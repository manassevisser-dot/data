

// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       899
// Timestamp:     2026-02-06T08:17:35.668Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       900
// Timestamp:     2026-02-06T08:17:35.674Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       901
// Timestamp:     2026-02-06T08:17:35.674Z
// ==========================================================
// ‚úì Geen state management
// ‚úì Geen business logic
// ‚úì Geen API calls
// ‚úì Props-driven


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       902
// Timestamp:     2026-02-06T08:17:35.674Z
// ==========================================================
// 1. LOGICA IN COMPONENT (zou niet moeten)
const isSelected = selected === true;
const hasError = error === true;

// 2. STYLE BEREKENINGEN (presentatie-logica)
const containerStyle = [
  styles.chip, 
  isSelected ? styles.chipSelected : null, 
  hasError ? styles.chipError : null
];

// 3. FALLBACK LOGICA
accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}

// 4. CONDITIONAL RENDERING VAN STYLES
style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       903
// Timestamp:     2026-02-06T08:17:35.675Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       904
// Timestamp:     2026-02-06T08:17:35.675Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       905
// Timestamp:     2026-02-06T08:17:35.675Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       906
// Timestamp:     2026-02-06T08:17:35.675Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       907
// Timestamp:     2026-02-06T08:17:35.675Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       908
// Timestamp:     2026-02-06T08:17:35.675Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       909
// Timestamp:     2026-02-06T08:17:35.675Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       910
// Timestamp:     2026-02-06T08:17:35.675Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       911
// Timestamp:     2026-02-06T08:17:35.675Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       912
// Timestamp:     2026-02-06T08:17:35.679Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       913
// Timestamp:     2026-02-06T08:17:35.682Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       914
// Timestamp:     2026-02-06T08:17:35.682Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       915
// Timestamp:     2026-02-06T08:17:35.682Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       916
// Timestamp:     2026-02-06T08:17:35.682Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       917
// Timestamp:     2026-02-06T08:17:35.682Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       918
// Timestamp:     2026-02-06T08:17:35.682Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       919
// Timestamp:     2026-02-06T08:17:35.682Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       920
// Timestamp:     2026-02-06T08:17:35.682Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       921
// Timestamp:     2026-02-06T08:17:35.682Z
// ==========================================================
FieldRenderer.tsx


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       922
// Timestamp:     2026-02-06T08:17:35.683Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       923
// Timestamp:     2026-02-06T08:17:35.683Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       924
// Timestamp:     2026-02-06T08:17:35.683Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       925
// Timestamp:     2026-02-06T08:17:35.683Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       926
// Timestamp:     2026-02-06T08:17:35.683Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       927
// Timestamp:     2026-02-06T08:17:35.683Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       928
// Timestamp:     2026-02-06T08:17:35.686Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       929
// Timestamp:     2026-02-06T08:17:35.691Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       930
// Timestamp:     2026-02-06T08:17:35.691Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       931
// Timestamp:     2026-02-06T08:17:35.691Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       932
// Timestamp:     2026-02-06T08:17:35.691Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       933
// Timestamp:     2026-02-06T08:17:35.691Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       934
// Timestamp:     2026-02-06T08:17:35.691Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       935
// Timestamp:     2026-02-06T08:17:35.691Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       936
// Timestamp:     2026-02-06T08:17:35.693Z
// ==========================================================
// Simplify to pure rendering
// Remove all helper functions
// Just map ComponentViewModel ‚Üí React


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       937
// Timestamp:     2026-02-06T08:17:35.694Z
// ==========================================================
// Change from props to viewModel
// Remove all internal logic


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       938
// Timestamp:     2026-02-06T08:17:35.694Z
// ==========================================================
// Change all imports from named to default:
// ‚ùå import { ChipButton } from '...'
// ‚úÖ import ChipButton from '...'


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       939
// Timestamp:     2026-02-06T08:17:35.695Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       940
// Timestamp:     2026-02-06T08:17:35.695Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       941
// Timestamp:     2026-02-06T08:17:35.695Z
// ==========================================================
ComponentViewModels.ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       942
// Timestamp:     2026-02-06T08:17:35.695Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       943
// Timestamp:     2026-02-06T08:17:35.695Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       944
// Timestamp:     2026-02-06T08:17:35.699Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       945
// Timestamp:     2026-02-06T08:17:35.700Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       946
// Timestamp:     2026-02-06T08:17:35.700Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@app/orchestrators/ComponentOrchestrator';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params)
 * ‚úÖ No logic (no complexity)
 * ‚úÖ Small (no max-lines)
 * ‚úÖ ADR-04 compliant
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering (if present) */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * 
 * Each case: 2-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case 'text':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       947
// Timestamp:     2026-02-06T08:17:35.701Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@app/orchestrators/ComponentOrchestrator';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params)
 * ‚úÖ No logic (no complexity)
 * ‚úÖ Small (no max-lines)
 * ‚úÖ ADR-04 compliant
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering (if present) */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * 
 * Each case: 2-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case 'text':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       948
// Timestamp:     2026-02-06T08:17:35.701Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@app/orchestrators/ComponentOrchestrator';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * No logic, no decisions - just render ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       949
// Timestamp:     2026-02-06T08:17:35.704Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@app/orchestrators/ComponentOrchestrator';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * No logic, no decisions - just render ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       950
// Timestamp:     2026-02-06T08:17:35.704Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       951
// Timestamp:     2026-02-06T08:17:35.704Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       952
// Timestamp:     2026-02-06T08:17:35.704Z
// ==========================================================
ComponentOrchestrator.ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       953
// Timestamp:     2026-02-06T08:17:35.704Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       954
// Timestamp:     2026-02-06T08:17:35.704Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       955
// Timestamp:     2026-02-06T08:17:35.704Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       956
// Timestamp:     2026-02-06T08:17:35.709Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       957
// Timestamp:     2026-02-06T08:17:35.709Z
// ==========================================================
// Nieuwe laag tussen domain en UI
ComponentOrchestrator
  ‚îî‚îÄ buildComponentViewModel(fieldVM, styles)
      ‚Üí ComponentViewModel (1 object met alles erin)

FieldRenderer
  ‚îî‚îÄ renderComponent(vm)  // 1 parameter!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       958
// Timestamp:     2026-02-06T08:17:35.710Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       959
// Timestamp:     2026-02-06T08:17:35.711Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       960
// Timestamp:     2026-02-06T08:17:35.711Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       961
// Timestamp:     2026-02-06T08:17:35.715Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       962
// Timestamp:     2026-02-06T08:17:35.719Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       963
// Timestamp:     2026-02-06T08:17:35.719Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       964
// Timestamp:     2026-02-06T08:17:35.719Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       965
// Timestamp:     2026-02-06T08:17:35.719Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       966
// Timestamp:     2026-02-06T08:17:35.719Z
// ==========================================================
// Voor: switch met 11 cases (complexity 11)
function renderFieldComponent(vm, onUpdate, styles, label) {
  switch (vm.componentType) {
    case 'counter': return renderCounter(...);
    case 'currency': return renderCurrency(...);
    // ... 9 more cases
    default: return renderFallback(...);
  }
}

// Na: gebruik lookup table (complexity 1)
const RENDER_MAP: Record<string, RenderFunction> = {
  'counter': renderCounter,
  'currency': renderCurrency,
  'chip-group': renderChipGroup,
  // ... etc
};

function renderFieldComponent(vm, onUpdate, styles, label) {
  const renderFn = RENDER_MAP[vm.componentType] ?? renderFallback;
  return renderFn(vm, onUpdate, styles, label);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       967
// Timestamp:     2026-02-06T08:17:35.719Z
// ==========================================================
// ‚úÖ Voeg ESLint exception toe met goede comment
/* eslint-disable max-params */
// REASON: Pure presentation functions - parameters are acceptable
// TODO: Consider ComponentOrchestrator pattern in future refactor


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       968
// Timestamp:     2026-02-06T08:17:35.719Z
// ==========================================================
// ‚úÖ Splits bestand (helpers apart)
// ‚úÖ Vervang switch door lookup table
// ‚úÖ Blijft functioneel hetzelfde


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       969
// Timestamp:     2026-02-06T08:17:35.720Z
// ==========================================================
// ‚úÖ Implementeer ComponentOrchestrator
// ‚úÖ Volledige ViewModel pattern
// ‚úÖ Perfect separation of concerns


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       970
// Timestamp:     2026-02-06T08:17:35.721Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       971
// Timestamp:     2026-02-06T08:17:35.724Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       972
// Timestamp:     2026-02-06T08:17:35.731Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       973
// Timestamp:     2026-02-06T08:17:35.731Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       974
// Timestamp:     2026-02-06T08:17:35.731Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       975
// Timestamp:     2026-02-06T08:17:35.731Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       976
// Timestamp:     2026-02-06T08:17:35.731Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       977
// Timestamp:     2026-02-06T08:17:35.731Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       978
// Timestamp:     2026-02-06T08:17:35.731Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       979
// Timestamp:     2026-02-06T08:17:35.734Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       980
// Timestamp:     2026-02-06T08:17:35.735Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       981
// Timestamp:     2026-02-06T08:17:35.735Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       982
// Timestamp:     2026-02-06T08:17:35.735Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       983
// Timestamp:     2026-02-06T08:17:35.735Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       984
// Timestamp:     2026-02-06T08:17:35.735Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       985
// Timestamp:     2026-02-06T08:17:35.736Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       986
// Timestamp:     2026-02-06T08:17:35.736Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       987
// Timestamp:     2026-02-06T08:17:35.736Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       988
// Timestamp:     2026-02-06T08:17:35.736Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       989
// Timestamp:     2026-02-06T08:17:35.739Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       990
// Timestamp:     2026-02-06T08:17:35.739Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       991
// Timestamp:     2026-02-06T08:17:35.739Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       992
// Timestamp:     2026-02-06T08:17:35.739Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       993
// Timestamp:     2026-02-06T08:17:35.739Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       994
// Timestamp:     2026-02-06T08:17:35.739Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       995
// Timestamp:     2026-02-06T08:17:35.739Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       996
// Timestamp:     2026-02-06T08:17:35.739Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       997
// Timestamp:     2026-02-06T08:17:35.739Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       998
// Timestamp:     2026-02-06T08:17:35.740Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       999
// Timestamp:     2026-02-06T08:17:35.750Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1000
// Timestamp:     2026-02-06T08:17:35.751Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1001
// Timestamp:     2026-02-06T08:17:35.751Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1002
// Timestamp:     2026-02-06T08:17:35.752Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1003
// Timestamp:     2026-02-06T08:17:35.754Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1004
// Timestamp:     2026-02-06T08:17:35.756Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1005
// Timestamp:     2026-02-06T08:17:35.757Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1006
// Timestamp:     2026-02-06T08:17:35.758Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Step 2: Transform to ComponentViewModels (presentation level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm) => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1007
// Timestamp:     2026-02-06T08:17:35.758Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Step 2: Transform to ComponentViewModels (presentation level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm) => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1008
// Timestamp:     2026-02-06T08:17:35.758Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1009
// Timestamp:     2026-02-06T08:17:35.760Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1010
// Timestamp:     2026-02-06T08:17:35.764Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1011
// Timestamp:     2026-02-06T08:17:35.764Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1012
// Timestamp:     2026-02-06T08:17:35.764Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1013
// Timestamp:     2026-02-06T08:17:35.764Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1014
// Timestamp:     2026-02-06T08:17:35.766Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  // ==================== HOUSEHOLD SETUP ====================
  
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    constraintsKey: 'aantalMensen',
    defaultValue: 1,
  },
  
  aantalVolwassen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_VOLWASSENEN',
    visibilityRuleName: 'isAdultInputVisible',
    constraintsKey: 'aantalVolwassen',
    uiModel: 'numericWrapper',
  },
  
  kinderenLabel: {
    componentType: COMPONENT_TYPES.LABEL,  // ‚Üê SSOT!
    labelToken: 'LABEL_KINDEREN',
    visibilityRuleName: 'calculateChildrenCount',
    isDerived: true,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },

  heeftHuisdieren: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_HUISDIEREN',
    optionsKey: 'isBoolean', 
    defaultValue: 'Nee',
  },
  
  // ==================== HOUSEHOLD DETAILS ====================
  
  burgerlijkeStaat: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_BURGERLIJKE_STAAT',
    visibilityRuleName: 'showMaritalStatus',
    optionsKey: 'burgerlijkeStaat',
  },
  
  woningType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_WONING_TYPE',
    optionsKey: 'woningType',
    defaultValue: 'Huur',
  },
  
  postcode: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_POSTCODE',
    placeholderToken: '1234',
    visibilityRuleName: 'showPostcode',
    constraintsKey: 'postcode',
  },
  
  // ==================== MEMBER FIELDS ====================
  
  naam: {
    componentType: COMPONENT_TYPES.TEXT,  // ‚Üê SSOT!
    labelToken: 'LABEL_NAME',
    placeholderToken: 'PLACEHOLDER_NAME',
    constraintsKey: 'naam',
  },
  
  leeftijd: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AGE',
    constraintsKey: 'leeftijd',
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',
  },
  
  // ==================== INCOME FIELDS ====================
  
  incomeCategory: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_INCOME_CATS',
    optionsKey: 'incomeCategory',
  },
  
  aow_bedrag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_AOW_BEDRAG',
    placeholderToken: '0.00',
    visibilityRuleName: 'isPensionado',
    constraintsKey: 'nettoSalaris',
  },

  nettoSalaris: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_NETTO_SALARIS',
    placeholderToken: '0.00',
    visibilityRuleName: 'hasWorkSelected',
    constraintsKey: 'nettoSalaris',
  },
  
  frequentie: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_FREQUENTIE',
    optionsKey: 'incomeFrequency',
  },
  
  vakantiegeldPerJaar: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_VAKANTIEGELD_JAAR',
    placeholderToken: '0.00',
    constraintsKey: 'vakantiegeldPerJaar',
  },
  
  uitkeringType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_UITKERING_TYPE',
    visibilityRuleName: 'hasBenefitSelected',
    optionsKey: 'uitkeringType',
  },
  
  zorgtoeslag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_ZORGTOESLAG',
    placeholderToken: 'LABEL_ZORGTOESLAG_PM',
    constraintsKey: 'zorgtoeslag',
  },
  
  // ... add rest of fields using COMPONENT_TYPES.XXX
};

export function getFieldDefinition(fieldId: string): FieldDefinition | null {
  return FIELD_REGISTRY[fieldId] ?? null;
}

export function isKnownField(fieldId: string): boolean {
  return fieldId in FIELD_REGISTRY;
}

export function getFieldsByComponentType(type: ComponentType): string[] {
  return Object.entries(FIELD_REGISTRY)
    .filter(([_, def]) => def.componentType === type)
    .map(([fieldId]) => fieldId);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1015
// Timestamp:     2026-02-06T08:17:35.771Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  // ==================== HOUSEHOLD SETUP ====================
  
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    constraintsKey: 'aantalMensen',
    defaultValue: 1,
  },
  
  aantalVolwassen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_VOLWASSENEN',
    visibilityRuleName: 'isAdultInputVisible',
    constraintsKey: 'aantalVolwassen',
    uiModel: 'numericWrapper',
  },
  
  kinderenLabel: {
    componentType: COMPONENT_TYPES.LABEL,  // ‚Üê SSOT!
    labelToken: 'LABEL_KINDEREN',
    visibilityRuleName: 'calculateChildrenCount',
    isDerived: true,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },

  heeftHuisdieren: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_HUISDIEREN',
    optionsKey: 'isBoolean', 
    defaultValue: 'Nee',
  },
  
  // ==================== HOUSEHOLD DETAILS ====================
  
  burgerlijkeStaat: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_BURGERLIJKE_STAAT',
    visibilityRuleName: 'showMaritalStatus',
    optionsKey: 'burgerlijkeStaat',
  },
  
  woningType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_WONING_TYPE',
    optionsKey: 'woningType',
    defaultValue: 'Huur',
  },
  
  postcode: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_POSTCODE',
    placeholderToken: '1234',
    visibilityRuleName: 'showPostcode',
    constraintsKey: 'postcode',
  },
  
  // ==================== MEMBER FIELDS ====================
  
  naam: {
    componentType: COMPONENT_TYPES.TEXT,  // ‚Üê SSOT!
    labelToken: 'LABEL_NAME',
    placeholderToken: 'PLACEHOLDER_NAME',
    constraintsKey: 'naam',
  },
  
  leeftijd: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AGE',
    constraintsKey: 'leeftijd',
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',
  },
  
  // ==================== INCOME FIELDS ====================
  
  incomeCategory: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_INCOME_CATS',
    optionsKey: 'incomeCategory',
  },
  
  aow_bedrag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_AOW_BEDRAG',
    placeholderToken: '0.00',
    visibilityRuleName: 'isPensionado',
    constraintsKey: 'nettoSalaris',
  },

  nettoSalaris: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_NETTO_SALARIS',
    placeholderToken: '0.00',
    visibilityRuleName: 'hasWorkSelected',
    constraintsKey: 'nettoSalaris',
  },
  
  frequentie: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_FREQUENTIE',
    optionsKey: 'incomeFrequency',
  },
  
  vakantiegeldPerJaar: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_VAKANTIEGELD_JAAR',
    placeholderToken: '0.00',
    constraintsKey: 'vakantiegeldPerJaar',
  },
  
  uitkeringType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_UITKERING_TYPE',
    visibilityRuleName: 'hasBenefitSelected',
    optionsKey: 'uitkeringType',
  },
  
  zorgtoeslag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_ZORGTOESLAG',
    placeholderToken: 'LABEL_ZORGTOESLAG_PM',
    constraintsKey: 'zorgtoeslag',
  },
  
  // ... add rest of fields using COMPONENT_TYPES.XXX
};

export function getFieldDefinition(fieldId: string): FieldDefinition | null {
  return FIELD_REGISTRY[fieldId] ?? null;
}

export function isKnownField(fieldId: string): boolean {
  return fieldId in FIELD_REGISTRY;
}

export function getFieldsByComponentType(type: ComponentType): string[] {
  return Object.entries(FIELD_REGISTRY)
    .filter(([_, def]) => def.componentType === type)
    .map(([fieldId]) => fieldId);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1016
// Timestamp:     2026-02-06T08:17:35.771Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1017
// Timestamp:     2026-02-06T08:17:35.771Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1018
// Timestamp:     2026-02-06T08:17:35.771Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/registry/ComponentRegistry';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * 
 * No logic, no decisions - just render ViewModel
 * All style/state logic done in ComponentOrchestrator
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1019
// Timestamp:     2026-02-06T08:17:35.771Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/registry/ComponentRegistry';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * 
 * No logic, no decisions - just render ViewModel
 * All style/state logic done in ComponentOrchestrator
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1020
// Timestamp:     2026-02-06T08:17:35.771Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1021
// Timestamp:     2026-02-06T08:17:35.772Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1022
// Timestamp:     2026-02-06T08:17:35.772Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1023
// Timestamp:     2026-02-06T08:17:35.772Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1024
// Timestamp:     2026-02-06T08:17:35.775Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1025
// Timestamp:     2026-02-06T08:17:35.775Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, geen FSO!
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1026
// Timestamp:     2026-02-06T08:17:35.777Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1027
// Timestamp:     2026-02-06T08:17:35.779Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1028
// Timestamp:     2026-02-06T08:17:35.780Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1029
// Timestamp:     2026-02-06T08:17:35.780Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1030
// Timestamp:     2026-02-06T08:17:35.782Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1031
// Timestamp:     2026-02-06T08:17:35.783Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1032
// Timestamp:     2026-02-06T08:17:35.783Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1033
// Timestamp:     2026-02-06T08:17:35.784Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1034
// Timestamp:     2026-02-06T08:17:35.785Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1035
// Timestamp:     2026-02-06T08:17:35.786Z
// ==========================================================
/**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1036
// Timestamp:     2026-02-06T08:17:35.787Z
// ==========================================================
options (2).ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1037
// Timestamp:     2026-02-06T08:17:35.789Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1038
// Timestamp:     2026-02-06T08:17:35.789Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1039
// Timestamp:     2026-02-06T08:17:35.789Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1040
// Timestamp:     2026-02-06T08:17:35.789Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1041
// Timestamp:     2026-02-06T08:17:35.789Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1042
// Timestamp:     2026-02-06T08:17:35.790Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1043
// Timestamp:     2026-02-06T08:17:35.792Z
// ==========================================================
// RenderOrchestrator.buildFieldViewModel() returns:
return {
  fieldId: 'aantalMensen',
  componentType: 'counter',  // ‚Üê Already from FieldRegistry
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1044
// Timestamp:     2026-02-06T08:17:35.792Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1045
// Timestamp:     2026-02-06T08:17:35.792Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1046
// Timestamp:     2026-02-06T08:17:35.792Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1047
// Timestamp:     2026-02-06T08:17:35.793Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1048
// Timestamp:     2026-02-06T08:17:35.793Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1049
// Timestamp:     2026-02-06T08:17:35.793Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1050
// Timestamp:     2026-02-06T08:17:35.793Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Single Entry Point - Owns ALL orchestrators
 * 
 * ARCHITECTURE PRINCIPLES:
 * ‚úÖ All orchestrators instantiated here (Master owns everything)
 * ‚úÖ No horizontal dependencies (orchestrators don't know each other)
 * ‚úÖ All state mutations flow through updateField()
 * ‚úÖ Orchestrators receive callbacks, not direct references
 * ‚úÖ Public facades expose read-only orchestrators
 * ‚úÖ Private orchestrators accessed via Master API only
 * 
 * RESPONSIBILITIES:
 * - Orchestrator lifecycle management (instantiation, ownership)
 * - State mutation coordination (single entry point)
 * - Facade provision (controlled access to orchestrators)
 * - Integration coordination (CSV import, financial updates)
 * 
 * DOES NOT:
 * - Duplicate registry data (componentType, options)
 * - Implement business logic (delegated to domain)
 * - Directly mutate state (via FormStateOrchestrator)
 */
export class MasterOrchestrator {
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC FACADES - Read-only orchestrators for UI
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PRIVATE ORCHESTRATORS - Accessed via Master API only
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  private readonly component: ComponentOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * CONSTRUCTOR - Instantiates and wires all orchestrators
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles hook
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators with minimal dependencies
    this.fso = new FormStateOrchestrator(getState, dispatch);
    
    // Visibility depends on FSO (for value lookup) and TimeProvider
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // Render depends on FSO and Visibility (vertical dependency)
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // Research depends only on FSO
    this.research = new ResearchOrchestrator(this.fso);
    
    // Component depends on NO orchestrators - only callback and styles!
    // This prevents horizontal dependencies
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator.
   * Maintains vertical architecture (no direct access from UI).
   * 
   * @param fieldViewModel - Business-level ViewModel from RenderOrchestrator
   * @returns ComponentViewModel ready for rendering, or null if invalid
   * 
   * @example
   * const fieldVM = master.render.buildFieldViewModel('aantalMensen');
   * const componentVM = master.buildComponentViewModel(fieldVM);
   * // Pass componentVM to FieldRenderer
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VISIBILITY
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Evaluate visibility rule
   * 
   * Used by UI to determine if field/section should be shown.
   * Delegates to VisibilityOrchestrator.
   * 
   * @param ruleName - Name of visibility rule (from fieldVisibility.ts)
   * @param context - Optional context (memberId, targetWoningType, etc.)
   * @returns true if field should be visible
   * 
   * @example
   * if (master.isVisible('isAdultInputVisible')) {
   *   // Show aantalVolwassen field
   * }
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: STATE MUTATIONS (Single Entry Point)
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Update field value
   * 
   * **CRITICAL: This is the ONLY method that mutates state!**
   * 
   * Flow:
   * 1. Validate at boundary (Zod schema)
   * 2. Update field via FormStateOrchestrator
   * 3. Recompute financial summary (if applicable)
   * 4. Update ViewModel
   * 
   * Used by:
   * - UI components directly
   * - ComponentOrchestrator callbacks (pre-bound in constructor)
   * - Any orchestrator that needs to mutate state
   * 
   * @param fieldId - Field identifier
   * @param value - New value (will be validated)
   */
  public updateField(fieldId: string, value: unknown): void {
    // Boundary validation (Zod)
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    // Update state via FSO
    this.fso.updateField(fieldId, result.data);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: CSV IMPORT
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Handle CSV import (bank transactions)
   * 
   * Flow:
   * 1. Process CSV via ImportOrchestrator
   * 2. Update transactions in state
   * 3. Recompute financial summary
   * 4. Log success or discrepancies
   * 
   * @param csvText - Raw CSV content
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    // Process CSV through ImportOrchestrator
    // Note: ImportOrchestrator uses ResearchOrchestrator instance (DI)
    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    // Update transactions
    this.fso.updateField('transactions', result.transactions);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    // Log results
    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALUE GETTERS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Get current field value
   * 
   * Delegates to FormStateOrchestrator.
   * 
   * @param fieldId - Field identifier
   * @returns Current value or undefined
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  /**
   * Get formatted date value
   * 
   * Converts Date or date string to formatted display string.
   * 
   * @param fieldId - Field identifier
   * @param format - Display format
   * @returns Formatted date string or empty string
   */
  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALIDATION
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Validate field value
   * 
   * Validates against Zod schema at boundary.
   * 
   * @param fieldId - Field identifier
   * @param value - Value to validate
   * @returns Error message or null if valid
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1051
// Timestamp:     2026-02-06T08:17:35.794Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Single Entry Point - Owns ALL orchestrators
 * 
 * ARCHITECTURE PRINCIPLES:
 * ‚úÖ All orchestrators instantiated here (Master owns everything)
 * ‚úÖ No horizontal dependencies (orchestrators don't know each other)
 * ‚úÖ All state mutations flow through updateField()
 * ‚úÖ Orchestrators receive callbacks, not direct references
 * ‚úÖ Public facades expose read-only orchestrators
 * ‚úÖ Private orchestrators accessed via Master API only
 * 
 * RESPONSIBILITIES:
 * - Orchestrator lifecycle management (instantiation, ownership)
 * - State mutation coordination (single entry point)
 * - Facade provision (controlled access to orchestrators)
 * - Integration coordination (CSV import, financial updates)
 * 
 * DOES NOT:
 * - Duplicate registry data (componentType, options)
 * - Implement business logic (delegated to domain)
 * - Directly mutate state (via FormStateOrchestrator)
 */
export class MasterOrchestrator {
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC FACADES - Read-only orchestrators for UI
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PRIVATE ORCHESTRATORS - Accessed via Master API only
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  private readonly component: ComponentOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * CONSTRUCTOR - Instantiates and wires all orchestrators
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles hook
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators with minimal dependencies
    this.fso = new FormStateOrchestrator(getState, dispatch);
    
    // Visibility depends on FSO (for value lookup) and TimeProvider
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // Render depends on FSO and Visibility (vertical dependency)
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // Research depends only on FSO
    this.research = new ResearchOrchestrator(this.fso);
    
    // Component depends on NO orchestrators - only callback and styles!
    // This prevents horizontal dependencies
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator.
   * Maintains vertical architecture (no direct access from UI).
   * 
   * @param fieldViewModel - Business-level ViewModel from RenderOrchestrator
   * @returns ComponentViewModel ready for rendering, or null if invalid
   * 
   * @example
   * const fieldVM = master.render.buildFieldViewModel('aantalMensen');
   * const componentVM = master.buildComponentViewModel(fieldVM);
   * // Pass componentVM to FieldRenderer
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VISIBILITY
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Evaluate visibility rule
   * 
   * Used by UI to determine if field/section should be shown.
   * Delegates to VisibilityOrchestrator.
   * 
   * @param ruleName - Name of visibility rule (from fieldVisibility.ts)
   * @param context - Optional context (memberId, targetWoningType, etc.)
   * @returns true if field should be visible
   * 
   * @example
   * if (master.isVisible('isAdultInputVisible')) {
   *   // Show aantalVolwassen field
   * }
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: STATE MUTATIONS (Single Entry Point)
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Update field value
   * 
   * **CRITICAL: This is the ONLY method that mutates state!**
   * 
   * Flow:
   * 1. Validate at boundary (Zod schema)
   * 2. Update field via FormStateOrchestrator
   * 3. Recompute financial summary (if applicable)
   * 4. Update ViewModel
   * 
   * Used by:
   * - UI components directly
   * - ComponentOrchestrator callbacks (pre-bound in constructor)
   * - Any orchestrator that needs to mutate state
   * 
   * @param fieldId - Field identifier
   * @param value - New value (will be validated)
   */
  public updateField(fieldId: string, value: unknown): void {
    // Boundary validation (Zod)
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    // Update state via FSO
    this.fso.updateField(fieldId, result.data);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: CSV IMPORT
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Handle CSV import (bank transactions)
   * 
   * Flow:
   * 1. Process CSV via ImportOrchestrator
   * 2. Update transactions in state
   * 3. Recompute financial summary
   * 4. Log success or discrepancies
   * 
   * @param csvText - Raw CSV content
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    // Process CSV through ImportOrchestrator
    // Note: ImportOrchestrator uses ResearchOrchestrator instance (DI)
    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    // Update transactions
    this.fso.updateField('transactions', result.transactions);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    // Log results
    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALUE GETTERS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Get current field value
   * 
   * Delegates to FormStateOrchestrator.
   * 
   * @param fieldId - Field identifier
   * @returns Current value or undefined
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  /**
   * Get formatted date value
   * 
   * Converts Date or date string to formatted display string.
   * 
   * @param fieldId - Field identifier
   * @param format - Display format
   * @returns Formatted date string or empty string
   */
  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALIDATION
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Validate field value
   * 
   * Validates against Zod schema at boundary.
   * 
   * @param fieldId - Field identifier
   * @param value - Value to validate
   * @returns Error message or null if valid
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1052
// Timestamp:     2026-02-06T08:17:35.794Z
// ==========================================================
// ‚ùå FOUT - Deze stonden erin, nu weg:
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1053
// Timestamp:     2026-02-06T08:17:35.794Z
// ==========================================================
/**
 * DEPENDENCY GRAPH (Geen horizontale pijlen!)
 * 
 *     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *     ‚îÇ     MASTER ORCHESTRATOR              ‚îÇ
 *     ‚îÇ     (owns & instantiates all)        ‚îÇ
 *     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *            ‚Üì          ‚Üì          ‚Üì          ‚Üì
 *      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *      ‚îÇ   FSO   ‚îÇ ‚îÇ Render  ‚îÇ ‚îÇVisibility‚îÇ ‚îÇComponent‚îÇ
 *      ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ (private)‚îÇ
 *      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                       ‚Üì           ‚Üë
 *                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                     (Vertical OK!)
 * 
 * ‚úÖ NO horizontal arrows
 * ‚úÖ ALL via Master (or vertical: Render‚ÜíVisibility)
 * ‚úÖ Component gets callback, not FSO
 */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1054
// Timestamp:     2026-02-06T08:17:35.794Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1055
// Timestamp:     2026-02-06T08:17:35.795Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1056
// Timestamp:     2026-02-06T08:17:35.795Z
// ==========================================================
new RenderOrchestrator(
  fso,
  (ruleName, context) => this.visibility.evaluate(ruleName, context)  // callback!
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1057
// Timestamp:     2026-02-06T08:17:35.795Z
// ==========================================================
// RenderOrchestrator build ZONDER visibility check
const fieldVM = orchestrator.render.buildFieldViewModelRaw(fieldId);

// Master doet visibility
if (fieldVM.visibilityRule && !orchestrator.isVisible(fieldVM.visibilityRule)) {
  return null;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1058
// Timestamp:     2026-02-06T08:17:35.795Z
// ==========================================================
// ComponentOrchestrator: ‚úÖ Krijgt callback (geen directe FSO)
this.component = new ComponentOrchestrator(
  (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Callback!
  styles
);

// RenderOrchestrator: ‚ùå Krijgt directe Visibility (horizontaal!)
this.render = new RenderOrchestrator(
  this.fso,
  this.visibility  // ‚Üê Direct! Horizontale dependency!
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1059
// Timestamp:     2026-02-06T08:17:35.795Z
// ==========================================================
// Master constructor
this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);

this.render = new RenderOrchestrator(
  this.fso,
  (ruleName: string, context?: VisibilityContext) => 
    this.visibility.evaluate(ruleName, context)  // ‚Üê Callback!
);

this.component = new ComponentOrchestrator(
  (fieldId: string, value: unknown) => this.updateField(fieldId, value),
  styles
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1060
// Timestamp:     2026-02-06T08:17:35.796Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1061
// Timestamp:     2026-02-06T08:17:35.796Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1062
// Timestamp:     2026-02-06T08:17:35.797Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1063
// Timestamp:     2026-02-06T08:17:35.798Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1064
// Timestamp:     2026-02-06T08:17:35.798Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1065
// Timestamp:     2026-02-06T08:17:35.798Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1066
// Timestamp:     2026-02-06T08:17:35.799Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1067
// Timestamp:     2026-02-06T08:17:35.799Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1068
// Timestamp:     2026-02-06T08:17:35.799Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // ‚úÖ RenderOrchestrator has NO visibility dependency!
    this.render = new RenderOrchestrator(this.fso);
    
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Build FieldViewModel WITH Visibility
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build field ViewModel with visibility evaluation
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility rule
   * 
   * Returns null if field is unknown OR not visible.
   * 
   * @param fieldId - Field identifier
   * @param context - Visibility context (memberId, etc.)
   * @returns FieldViewModel if visible, null if hidden
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Evaluate visibility (Master decides!)
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master hides field
      }
    }

    // Field is visible - return ViewModel
    return rawViewModel;
  }

  /**
   * Build page ViewModels (batch)
   * 
   * Convenience method for building multiple fields at once.
   * Filters out hidden fields automatically.
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * Assumes visibility already checked by buildFieldViewModel!
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel directly from fieldId (convenience)
   * 
   * Two-step process:
   * 1. Build FieldViewModel (with visibility)
   * 2. Transform to ComponentViewModel
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    return this.buildComponentViewModel(fieldViewModel);
  }

  // ... rest of Master methods (updateField, etc.)
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1069
// Timestamp:     2026-02-06T08:17:35.799Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // ‚úÖ RenderOrchestrator has NO visibility dependency!
    this.render = new RenderOrchestrator(this.fso);
    
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Build FieldViewModel WITH Visibility
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build field ViewModel with visibility evaluation
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility rule
   * 
   * Returns null if field is unknown OR not visible.
   * 
   * @param fieldId - Field identifier
   * @param context - Visibility context (memberId, etc.)
   * @returns FieldViewModel if visible, null if hidden
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Evaluate visibility (Master decides!)
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master hides field
      }
    }

    // Field is visible - return ViewModel
    return rawViewModel;
  }

  /**
   * Build page ViewModels (batch)
   * 
   * Convenience method for building multiple fields at once.
   * Filters out hidden fields automatically.
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * Assumes visibility already checked by buildFieldViewModel!
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel directly from fieldId (convenience)
   * 
   * Two-step process:
   * 1. Build FieldViewModel (with visibility)
   * 2. Transform to ComponentViewModel
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    return this.buildComponentViewModel(fieldViewModel);
  }

  // ... rest of Master methods (updateField, etc.)
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1070
// Timestamp:     2026-02-06T08:17:35.801Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1071
// Timestamp:     2026-02-06T08:17:35.801Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1072
// Timestamp:     2026-02-06T08:17:35.802Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator  // ‚Üê Direct!
)

// In buildFieldViewModel
const isVisible = this.visibility.evaluate(ruleName, context);  // ‚Üê Direct call!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1073
// Timestamp:     2026-02-06T08:17:35.802Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator
  // ‚Üê NO visibility!
)

// Master doet:
const rawVM = this.render.buildFieldViewModel(fieldId);
const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1074
// Timestamp:     2026-02-06T08:17:35.802Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1075
// Timestamp:     2026-02-06T08:17:35.803Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1076
// Timestamp:     2026-02-06T08:17:35.803Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1077
// Timestamp:     2026-02-06T08:17:35.803Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1078
// Timestamp:     2026-02-06T08:17:35.805Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1079
// Timestamp:     2026-02-06T08:17:35.805Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1080
// Timestamp:     2026-02-06T08:17:35.805Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1081
// Timestamp:     2026-02-06T08:17:35.806Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1082
// Timestamp:     2026-02-06T08:17:35.806Z
// ==========================================================
// ‚ùå FOUT - Horizontaal
this.render = new RenderOrchestrator(this.fso, this.visibility);

// ‚úÖ GOED - Alleen FSO
this.render = new RenderOrchestrator(this.fso);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1083
// Timestamp:     2026-02-06T08:17:35.807Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from registry + state.
 * NO visibility evaluation - Master does that.
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
  ) {}

  public buildFieldViewModel(fieldId: string): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value: this.fso.getValue(fieldId),
      options: getOptionsForField(fieldId),
      visibilityRuleName: fieldDef.visibilityRuleName,
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1084
// Timestamp:     2026-02-06T08:17:35.807Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from registry + state.
 * NO visibility evaluation - Master does that.
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
  ) {}

  public buildFieldViewModel(fieldId: string): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value: this.fso.getValue(fieldId),
      options: getOptionsForField(fieldId),
      visibilityRuleName: fieldDef.visibilityRuleName,
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1085
// Timestamp:     2026-02-06T08:17:35.809Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator, FieldViewModel } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * PHOENIX MASTER ORCHESTRATOR
 * 
 * ENIGE plaats waar orchestrators elkaar "ontmoeten"
 * Alle communicatie verloopt via deze Master
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  private readonly render: RenderOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚úÖ NO orchestrator dependencies
    this.render = new RenderOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * Build FieldViewModel met visibility check
   * 
   * Master co√∂rdineert:
   * 1. Render bouwt ViewModel
   * 2. Visibility evalueert rule
   * 3. Master besluit: toon of verberg
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // 1. Render bouwt ViewModel
    const viewModel = this.render.buildFieldViewModel(fieldId);
    if (!viewModel) return null;

    // 2. Visibility evalueert (als er een rule is)
    if (viewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        viewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) return null;
    }

    // 3. Return visible ViewModel
    return viewModel;
  }

  /**
   * Build meerdere FieldViewModels (batch)
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * Build ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel direct van fieldId (convenience)
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;
    return this.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Visibility check (facade)
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ENIGE mutatie entry point
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1086
// Timestamp:     2026-02-06T08:17:35.810Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator, FieldViewModel } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * PHOENIX MASTER ORCHESTRATOR
 * 
 * ENIGE plaats waar orchestrators elkaar "ontmoeten"
 * Alle communicatie verloopt via deze Master
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  private readonly render: RenderOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚úÖ NO orchestrator dependencies
    this.render = new RenderOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * Build FieldViewModel met visibility check
   * 
   * Master co√∂rdineert:
   * 1. Render bouwt ViewModel
   * 2. Visibility evalueert rule
   * 3. Master besluit: toon of verberg
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // 1. Render bouwt ViewModel
    const viewModel = this.render.buildFieldViewModel(fieldId);
    if (!viewModel) return null;

    // 2. Visibility evalueert (als er een rule is)
    if (viewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        viewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) return null;
    }

    // 3. Return visible ViewModel
    return viewModel;
  }

  /**
   * Build meerdere FieldViewModels (batch)
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * Build ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel direct van fieldId (convenience)
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;
    return this.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Visibility check (facade)
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ENIGE mutatie entry point
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1087
// Timestamp:     2026-02-06T08:17:35.811Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1088
// Timestamp:     2026-02-06T08:17:35.812Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1089
// Timestamp:     2026-02-06T08:17:35.812Z
// ==========================================================
// ‚ùå DELETE deze 2 methoden uit MasterOrchestrator:
public getComponentType(fieldId: string, baseType: string): string { ... }
public getOptions(fieldId: string): readonly string[] { ... }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1090
// Timestamp:     2026-02-06T08:17:35.812Z
// ==========================================================
"resource": "/home/user/pre7/src/ui/components/FieldRenderer.tsx",
"owner": "typescript",
"code": "2614",
"severity": 8,
"message": "Module '\"@ui/components/fields/MoneyInput\"' has no exported member 'MoneyInput'. Did you mean to use 'import MoneyInput from \"@ui/components/fields/Monpastedde fieldRenderer ziet er nu zo uit en geeft bijbehorende eslint-issues (welke ik deels oplos door de ui-componenten aan te pakken - niet de fieldrenderer). Past jouw voorstel bij deze fieldrenderer?08:00Onderzocht hoe ViewModel-aanpak FieldRenderer kan vereenvoudigenLaten we de huidige  analyseren in het licht van mijn voorstel over het "dommer" maken van de UI.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1091
// Timestamp:     2026-02-06T08:17:35.823Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1092
// Timestamp:     2026-02-06T08:17:35.827Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1093
// Timestamp:     2026-02-06T08:17:35.827Z
// ==========================================================
// ‚úì Geen state management
// ‚úì Geen business logic
// ‚úì Geen API calls
// ‚úì Props-driven


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1094
// Timestamp:     2026-02-06T08:17:35.827Z
// ==========================================================
// 1. LOGICA IN COMPONENT (zou niet moeten)
const isSelected = selected === true;
const hasError = error === true;

// 2. STYLE BEREKENINGEN (presentatie-logica)
const containerStyle = [
  styles.chip, 
  isSelected ? styles.chipSelected : null, 
  hasError ? styles.chipError : null
];

// 3. FALLBACK LOGICA
accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}

// 4. CONDITIONAL RENDERING VAN STYLES
style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1095
// Timestamp:     2026-02-06T08:17:35.829Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1096
// Timestamp:     2026-02-06T08:17:35.830Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1097
// Timestamp:     2026-02-06T08:17:35.830Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1098
// Timestamp:     2026-02-06T08:17:35.830Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1099
// Timestamp:     2026-02-06T08:17:35.831Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1100
// Timestamp:     2026-02-06T08:17:35.831Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1101
// Timestamp:     2026-02-06T08:17:35.832Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1102
// Timestamp:     2026-02-06T08:17:35.834Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1103
// Timestamp:     2026-02-06T08:17:35.835Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1104
// Timestamp:     2026-02-06T08:17:35.835Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1105
// Timestamp:     2026-02-06T08:17:35.835Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1106
// Timestamp:     2026-02-06T08:17:35.835Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1107
// Timestamp:     2026-02-06T08:17:35.835Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1108
// Timestamp:     2026-02-06T08:17:35.836Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1109
// Timestamp:     2026-02-06T08:17:35.836Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1110
// Timestamp:     2026-02-06T08:17:35.836Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1111
// Timestamp:     2026-02-06T08:17:35.836Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1112
// Timestamp:     2026-02-06T08:17:35.837Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1113
// Timestamp:     2026-02-06T08:17:35.837Z
// ==========================================================
FieldRenderer.tsx


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1114
// Timestamp:     2026-02-06T08:17:35.837Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1115
// Timestamp:     2026-02-06T08:17:35.838Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1116
// Timestamp:     2026-02-06T08:17:35.839Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1117
// Timestamp:     2026-02-06T08:17:35.839Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1118
// Timestamp:     2026-02-06T08:17:35.840Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1119
// Timestamp:     2026-02-06T08:17:35.842Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1120
// Timestamp:     2026-02-06T08:17:35.842Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1121
// Timestamp:     2026-02-06T08:17:35.844Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1122
// Timestamp:     2026-02-06T08:17:35.845Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1123
// Timestamp:     2026-02-06T08:17:35.846Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1124
// Timestamp:     2026-02-06T08:17:35.846Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1125
// Timestamp:     2026-02-06T08:17:35.846Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1126
// Timestamp:     2026-02-06T08:17:35.846Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1127
// Timestamp:     2026-02-06T08:17:35.846Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1128
// Timestamp:     2026-02-06T08:17:35.846Z
// ==========================================================
// Simplify to pure rendering
// Remove all helper functions
// Just map ComponentViewModel ‚Üí React


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1129
// Timestamp:     2026-02-06T08:17:35.847Z
// ==========================================================
// Change from props to viewModel
// Remove all internal logic


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1130
// Timestamp:     2026-02-06T08:17:35.847Z
// ==========================================================
// Change all imports from named to default:
// ‚ùå import { ChipButton } from '...'
// ‚úÖ import ChipButton from '...'


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1131
// Timestamp:     2026-02-06T08:17:35.847Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1132
// Timestamp:     2026-02-06T08:17:35.847Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1133
// Timestamp:     2026-02-06T08:17:35.847Z
// ==========================================================
ComponentViewModels.ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1134
// Timestamp:     2026-02-06T08:17:35.847Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1135
// Timestamp:     2026-02-06T08:17:35.849Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1136
// Timestamp:     2026-02-06T08:17:35.850Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1137
// Timestamp:     2026-02-06T08:17:35.850Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1138
// Timestamp:     2026-02-06T08:17:35.851Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@app/orchestrators/ComponentOrchestrator';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params)
 * ‚úÖ No logic (no complexity)
 * ‚úÖ Small (no max-lines)
 * ‚úÖ ADR-04 compliant
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering (if present) */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * 
 * Each case: 2-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case 'text':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1139
// Timestamp:     2026-02-06T08:17:35.851Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@app/orchestrators/ComponentOrchestrator';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params)
 * ‚úÖ No logic (no complexity)
 * ‚úÖ Small (no max-lines)
 * ‚úÖ ADR-04 compliant
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering (if present) */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * 
 * Each case: 2-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case 'text':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1140
// Timestamp:     2026-02-06T08:17:35.851Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@app/orchestrators/ComponentOrchestrator';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * No logic, no decisions - just render ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1141
// Timestamp:     2026-02-06T08:17:35.851Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@app/orchestrators/ComponentOrchestrator';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * No logic, no decisions - just render ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1142
// Timestamp:     2026-02-06T08:17:35.854Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1143
// Timestamp:     2026-02-06T08:17:35.854Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1144
// Timestamp:     2026-02-06T08:17:35.854Z
// ==========================================================
ComponentOrchestrator.ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1145
// Timestamp:     2026-02-06T08:17:35.854Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1146
// Timestamp:     2026-02-06T08:17:35.854Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1147
// Timestamp:     2026-02-06T08:17:35.854Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1148
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1149
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
// Nieuwe laag tussen domain en UI
ComponentOrchestrator
  ‚îî‚îÄ buildComponentViewModel(fieldVM, styles)
      ‚Üí ComponentViewModel (1 object met alles erin)

FieldRenderer
  ‚îî‚îÄ renderComponent(vm)  // 1 parameter!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1150
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1151
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1152
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1153
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1154
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1155
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1156
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1157
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1158
// Timestamp:     2026-02-06T08:17:35.855Z
// ==========================================================
// Voor: switch met 11 cases (complexity 11)
function renderFieldComponent(vm, onUpdate, styles, label) {
  switch (vm.componentType) {
    case 'counter': return renderCounter(...);
    case 'currency': return renderCurrency(...);
    // ... 9 more cases
    default: return renderFallback(...);
  }
}

// Na: gebruik lookup table (complexity 1)
const RENDER_MAP: Record<string, RenderFunction> = {
  'counter': renderCounter,
  'currency': renderCurrency,
  'chip-group': renderChipGroup,
  // ... etc
};

function renderFieldComponent(vm, onUpdate, styles, label) {
  const renderFn = RENDER_MAP[vm.componentType] ?? renderFallback;
  return renderFn(vm, onUpdate, styles, label);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1159
// Timestamp:     2026-02-06T08:17:35.856Z
// ==========================================================
// ‚úÖ Voeg ESLint exception toe met goede comment
/* eslint-disable max-params */
// REASON: Pure presentation functions - parameters are acceptable
// TODO: Consider ComponentOrchestrator pattern in future refactor


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1160
// Timestamp:     2026-02-06T08:17:35.857Z
// ==========================================================
// ‚úÖ Splits bestand (helpers apart)
// ‚úÖ Vervang switch door lookup table
// ‚úÖ Blijft functioneel hetzelfde


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1161
// Timestamp:     2026-02-06T08:17:35.857Z
// ==========================================================
// ‚úÖ Implementeer ComponentOrchestrator
// ‚úÖ Volledige ViewModel pattern
// ‚úÖ Perfect separation of concerns


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1162
// Timestamp:     2026-02-06T08:17:35.857Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1163
// Timestamp:     2026-02-06T08:17:35.857Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1164
// Timestamp:     2026-02-06T08:17:35.857Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1165
// Timestamp:     2026-02-06T08:17:35.858Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1166
// Timestamp:     2026-02-06T08:17:35.859Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1167
// Timestamp:     2026-02-06T08:17:35.859Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1168
// Timestamp:     2026-02-06T08:17:35.859Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1169
// Timestamp:     2026-02-06T08:17:35.859Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1170
// Timestamp:     2026-02-06T08:17:35.859Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1171
// Timestamp:     2026-02-06T08:17:35.860Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1172
// Timestamp:     2026-02-06T08:17:35.861Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1173
// Timestamp:     2026-02-06T08:17:35.861Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1174
// Timestamp:     2026-02-06T08:17:35.861Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1175
// Timestamp:     2026-02-06T08:17:35.861Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1176
// Timestamp:     2026-02-06T08:17:35.861Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1177
// Timestamp:     2026-02-06T08:17:35.861Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1178
// Timestamp:     2026-02-06T08:17:35.861Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1179
// Timestamp:     2026-02-06T08:17:35.862Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1180
// Timestamp:     2026-02-06T08:17:35.862Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1181
// Timestamp:     2026-02-06T08:17:35.862Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1182
// Timestamp:     2026-02-06T08:17:35.864Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1183
// Timestamp:     2026-02-06T08:17:35.864Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1184
// Timestamp:     2026-02-06T08:17:35.864Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1185
// Timestamp:     2026-02-06T08:17:35.866Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1186
// Timestamp:     2026-02-06T08:17:35.866Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1187
// Timestamp:     2026-02-06T08:17:35.866Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1188
// Timestamp:     2026-02-06T08:17:35.867Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1189
// Timestamp:     2026-02-06T08:17:35.868Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1190
// Timestamp:     2026-02-06T08:17:35.869Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1191
// Timestamp:     2026-02-06T08:17:35.870Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1192
// Timestamp:     2026-02-06T08:17:35.870Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1193
// Timestamp:     2026-02-06T08:17:35.870Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1194
// Timestamp:     2026-02-06T08:17:35.870Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1195
// Timestamp:     2026-02-06T08:17:35.872Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1196
// Timestamp:     2026-02-06T08:17:35.873Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1197
// Timestamp:     2026-02-06T08:17:35.873Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1198
// Timestamp:     2026-02-06T08:17:35.873Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Step 2: Transform to ComponentViewModels (presentation level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm) => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1199
// Timestamp:     2026-02-06T08:17:35.876Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Step 2: Transform to ComponentViewModels (presentation level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm) => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1200
// Timestamp:     2026-02-06T08:17:35.876Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1201
// Timestamp:     2026-02-06T08:17:35.877Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1202
// Timestamp:     2026-02-06T08:17:35.877Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1203
// Timestamp:     2026-02-06T08:17:35.879Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1204
// Timestamp:     2026-02-06T08:17:35.879Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1205
// Timestamp:     2026-02-06T08:17:35.879Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1206
// Timestamp:     2026-02-06T08:17:35.880Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  // ==================== HOUSEHOLD SETUP ====================
  
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    constraintsKey: 'aantalMensen',
    defaultValue: 1,
  },
  
  aantalVolwassen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_VOLWASSENEN',
    visibilityRuleName: 'isAdultInputVisible',
    constraintsKey: 'aantalVolwassen',
    uiModel: 'numericWrapper',
  },
  
  kinderenLabel: {
    componentType: COMPONENT_TYPES.LABEL,  // ‚Üê SSOT!
    labelToken: 'LABEL_KINDEREN',
    visibilityRuleName: 'calculateChildrenCount',
    isDerived: true,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },

  heeftHuisdieren: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_HUISDIEREN',
    optionsKey: 'isBoolean', 
    defaultValue: 'Nee',
  },
  
  // ==================== HOUSEHOLD DETAILS ====================
  
  burgerlijkeStaat: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_BURGERLIJKE_STAAT',
    visibilityRuleName: 'showMaritalStatus',
    optionsKey: 'burgerlijkeStaat',
  },
  
  woningType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_WONING_TYPE',
    optionsKey: 'woningType',
    defaultValue: 'Huur',
  },
  
  postcode: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_POSTCODE',
    placeholderToken: '1234',
    visibilityRuleName: 'showPostcode',
    constraintsKey: 'postcode',
  },
  
  // ==================== MEMBER FIELDS ====================
  
  naam: {
    componentType: COMPONENT_TYPES.TEXT,  // ‚Üê SSOT!
    labelToken: 'LABEL_NAME',
    placeholderToken: 'PLACEHOLDER_NAME',
    constraintsKey: 'naam',
  },
  
  leeftijd: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AGE',
    constraintsKey: 'leeftijd',
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',
  },
  
  // ==================== INCOME FIELDS ====================
  
  incomeCategory: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_INCOME_CATS',
    optionsKey: 'incomeCategory',
  },
  
  aow_bedrag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_AOW_BEDRAG',
    placeholderToken: '0.00',
    visibilityRuleName: 'isPensionado',
    constraintsKey: 'nettoSalaris',
  },

  nettoSalaris: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_NETTO_SALARIS',
    placeholderToken: '0.00',
    visibilityRuleName: 'hasWorkSelected',
    constraintsKey: 'nettoSalaris',
  },
  
  frequentie: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_FREQUENTIE',
    optionsKey: 'incomeFrequency',
  },
  
  vakantiegeldPerJaar: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_VAKANTIEGELD_JAAR',
    placeholderToken: '0.00',
    constraintsKey: 'vakantiegeldPerJaar',
  },
  
  uitkeringType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_UITKERING_TYPE',
    visibilityRuleName: 'hasBenefitSelected',
    optionsKey: 'uitkeringType',
  },
  
  zorgtoeslag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_ZORGTOESLAG',
    placeholderToken: 'LABEL_ZORGTOESLAG_PM',
    constraintsKey: 'zorgtoeslag',
  },
  
  // ... add rest of fields using COMPONENT_TYPES.XXX
};

export function getFieldDefinition(fieldId: string): FieldDefinition | null {
  return FIELD_REGISTRY[fieldId] ?? null;
}

export function isKnownField(fieldId: string): boolean {
  return fieldId in FIELD_REGISTRY;
}

export function getFieldsByComponentType(type: ComponentType): string[] {
  return Object.entries(FIELD_REGISTRY)
    .filter(([_, def]) => def.componentType === type)
    .map(([fieldId]) => fieldId);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1207
// Timestamp:     2026-02-06T08:17:35.882Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  // ==================== HOUSEHOLD SETUP ====================
  
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    constraintsKey: 'aantalMensen',
    defaultValue: 1,
  },
  
  aantalVolwassen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_VOLWASSENEN',
    visibilityRuleName: 'isAdultInputVisible',
    constraintsKey: 'aantalVolwassen',
    uiModel: 'numericWrapper',
  },
  
  kinderenLabel: {
    componentType: COMPONENT_TYPES.LABEL,  // ‚Üê SSOT!
    labelToken: 'LABEL_KINDEREN',
    visibilityRuleName: 'calculateChildrenCount',
    isDerived: true,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },

  heeftHuisdieren: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_HUISDIEREN',
    optionsKey: 'isBoolean', 
    defaultValue: 'Nee',
  },
  
  // ==================== HOUSEHOLD DETAILS ====================
  
  burgerlijkeStaat: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_BURGERLIJKE_STAAT',
    visibilityRuleName: 'showMaritalStatus',
    optionsKey: 'burgerlijkeStaat',
  },
  
  woningType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_WONING_TYPE',
    optionsKey: 'woningType',
    defaultValue: 'Huur',
  },
  
  postcode: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_POSTCODE',
    placeholderToken: '1234',
    visibilityRuleName: 'showPostcode',
    constraintsKey: 'postcode',
  },
  
  // ==================== MEMBER FIELDS ====================
  
  naam: {
    componentType: COMPONENT_TYPES.TEXT,  // ‚Üê SSOT!
    labelToken: 'LABEL_NAME',
    placeholderToken: 'PLACEHOLDER_NAME',
    constraintsKey: 'naam',
  },
  
  leeftijd: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AGE',
    constraintsKey: 'leeftijd',
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',
  },
  
  // ==================== INCOME FIELDS ====================
  
  incomeCategory: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_INCOME_CATS',
    optionsKey: 'incomeCategory',
  },
  
  aow_bedrag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_AOW_BEDRAG',
    placeholderToken: '0.00',
    visibilityRuleName: 'isPensionado',
    constraintsKey: 'nettoSalaris',
  },

  nettoSalaris: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_NETTO_SALARIS',
    placeholderToken: '0.00',
    visibilityRuleName: 'hasWorkSelected',
    constraintsKey: 'nettoSalaris',
  },
  
  frequentie: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_FREQUENTIE',
    optionsKey: 'incomeFrequency',
  },
  
  vakantiegeldPerJaar: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_VAKANTIEGELD_JAAR',
    placeholderToken: '0.00',
    constraintsKey: 'vakantiegeldPerJaar',
  },
  
  uitkeringType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_UITKERING_TYPE',
    visibilityRuleName: 'hasBenefitSelected',
    optionsKey: 'uitkeringType',
  },
  
  zorgtoeslag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_ZORGTOESLAG',
    placeholderToken: 'LABEL_ZORGTOESLAG_PM',
    constraintsKey: 'zorgtoeslag',
  },
  
  // ... add rest of fields using COMPONENT_TYPES.XXX
};

export function getFieldDefinition(fieldId: string): FieldDefinition | null {
  return FIELD_REGISTRY[fieldId] ?? null;
}

export function isKnownField(fieldId: string): boolean {
  return fieldId in FIELD_REGISTRY;
}

export function getFieldsByComponentType(type: ComponentType): string[] {
  return Object.entries(FIELD_REGISTRY)
    .filter(([_, def]) => def.componentType === type)
    .map(([fieldId]) => fieldId);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1208
// Timestamp:     2026-02-06T08:17:35.882Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1209
// Timestamp:     2026-02-06T08:17:35.882Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1210
// Timestamp:     2026-02-06T08:17:35.882Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/registry/ComponentRegistry';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * 
 * No logic, no decisions - just render ViewModel
 * All style/state logic done in ComponentOrchestrator
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1211
// Timestamp:     2026-02-06T08:17:35.882Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/registry/ComponentRegistry';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * 
 * No logic, no decisions - just render ViewModel
 * All style/state logic done in ComponentOrchestrator
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1212
// Timestamp:     2026-02-06T08:17:35.882Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1213
// Timestamp:     2026-02-06T08:17:35.883Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1214
// Timestamp:     2026-02-06T08:17:35.883Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1215
// Timestamp:     2026-02-06T08:17:35.883Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1216
// Timestamp:     2026-02-06T08:17:35.883Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1217
// Timestamp:     2026-02-06T08:17:35.883Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, geen FSO!
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1218
// Timestamp:     2026-02-06T08:17:35.883Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1219
// Timestamp:     2026-02-06T08:17:35.883Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1220
// Timestamp:     2026-02-06T08:17:35.884Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1221
// Timestamp:     2026-02-06T08:17:35.884Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1222
// Timestamp:     2026-02-06T08:17:35.885Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1223
// Timestamp:     2026-02-06T08:17:35.886Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1224
// Timestamp:     2026-02-06T08:17:35.886Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1225
// Timestamp:     2026-02-06T08:17:35.886Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1226
// Timestamp:     2026-02-06T08:17:35.886Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1227
// Timestamp:     2026-02-06T08:17:35.886Z
// ==========================================================
/**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1228
// Timestamp:     2026-02-06T08:17:35.886Z
// ==========================================================
options (2).ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1229
// Timestamp:     2026-02-06T08:17:35.887Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1230
// Timestamp:     2026-02-06T08:17:35.888Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1231
// Timestamp:     2026-02-06T08:17:35.888Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1232
// Timestamp:     2026-02-06T08:17:35.892Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1233
// Timestamp:     2026-02-06T08:17:35.892Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1234
// Timestamp:     2026-02-06T08:17:35.892Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1235
// Timestamp:     2026-02-06T08:17:35.892Z
// ==========================================================
// RenderOrchestrator.buildFieldViewModel() returns:
return {
  fieldId: 'aantalMensen',
  componentType: 'counter',  // ‚Üê Already from FieldRegistry
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1236
// Timestamp:     2026-02-06T08:17:35.892Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1237
// Timestamp:     2026-02-06T08:17:35.893Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1238
// Timestamp:     2026-02-06T08:17:35.893Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1239
// Timestamp:     2026-02-06T08:17:35.893Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1240
// Timestamp:     2026-02-06T08:17:35.896Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1241
// Timestamp:     2026-02-06T08:17:35.896Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1242
// Timestamp:     2026-02-06T08:17:35.896Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Single Entry Point - Owns ALL orchestrators
 * 
 * ARCHITECTURE PRINCIPLES:
 * ‚úÖ All orchestrators instantiated here (Master owns everything)
 * ‚úÖ No horizontal dependencies (orchestrators don't know each other)
 * ‚úÖ All state mutations flow through updateField()
 * ‚úÖ Orchestrators receive callbacks, not direct references
 * ‚úÖ Public facades expose read-only orchestrators
 * ‚úÖ Private orchestrators accessed via Master API only
 * 
 * RESPONSIBILITIES:
 * - Orchestrator lifecycle management (instantiation, ownership)
 * - State mutation coordination (single entry point)
 * - Facade provision (controlled access to orchestrators)
 * - Integration coordination (CSV import, financial updates)
 * 
 * DOES NOT:
 * - Duplicate registry data (componentType, options)
 * - Implement business logic (delegated to domain)
 * - Directly mutate state (via FormStateOrchestrator)
 */
export class MasterOrchestrator {
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC FACADES - Read-only orchestrators for UI
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PRIVATE ORCHESTRATORS - Accessed via Master API only
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  private readonly component: ComponentOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * CONSTRUCTOR - Instantiates and wires all orchestrators
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles hook
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators with minimal dependencies
    this.fso = new FormStateOrchestrator(getState, dispatch);
    
    // Visibility depends on FSO (for value lookup) and TimeProvider
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // Render depends on FSO and Visibility (vertical dependency)
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // Research depends only on FSO
    this.research = new ResearchOrchestrator(this.fso);
    
    // Component depends on NO orchestrators - only callback and styles!
    // This prevents horizontal dependencies
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator.
   * Maintains vertical architecture (no direct access from UI).
   * 
   * @param fieldViewModel - Business-level ViewModel from RenderOrchestrator
   * @returns ComponentViewModel ready for rendering, or null if invalid
   * 
   * @example
   * const fieldVM = master.render.buildFieldViewModel('aantalMensen');
   * const componentVM = master.buildComponentViewModel(fieldVM);
   * // Pass componentVM to FieldRenderer
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VISIBILITY
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Evaluate visibility rule
   * 
   * Used by UI to determine if field/section should be shown.
   * Delegates to VisibilityOrchestrator.
   * 
   * @param ruleName - Name of visibility rule (from fieldVisibility.ts)
   * @param context - Optional context (memberId, targetWoningType, etc.)
   * @returns true if field should be visible
   * 
   * @example
   * if (master.isVisible('isAdultInputVisible')) {
   *   // Show aantalVolwassen field
   * }
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: STATE MUTATIONS (Single Entry Point)
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Update field value
   * 
   * **CRITICAL: This is the ONLY method that mutates state!**
   * 
   * Flow:
   * 1. Validate at boundary (Zod schema)
   * 2. Update field via FormStateOrchestrator
   * 3. Recompute financial summary (if applicable)
   * 4. Update ViewModel
   * 
   * Used by:
   * - UI components directly
   * - ComponentOrchestrator callbacks (pre-bound in constructor)
   * - Any orchestrator that needs to mutate state
   * 
   * @param fieldId - Field identifier
   * @param value - New value (will be validated)
   */
  public updateField(fieldId: string, value: unknown): void {
    // Boundary validation (Zod)
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    // Update state via FSO
    this.fso.updateField(fieldId, result.data);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: CSV IMPORT
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Handle CSV import (bank transactions)
   * 
   * Flow:
   * 1. Process CSV via ImportOrchestrator
   * 2. Update transactions in state
   * 3. Recompute financial summary
   * 4. Log success or discrepancies
   * 
   * @param csvText - Raw CSV content
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    // Process CSV through ImportOrchestrator
    // Note: ImportOrchestrator uses ResearchOrchestrator instance (DI)
    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    // Update transactions
    this.fso.updateField('transactions', result.transactions);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    // Log results
    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALUE GETTERS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Get current field value
   * 
   * Delegates to FormStateOrchestrator.
   * 
   * @param fieldId - Field identifier
   * @returns Current value or undefined
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  /**
   * Get formatted date value
   * 
   * Converts Date or date string to formatted display string.
   * 
   * @param fieldId - Field identifier
   * @param format - Display format
   * @returns Formatted date string or empty string
   */
  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALIDATION
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Validate field value
   * 
   * Validates against Zod schema at boundary.
   * 
   * @param fieldId - Field identifier
   * @param value - Value to validate
   * @returns Error message or null if valid
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1243
// Timestamp:     2026-02-06T08:17:35.898Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Single Entry Point - Owns ALL orchestrators
 * 
 * ARCHITECTURE PRINCIPLES:
 * ‚úÖ All orchestrators instantiated here (Master owns everything)
 * ‚úÖ No horizontal dependencies (orchestrators don't know each other)
 * ‚úÖ All state mutations flow through updateField()
 * ‚úÖ Orchestrators receive callbacks, not direct references
 * ‚úÖ Public facades expose read-only orchestrators
 * ‚úÖ Private orchestrators accessed via Master API only
 * 
 * RESPONSIBILITIES:
 * - Orchestrator lifecycle management (instantiation, ownership)
 * - State mutation coordination (single entry point)
 * - Facade provision (controlled access to orchestrators)
 * - Integration coordination (CSV import, financial updates)
 * 
 * DOES NOT:
 * - Duplicate registry data (componentType, options)
 * - Implement business logic (delegated to domain)
 * - Directly mutate state (via FormStateOrchestrator)
 */
export class MasterOrchestrator {
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC FACADES - Read-only orchestrators for UI
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PRIVATE ORCHESTRATORS - Accessed via Master API only
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  private readonly component: ComponentOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * CONSTRUCTOR - Instantiates and wires all orchestrators
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles hook
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators with minimal dependencies
    this.fso = new FormStateOrchestrator(getState, dispatch);
    
    // Visibility depends on FSO (for value lookup) and TimeProvider
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // Render depends on FSO and Visibility (vertical dependency)
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // Research depends only on FSO
    this.research = new ResearchOrchestrator(this.fso);
    
    // Component depends on NO orchestrators - only callback and styles!
    // This prevents horizontal dependencies
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator.
   * Maintains vertical architecture (no direct access from UI).
   * 
   * @param fieldViewModel - Business-level ViewModel from RenderOrchestrator
   * @returns ComponentViewModel ready for rendering, or null if invalid
   * 
   * @example
   * const fieldVM = master.render.buildFieldViewModel('aantalMensen');
   * const componentVM = master.buildComponentViewModel(fieldVM);
   * // Pass componentVM to FieldRenderer
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VISIBILITY
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Evaluate visibility rule
   * 
   * Used by UI to determine if field/section should be shown.
   * Delegates to VisibilityOrchestrator.
   * 
   * @param ruleName - Name of visibility rule (from fieldVisibility.ts)
   * @param context - Optional context (memberId, targetWoningType, etc.)
   * @returns true if field should be visible
   * 
   * @example
   * if (master.isVisible('isAdultInputVisible')) {
   *   // Show aantalVolwassen field
   * }
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: STATE MUTATIONS (Single Entry Point)
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Update field value
   * 
   * **CRITICAL: This is the ONLY method that mutates state!**
   * 
   * Flow:
   * 1. Validate at boundary (Zod schema)
   * 2. Update field via FormStateOrchestrator
   * 3. Recompute financial summary (if applicable)
   * 4. Update ViewModel
   * 
   * Used by:
   * - UI components directly
   * - ComponentOrchestrator callbacks (pre-bound in constructor)
   * - Any orchestrator that needs to mutate state
   * 
   * @param fieldId - Field identifier
   * @param value - New value (will be validated)
   */
  public updateField(fieldId: string, value: unknown): void {
    // Boundary validation (Zod)
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    // Update state via FSO
    this.fso.updateField(fieldId, result.data);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: CSV IMPORT
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Handle CSV import (bank transactions)
   * 
   * Flow:
   * 1. Process CSV via ImportOrchestrator
   * 2. Update transactions in state
   * 3. Recompute financial summary
   * 4. Log success or discrepancies
   * 
   * @param csvText - Raw CSV content
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    // Process CSV through ImportOrchestrator
    // Note: ImportOrchestrator uses ResearchOrchestrator instance (DI)
    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    // Update transactions
    this.fso.updateField('transactions', result.transactions);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    // Log results
    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALUE GETTERS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Get current field value
   * 
   * Delegates to FormStateOrchestrator.
   * 
   * @param fieldId - Field identifier
   * @returns Current value or undefined
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  /**
   * Get formatted date value
   * 
   * Converts Date or date string to formatted display string.
   * 
   * @param fieldId - Field identifier
   * @param format - Display format
   * @returns Formatted date string or empty string
   */
  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALIDATION
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Validate field value
   * 
   * Validates against Zod schema at boundary.
   * 
   * @param fieldId - Field identifier
   * @param value - Value to validate
   * @returns Error message or null if valid
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1244
// Timestamp:     2026-02-06T08:17:35.901Z
// ==========================================================
// ‚ùå FOUT - Deze stonden erin, nu weg:
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1245
// Timestamp:     2026-02-06T08:17:35.904Z
// ==========================================================
/**
 * DEPENDENCY GRAPH (Geen horizontale pijlen!)
 * 
 *     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *     ‚îÇ     MASTER ORCHESTRATOR              ‚îÇ
 *     ‚îÇ     (owns & instantiates all)        ‚îÇ
 *     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *            ‚Üì          ‚Üì          ‚Üì          ‚Üì
 *      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *      ‚îÇ   FSO   ‚îÇ ‚îÇ Render  ‚îÇ ‚îÇVisibility‚îÇ ‚îÇComponent‚îÇ
 *      ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ (private)‚îÇ
 *      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                       ‚Üì           ‚Üë
 *                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                     (Vertical OK!)
 * 
 * ‚úÖ NO horizontal arrows
 * ‚úÖ ALL via Master (or vertical: Render‚ÜíVisibility)
 * ‚úÖ Component gets callback, not FSO
 */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1246
// Timestamp:     2026-02-06T08:17:35.905Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1247
// Timestamp:     2026-02-06T08:17:35.905Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1248
// Timestamp:     2026-02-06T08:17:35.906Z
// ==========================================================
new RenderOrchestrator(
  fso,
  (ruleName, context) => this.visibility.evaluate(ruleName, context)  // callback!
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1249
// Timestamp:     2026-02-06T08:17:35.907Z
// ==========================================================
// RenderOrchestrator build ZONDER visibility check
const fieldVM = orchestrator.render.buildFieldViewModelRaw(fieldId);

// Master doet visibility
if (fieldVM.visibilityRule && !orchestrator.isVisible(fieldVM.visibilityRule)) {
  return null;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1250
// Timestamp:     2026-02-06T08:17:35.907Z
// ==========================================================
// ComponentOrchestrator: ‚úÖ Krijgt callback (geen directe FSO)
this.component = new ComponentOrchestrator(
  (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Callback!
  styles
);

// RenderOrchestrator: ‚ùå Krijgt directe Visibility (horizontaal!)
this.render = new RenderOrchestrator(
  this.fso,
  this.visibility  // ‚Üê Direct! Horizontale dependency!
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1251
// Timestamp:     2026-02-06T08:17:35.907Z
// ==========================================================
// Master constructor
this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);

this.render = new RenderOrchestrator(
  this.fso,
  (ruleName: string, context?: VisibilityContext) => 
    this.visibility.evaluate(ruleName, context)  // ‚Üê Callback!
);

this.component = new ComponentOrchestrator(
  (fieldId: string, value: unknown) => this.updateField(fieldId, value),
  styles
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1252
// Timestamp:     2026-02-06T08:17:35.907Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1253
// Timestamp:     2026-02-06T08:17:35.908Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1254
// Timestamp:     2026-02-06T08:17:35.909Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1255
// Timestamp:     2026-02-06T08:17:35.911Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1256
// Timestamp:     2026-02-06T08:17:35.911Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1257
// Timestamp:     2026-02-06T08:17:35.911Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1258
// Timestamp:     2026-02-06T08:17:35.912Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1259
// Timestamp:     2026-02-06T08:17:35.912Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1260
// Timestamp:     2026-02-06T08:17:35.912Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // ‚úÖ RenderOrchestrator has NO visibility dependency!
    this.render = new RenderOrchestrator(this.fso);
    
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Build FieldViewModel WITH Visibility
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build field ViewModel with visibility evaluation
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility rule
   * 
   * Returns null if field is unknown OR not visible.
   * 
   * @param fieldId - Field identifier
   * @param context - Visibility context (memberId, etc.)
   * @returns FieldViewModel if visible, null if hidden
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Evaluate visibility (Master decides!)
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master hides field
      }
    }

    // Field is visible - return ViewModel
    return rawViewModel;
  }

  /**
   * Build page ViewModels (batch)
   * 
   * Convenience method for building multiple fields at once.
   * Filters out hidden fields automatically.
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * Assumes visibility already checked by buildFieldViewModel!
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel directly from fieldId (convenience)
   * 
   * Two-step process:
   * 1. Build FieldViewModel (with visibility)
   * 2. Transform to ComponentViewModel
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    return this.buildComponentViewModel(fieldViewModel);
  }

  // ... rest of Master methods (updateField, etc.)
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1261
// Timestamp:     2026-02-06T08:17:35.912Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // ‚úÖ RenderOrchestrator has NO visibility dependency!
    this.render = new RenderOrchestrator(this.fso);
    
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Build FieldViewModel WITH Visibility
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build field ViewModel with visibility evaluation
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility rule
   * 
   * Returns null if field is unknown OR not visible.
   * 
   * @param fieldId - Field identifier
   * @param context - Visibility context (memberId, etc.)
   * @returns FieldViewModel if visible, null if hidden
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Evaluate visibility (Master decides!)
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master hides field
      }
    }

    // Field is visible - return ViewModel
    return rawViewModel;
  }

  /**
   * Build page ViewModels (batch)
   * 
   * Convenience method for building multiple fields at once.
   * Filters out hidden fields automatically.
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * Assumes visibility already checked by buildFieldViewModel!
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel directly from fieldId (convenience)
   * 
   * Two-step process:
   * 1. Build FieldViewModel (with visibility)
   * 2. Transform to ComponentViewModel
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    return this.buildComponentViewModel(fieldViewModel);
  }

  // ... rest of Master methods (updateField, etc.)
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1262
// Timestamp:     2026-02-06T08:17:35.912Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1263
// Timestamp:     2026-02-06T08:17:35.913Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1264
// Timestamp:     2026-02-06T08:17:35.914Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator  // ‚Üê Direct!
)

// In buildFieldViewModel
const isVisible = this.visibility.evaluate(ruleName, context);  // ‚Üê Direct call!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1265
// Timestamp:     2026-02-06T08:17:35.914Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator
  // ‚Üê NO visibility!
)

// Master doet:
const rawVM = this.render.buildFieldViewModel(fieldId);
const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1266
// Timestamp:     2026-02-06T08:17:35.914Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1267
// Timestamp:     2026-02-06T08:17:35.914Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1268
// Timestamp:     2026-02-06T08:17:35.914Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1269
// Timestamp:     2026-02-06T08:17:35.914Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1270
// Timestamp:     2026-02-06T08:17:35.914Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1271
// Timestamp:     2026-02-06T08:17:35.914Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1272
// Timestamp:     2026-02-06T08:17:35.915Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1273
// Timestamp:     2026-02-06T08:17:35.929Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1274
// Timestamp:     2026-02-06T08:17:35.931Z
// ==========================================================
// ‚ùå FOUT - Horizontaal
this.render = new RenderOrchestrator(this.fso, this.visibility);

// ‚úÖ GOED - Alleen FSO
this.render = new RenderOrchestrator(this.fso);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1275
// Timestamp:     2026-02-06T08:17:35.931Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from registry + state.
 * NO visibility evaluation - Master does that.
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
  ) {}

  public buildFieldViewModel(fieldId: string): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value: this.fso.getValue(fieldId),
      options: getOptionsForField(fieldId),
      visibilityRuleName: fieldDef.visibilityRuleName,
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1276
// Timestamp:     2026-02-06T08:17:35.931Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from registry + state.
 * NO visibility evaluation - Master does that.
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
  ) {}

  public buildFieldViewModel(fieldId: string): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value: this.fso.getValue(fieldId),
      options: getOptionsForField(fieldId),
      visibilityRuleName: fieldDef.visibilityRuleName,
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1277
// Timestamp:     2026-02-06T08:17:35.934Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator, FieldViewModel } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * PHOENIX MASTER ORCHESTRATOR
 * 
 * ENIGE plaats waar orchestrators elkaar "ontmoeten"
 * Alle communicatie verloopt via deze Master
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  private readonly render: RenderOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚úÖ NO orchestrator dependencies
    this.render = new RenderOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * Build FieldViewModel met visibility check
   * 
   * Master co√∂rdineert:
   * 1. Render bouwt ViewModel
   * 2. Visibility evalueert rule
   * 3. Master besluit: toon of verberg
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // 1. Render bouwt ViewModel
    const viewModel = this.render.buildFieldViewModel(fieldId);
    if (!viewModel) return null;

    // 2. Visibility evalueert (als er een rule is)
    if (viewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        viewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) return null;
    }

    // 3. Return visible ViewModel
    return viewModel;
  }

  /**
   * Build meerdere FieldViewModels (batch)
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * Build ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel direct van fieldId (convenience)
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;
    return this.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Visibility check (facade)
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ENIGE mutatie entry point
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1278
// Timestamp:     2026-02-06T08:17:35.936Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator, FieldViewModel } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * PHOENIX MASTER ORCHESTRATOR
 * 
 * ENIGE plaats waar orchestrators elkaar "ontmoeten"
 * Alle communicatie verloopt via deze Master
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  private readonly render: RenderOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚úÖ NO orchestrator dependencies
    this.render = new RenderOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * Build FieldViewModel met visibility check
   * 
   * Master co√∂rdineert:
   * 1. Render bouwt ViewModel
   * 2. Visibility evalueert rule
   * 3. Master besluit: toon of verberg
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // 1. Render bouwt ViewModel
    const viewModel = this.render.buildFieldViewModel(fieldId);
    if (!viewModel) return null;

    // 2. Visibility evalueert (als er een rule is)
    if (viewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        viewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) return null;
    }

    // 3. Return visible ViewModel
    return viewModel;
  }

  /**
   * Build meerdere FieldViewModels (batch)
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * Build ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel direct van fieldId (convenience)
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;
    return this.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Visibility check (facade)
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ENIGE mutatie entry point
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1279
// Timestamp:     2026-02-06T08:17:35.937Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1280
// Timestamp:     2026-02-06T08:17:35.937Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1281
// Timestamp:     2026-02-06T08:17:35.937Z
// ==========================================================
// ‚ùå DELETE deze 2 methoden uit MasterOrchestrator:
public getComponentType(fieldId: string, baseType: string): string { ... }
public getOptions(fieldId: string): readonly string[] { ... }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1282
// Timestamp:     2026-02-06T08:17:35.938Z
// ==========================================================
"resource": "/home/user/pre7/src/ui/components/FieldRenderer.tsx",
"owner": "typescript",
"code": "2614",
"severity": 8,
"message": "Module '\"@ui/components/fields/MoneyInput\"' has no exported member 'MoneyInput'. Did you mean to use 'import MoneyInput from \"@ui/components/fields/Monpastedde fieldRenderer ziet er nu zo uit en geeft bijbehorende eslint-issues (welke ik deels oplos door de ui-componenten aan te pakken - niet de fieldrenderer). Past jouw voorstel bij deze fieldrenderer?08:00Onderzocht hoe ViewModel-aanpak FieldRenderer kan vereenvoudigenLaten we de huidige  analyseren in het licht van mijn voorstel over het "dommer" maken van de UI.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1283
// Timestamp:     2026-02-06T08:17:35.956Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1284
// Timestamp:     2026-02-06T08:17:35.959Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1285
// Timestamp:     2026-02-06T08:17:35.960Z
// ==========================================================
// ‚úì Geen state management
// ‚úì Geen business logic
// ‚úì Geen API calls
// ‚úì Props-driven


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1286
// Timestamp:     2026-02-06T08:17:35.960Z
// ==========================================================
// 1. LOGICA IN COMPONENT (zou niet moeten)
const isSelected = selected === true;
const hasError = error === true;

// 2. STYLE BEREKENINGEN (presentatie-logica)
const containerStyle = [
  styles.chip, 
  isSelected ? styles.chipSelected : null, 
  hasError ? styles.chipError : null
];

// 3. FALLBACK LOGICA
accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}

// 4. CONDITIONAL RENDERING VAN STYLES
style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1287
// Timestamp:     2026-02-06T08:17:35.960Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1288
// Timestamp:     2026-02-06T08:17:35.960Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1289
// Timestamp:     2026-02-06T08:17:35.960Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1290
// Timestamp:     2026-02-06T08:17:35.960Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1291
// Timestamp:     2026-02-06T08:17:35.960Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1292
// Timestamp:     2026-02-06T08:17:35.960Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1293
// Timestamp:     2026-02-06T08:17:35.960Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1294
// Timestamp:     2026-02-06T08:17:35.960Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1295
// Timestamp:     2026-02-06T08:17:35.961Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1296
// Timestamp:     2026-02-06T08:17:35.961Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1297
// Timestamp:     2026-02-06T08:17:35.961Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1298
// Timestamp:     2026-02-06T08:17:35.961Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1299
// Timestamp:     2026-02-06T08:17:35.961Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1300
// Timestamp:     2026-02-06T08:17:35.961Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1301
// Timestamp:     2026-02-06T08:17:35.961Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1302
// Timestamp:     2026-02-06T08:17:35.961Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1303
// Timestamp:     2026-02-06T08:17:35.961Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1304
// Timestamp:     2026-02-06T08:17:35.961Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1305
// Timestamp:     2026-02-06T08:17:35.962Z
// ==========================================================
FieldRenderer.tsx


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1306
// Timestamp:     2026-02-06T08:17:35.962Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1307
// Timestamp:     2026-02-06T08:17:35.962Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1308
// Timestamp:     2026-02-06T08:17:35.962Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1309
// Timestamp:     2026-02-06T08:17:35.962Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1310
// Timestamp:     2026-02-06T08:17:35.962Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1311
// Timestamp:     2026-02-06T08:17:35.962Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1312
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1313
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1314
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1315
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1316
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1317
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1318
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1319
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1320
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
// Simplify to pure rendering
// Remove all helper functions
// Just map ComponentViewModel ‚Üí React


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1321
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
// Change from props to viewModel
// Remove all internal logic


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1322
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
// Change all imports from named to default:
// ‚ùå import { ChipButton } from '...'
// ‚úÖ import ChipButton from '...'


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1323
// Timestamp:     2026-02-06T08:17:35.963Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1324
// Timestamp:     2026-02-06T08:17:35.964Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1325
// Timestamp:     2026-02-06T08:17:35.964Z
// ==========================================================
ComponentViewModels.ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1326
// Timestamp:     2026-02-06T08:17:35.964Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1327
// Timestamp:     2026-02-06T08:17:35.964Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1328
// Timestamp:     2026-02-06T08:17:35.964Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1329
// Timestamp:     2026-02-06T08:17:35.964Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1330
// Timestamp:     2026-02-06T08:17:35.965Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@app/orchestrators/ComponentOrchestrator';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params)
 * ‚úÖ No logic (no complexity)
 * ‚úÖ Small (no max-lines)
 * ‚úÖ ADR-04 compliant
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering (if present) */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * 
 * Each case: 2-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case 'text':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1331
// Timestamp:     2026-02-06T08:17:35.965Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@app/orchestrators/ComponentOrchestrator';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params)
 * ‚úÖ No logic (no complexity)
 * ‚úÖ Small (no max-lines)
 * ‚úÖ ADR-04 compliant
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering (if present) */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * 
 * Each case: 2-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case 'text':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1332
// Timestamp:     2026-02-06T08:17:35.965Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@app/orchestrators/ComponentOrchestrator';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * No logic, no decisions - just render ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1333
// Timestamp:     2026-02-06T08:17:35.965Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@app/orchestrators/ComponentOrchestrator';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * No logic, no decisions - just render ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1334
// Timestamp:     2026-02-06T08:17:35.965Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1335
// Timestamp:     2026-02-06T08:17:35.965Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1336
// Timestamp:     2026-02-06T08:17:35.965Z
// ==========================================================
ComponentOrchestrator.ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1337
// Timestamp:     2026-02-06T08:17:35.965Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1338
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1339
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1340
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1341
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
// Nieuwe laag tussen domain en UI
ComponentOrchestrator
  ‚îî‚îÄ buildComponentViewModel(fieldVM, styles)
      ‚Üí ComponentViewModel (1 object met alles erin)

FieldRenderer
  ‚îî‚îÄ renderComponent(vm)  // 1 parameter!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1342
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1343
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1344
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1345
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1346
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1347
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1348
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1349
// Timestamp:     2026-02-06T08:17:35.966Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1350
// Timestamp:     2026-02-06T08:17:35.967Z
// ==========================================================
// Voor: switch met 11 cases (complexity 11)
function renderFieldComponent(vm, onUpdate, styles, label) {
  switch (vm.componentType) {
    case 'counter': return renderCounter(...);
    case 'currency': return renderCurrency(...);
    // ... 9 more cases
    default: return renderFallback(...);
  }
}

// Na: gebruik lookup table (complexity 1)
const RENDER_MAP: Record<string, RenderFunction> = {
  'counter': renderCounter,
  'currency': renderCurrency,
  'chip-group': renderChipGroup,
  // ... etc
};

function renderFieldComponent(vm, onUpdate, styles, label) {
  const renderFn = RENDER_MAP[vm.componentType] ?? renderFallback;
  return renderFn(vm, onUpdate, styles, label);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1351
// Timestamp:     2026-02-06T08:17:35.968Z
// ==========================================================
// ‚úÖ Voeg ESLint exception toe met goede comment
/* eslint-disable max-params */
// REASON: Pure presentation functions - parameters are acceptable
// TODO: Consider ComponentOrchestrator pattern in future refactor


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1352
// Timestamp:     2026-02-06T08:17:35.968Z
// ==========================================================
// ‚úÖ Splits bestand (helpers apart)
// ‚úÖ Vervang switch door lookup table
// ‚úÖ Blijft functioneel hetzelfde


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1353
// Timestamp:     2026-02-06T08:17:35.968Z
// ==========================================================
// ‚úÖ Implementeer ComponentOrchestrator
// ‚úÖ Volledige ViewModel pattern
// ‚úÖ Perfect separation of concerns


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1354
// Timestamp:     2026-02-06T08:17:35.968Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1355
// Timestamp:     2026-02-06T08:17:35.968Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1356
// Timestamp:     2026-02-06T08:17:35.968Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1357
// Timestamp:     2026-02-06T08:17:35.969Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1358
// Timestamp:     2026-02-06T08:17:35.969Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1359
// Timestamp:     2026-02-06T08:17:35.969Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1360
// Timestamp:     2026-02-06T08:17:35.969Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1361
// Timestamp:     2026-02-06T08:17:35.969Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1362
// Timestamp:     2026-02-06T08:17:35.969Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1363
// Timestamp:     2026-02-06T08:17:35.969Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1364
// Timestamp:     2026-02-06T08:17:35.969Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1365
// Timestamp:     2026-02-06T08:17:35.970Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1366
// Timestamp:     2026-02-06T08:17:35.970Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1367
// Timestamp:     2026-02-06T08:17:35.970Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1368
// Timestamp:     2026-02-06T08:17:35.970Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1369
// Timestamp:     2026-02-06T08:17:35.970Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1370
// Timestamp:     2026-02-06T08:17:35.971Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1371
// Timestamp:     2026-02-06T08:17:35.971Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1372
// Timestamp:     2026-02-06T08:17:35.971Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1373
// Timestamp:     2026-02-06T08:17:35.971Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1374
// Timestamp:     2026-02-06T08:17:35.971Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1375
// Timestamp:     2026-02-06T08:17:35.971Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1376
// Timestamp:     2026-02-06T08:17:35.971Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1377
// Timestamp:     2026-02-06T08:17:35.971Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1378
// Timestamp:     2026-02-06T08:17:35.971Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1379
// Timestamp:     2026-02-06T08:17:35.972Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1380
// Timestamp:     2026-02-06T08:17:35.972Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1381
// Timestamp:     2026-02-06T08:17:35.972Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1382
// Timestamp:     2026-02-06T08:17:35.972Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1383
// Timestamp:     2026-02-06T08:17:35.972Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1384
// Timestamp:     2026-02-06T08:17:35.972Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1385
// Timestamp:     2026-02-06T08:17:35.972Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1386
// Timestamp:     2026-02-06T08:17:35.973Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1387
// Timestamp:     2026-02-06T08:17:35.973Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1388
// Timestamp:     2026-02-06T08:17:35.973Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1389
// Timestamp:     2026-02-06T08:17:35.973Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1390
// Timestamp:     2026-02-06T08:17:35.973Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Step 2: Transform to ComponentViewModels (presentation level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm) => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1391
// Timestamp:     2026-02-06T08:17:35.973Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Step 2: Transform to ComponentViewModels (presentation level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm) => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1392
// Timestamp:     2026-02-06T08:17:35.973Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1393
// Timestamp:     2026-02-06T08:17:35.973Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1394
// Timestamp:     2026-02-06T08:17:35.974Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1395
// Timestamp:     2026-02-06T08:17:35.974Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1396
// Timestamp:     2026-02-06T08:17:35.974Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1397
// Timestamp:     2026-02-06T08:17:35.974Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1398
// Timestamp:     2026-02-06T08:17:35.975Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  // ==================== HOUSEHOLD SETUP ====================
  
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    constraintsKey: 'aantalMensen',
    defaultValue: 1,
  },
  
  aantalVolwassen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_VOLWASSENEN',
    visibilityRuleName: 'isAdultInputVisible',
    constraintsKey: 'aantalVolwassen',
    uiModel: 'numericWrapper',
  },
  
  kinderenLabel: {
    componentType: COMPONENT_TYPES.LABEL,  // ‚Üê SSOT!
    labelToken: 'LABEL_KINDEREN',
    visibilityRuleName: 'calculateChildrenCount',
    isDerived: true,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },

  heeftHuisdieren: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_HUISDIEREN',
    optionsKey: 'isBoolean', 
    defaultValue: 'Nee',
  },
  
  // ==================== HOUSEHOLD DETAILS ====================
  
  burgerlijkeStaat: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_BURGERLIJKE_STAAT',
    visibilityRuleName: 'showMaritalStatus',
    optionsKey: 'burgerlijkeStaat',
  },
  
  woningType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_WONING_TYPE',
    optionsKey: 'woningType',
    defaultValue: 'Huur',
  },
  
  postcode: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_POSTCODE',
    placeholderToken: '1234',
    visibilityRuleName: 'showPostcode',
    constraintsKey: 'postcode',
  },
  
  // ==================== MEMBER FIELDS ====================
  
  naam: {
    componentType: COMPONENT_TYPES.TEXT,  // ‚Üê SSOT!
    labelToken: 'LABEL_NAME',
    placeholderToken: 'PLACEHOLDER_NAME',
    constraintsKey: 'naam',
  },
  
  leeftijd: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AGE',
    constraintsKey: 'leeftijd',
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',
  },
  
  // ==================== INCOME FIELDS ====================
  
  incomeCategory: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_INCOME_CATS',
    optionsKey: 'incomeCategory',
  },
  
  aow_bedrag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_AOW_BEDRAG',
    placeholderToken: '0.00',
    visibilityRuleName: 'isPensionado',
    constraintsKey: 'nettoSalaris',
  },

  nettoSalaris: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_NETTO_SALARIS',
    placeholderToken: '0.00',
    visibilityRuleName: 'hasWorkSelected',
    constraintsKey: 'nettoSalaris',
  },
  
  frequentie: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_FREQUENTIE',
    optionsKey: 'incomeFrequency',
  },
  
  vakantiegeldPerJaar: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_VAKANTIEGELD_JAAR',
    placeholderToken: '0.00',
    constraintsKey: 'vakantiegeldPerJaar',
  },
  
  uitkeringType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_UITKERING_TYPE',
    visibilityRuleName: 'hasBenefitSelected',
    optionsKey: 'uitkeringType',
  },
  
  zorgtoeslag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_ZORGTOESLAG',
    placeholderToken: 'LABEL_ZORGTOESLAG_PM',
    constraintsKey: 'zorgtoeslag',
  },
  
  // ... add rest of fields using COMPONENT_TYPES.XXX
};

export function getFieldDefinition(fieldId: string): FieldDefinition | null {
  return FIELD_REGISTRY[fieldId] ?? null;
}

export function isKnownField(fieldId: string): boolean {
  return fieldId in FIELD_REGISTRY;
}

export function getFieldsByComponentType(type: ComponentType): string[] {
  return Object.entries(FIELD_REGISTRY)
    .filter(([_, def]) => def.componentType === type)
    .map(([fieldId]) => fieldId);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1399
// Timestamp:     2026-02-06T08:17:35.975Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  // ==================== HOUSEHOLD SETUP ====================
  
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    constraintsKey: 'aantalMensen',
    defaultValue: 1,
  },
  
  aantalVolwassen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_VOLWASSENEN',
    visibilityRuleName: 'isAdultInputVisible',
    constraintsKey: 'aantalVolwassen',
    uiModel: 'numericWrapper',
  },
  
  kinderenLabel: {
    componentType: COMPONENT_TYPES.LABEL,  // ‚Üê SSOT!
    labelToken: 'LABEL_KINDEREN',
    visibilityRuleName: 'calculateChildrenCount',
    isDerived: true,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },

  heeftHuisdieren: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_HUISDIEREN',
    optionsKey: 'isBoolean', 
    defaultValue: 'Nee',
  },
  
  // ==================== HOUSEHOLD DETAILS ====================
  
  burgerlijkeStaat: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_BURGERLIJKE_STAAT',
    visibilityRuleName: 'showMaritalStatus',
    optionsKey: 'burgerlijkeStaat',
  },
  
  woningType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_WONING_TYPE',
    optionsKey: 'woningType',
    defaultValue: 'Huur',
  },
  
  postcode: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_POSTCODE',
    placeholderToken: '1234',
    visibilityRuleName: 'showPostcode',
    constraintsKey: 'postcode',
  },
  
  // ==================== MEMBER FIELDS ====================
  
  naam: {
    componentType: COMPONENT_TYPES.TEXT,  // ‚Üê SSOT!
    labelToken: 'LABEL_NAME',
    placeholderToken: 'PLACEHOLDER_NAME',
    constraintsKey: 'naam',
  },
  
  leeftijd: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AGE',
    constraintsKey: 'leeftijd',
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',
  },
  
  // ==================== INCOME FIELDS ====================
  
  incomeCategory: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_INCOME_CATS',
    optionsKey: 'incomeCategory',
  },
  
  aow_bedrag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_AOW_BEDRAG',
    placeholderToken: '0.00',
    visibilityRuleName: 'isPensionado',
    constraintsKey: 'nettoSalaris',
  },

  nettoSalaris: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_NETTO_SALARIS',
    placeholderToken: '0.00',
    visibilityRuleName: 'hasWorkSelected',
    constraintsKey: 'nettoSalaris',
  },
  
  frequentie: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_FREQUENTIE',
    optionsKey: 'incomeFrequency',
  },
  
  vakantiegeldPerJaar: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_VAKANTIEGELD_JAAR',
    placeholderToken: '0.00',
    constraintsKey: 'vakantiegeldPerJaar',
  },
  
  uitkeringType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_UITKERING_TYPE',
    visibilityRuleName: 'hasBenefitSelected',
    optionsKey: 'uitkeringType',
  },
  
  zorgtoeslag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_ZORGTOESLAG',
    placeholderToken: 'LABEL_ZORGTOESLAG_PM',
    constraintsKey: 'zorgtoeslag',
  },
  
  // ... add rest of fields using COMPONENT_TYPES.XXX
};

export function getFieldDefinition(fieldId: string): FieldDefinition | null {
  return FIELD_REGISTRY[fieldId] ?? null;
}

export function isKnownField(fieldId: string): boolean {
  return fieldId in FIELD_REGISTRY;
}

export function getFieldsByComponentType(type: ComponentType): string[] {
  return Object.entries(FIELD_REGISTRY)
    .filter(([_, def]) => def.componentType === type)
    .map(([fieldId]) => fieldId);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1400
// Timestamp:     2026-02-06T08:17:35.975Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1401
// Timestamp:     2026-02-06T08:17:35.975Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1402
// Timestamp:     2026-02-06T08:17:35.975Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/registry/ComponentRegistry';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * 
 * No logic, no decisions - just render ViewModel
 * All style/state logic done in ComponentOrchestrator
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1403
// Timestamp:     2026-02-06T08:17:35.975Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/registry/ComponentRegistry';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * 
 * No logic, no decisions - just render ViewModel
 * All style/state logic done in ComponentOrchestrator
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1404
// Timestamp:     2026-02-06T08:17:35.975Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1405
// Timestamp:     2026-02-06T08:17:35.976Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1406
// Timestamp:     2026-02-06T08:17:35.976Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1407
// Timestamp:     2026-02-06T08:17:35.976Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1408
// Timestamp:     2026-02-06T08:17:35.976Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1409
// Timestamp:     2026-02-06T08:17:35.976Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, geen FSO!
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1410
// Timestamp:     2026-02-06T08:17:35.976Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1411
// Timestamp:     2026-02-06T08:17:35.976Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1412
// Timestamp:     2026-02-06T08:17:35.976Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1413
// Timestamp:     2026-02-06T08:17:35.976Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1414
// Timestamp:     2026-02-06T08:17:35.976Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1415
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1416
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1417
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1418
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1419
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
/**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1420
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
options (2).ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1421
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1422
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1423
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1424
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1425
// Timestamp:     2026-02-06T08:17:35.977Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1426
// Timestamp:     2026-02-06T08:17:35.978Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1427
// Timestamp:     2026-02-06T08:17:35.978Z
// ==========================================================
// RenderOrchestrator.buildFieldViewModel() returns:
return {
  fieldId: 'aantalMensen',
  componentType: 'counter',  // ‚Üê Already from FieldRegistry
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1428
// Timestamp:     2026-02-06T08:17:35.978Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1429
// Timestamp:     2026-02-06T08:17:35.978Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1430
// Timestamp:     2026-02-06T08:17:35.978Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1431
// Timestamp:     2026-02-06T08:17:35.978Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1432
// Timestamp:     2026-02-06T08:17:35.978Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1433
// Timestamp:     2026-02-06T08:17:35.978Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1434
// Timestamp:     2026-02-06T08:17:35.978Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Single Entry Point - Owns ALL orchestrators
 * 
 * ARCHITECTURE PRINCIPLES:
 * ‚úÖ All orchestrators instantiated here (Master owns everything)
 * ‚úÖ No horizontal dependencies (orchestrators don't know each other)
 * ‚úÖ All state mutations flow through updateField()
 * ‚úÖ Orchestrators receive callbacks, not direct references
 * ‚úÖ Public facades expose read-only orchestrators
 * ‚úÖ Private orchestrators accessed via Master API only
 * 
 * RESPONSIBILITIES:
 * - Orchestrator lifecycle management (instantiation, ownership)
 * - State mutation coordination (single entry point)
 * - Facade provision (controlled access to orchestrators)
 * - Integration coordination (CSV import, financial updates)
 * 
 * DOES NOT:
 * - Duplicate registry data (componentType, options)
 * - Implement business logic (delegated to domain)
 * - Directly mutate state (via FormStateOrchestrator)
 */
export class MasterOrchestrator {
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC FACADES - Read-only orchestrators for UI
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PRIVATE ORCHESTRATORS - Accessed via Master API only
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  private readonly component: ComponentOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * CONSTRUCTOR - Instantiates and wires all orchestrators
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles hook
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators with minimal dependencies
    this.fso = new FormStateOrchestrator(getState, dispatch);
    
    // Visibility depends on FSO (for value lookup) and TimeProvider
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // Render depends on FSO and Visibility (vertical dependency)
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // Research depends only on FSO
    this.research = new ResearchOrchestrator(this.fso);
    
    // Component depends on NO orchestrators - only callback and styles!
    // This prevents horizontal dependencies
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator.
   * Maintains vertical architecture (no direct access from UI).
   * 
   * @param fieldViewModel - Business-level ViewModel from RenderOrchestrator
   * @returns ComponentViewModel ready for rendering, or null if invalid
   * 
   * @example
   * const fieldVM = master.render.buildFieldViewModel('aantalMensen');
   * const componentVM = master.buildComponentViewModel(fieldVM);
   * // Pass componentVM to FieldRenderer
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VISIBILITY
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Evaluate visibility rule
   * 
   * Used by UI to determine if field/section should be shown.
   * Delegates to VisibilityOrchestrator.
   * 
   * @param ruleName - Name of visibility rule (from fieldVisibility.ts)
   * @param context - Optional context (memberId, targetWoningType, etc.)
   * @returns true if field should be visible
   * 
   * @example
   * if (master.isVisible('isAdultInputVisible')) {
   *   // Show aantalVolwassen field
   * }
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: STATE MUTATIONS (Single Entry Point)
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Update field value
   * 
   * **CRITICAL: This is the ONLY method that mutates state!**
   * 
   * Flow:
   * 1. Validate at boundary (Zod schema)
   * 2. Update field via FormStateOrchestrator
   * 3. Recompute financial summary (if applicable)
   * 4. Update ViewModel
   * 
   * Used by:
   * - UI components directly
   * - ComponentOrchestrator callbacks (pre-bound in constructor)
   * - Any orchestrator that needs to mutate state
   * 
   * @param fieldId - Field identifier
   * @param value - New value (will be validated)
   */
  public updateField(fieldId: string, value: unknown): void {
    // Boundary validation (Zod)
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    // Update state via FSO
    this.fso.updateField(fieldId, result.data);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: CSV IMPORT
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Handle CSV import (bank transactions)
   * 
   * Flow:
   * 1. Process CSV via ImportOrchestrator
   * 2. Update transactions in state
   * 3. Recompute financial summary
   * 4. Log success or discrepancies
   * 
   * @param csvText - Raw CSV content
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    // Process CSV through ImportOrchestrator
    // Note: ImportOrchestrator uses ResearchOrchestrator instance (DI)
    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    // Update transactions
    this.fso.updateField('transactions', result.transactions);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    // Log results
    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALUE GETTERS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Get current field value
   * 
   * Delegates to FormStateOrchestrator.
   * 
   * @param fieldId - Field identifier
   * @returns Current value or undefined
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  /**
   * Get formatted date value
   * 
   * Converts Date or date string to formatted display string.
   * 
   * @param fieldId - Field identifier
   * @param format - Display format
   * @returns Formatted date string or empty string
   */
  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALIDATION
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Validate field value
   * 
   * Validates against Zod schema at boundary.
   * 
   * @param fieldId - Field identifier
   * @param value - Value to validate
   * @returns Error message or null if valid
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1435
// Timestamp:     2026-02-06T08:17:35.979Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Single Entry Point - Owns ALL orchestrators
 * 
 * ARCHITECTURE PRINCIPLES:
 * ‚úÖ All orchestrators instantiated here (Master owns everything)
 * ‚úÖ No horizontal dependencies (orchestrators don't know each other)
 * ‚úÖ All state mutations flow through updateField()
 * ‚úÖ Orchestrators receive callbacks, not direct references
 * ‚úÖ Public facades expose read-only orchestrators
 * ‚úÖ Private orchestrators accessed via Master API only
 * 
 * RESPONSIBILITIES:
 * - Orchestrator lifecycle management (instantiation, ownership)
 * - State mutation coordination (single entry point)
 * - Facade provision (controlled access to orchestrators)
 * - Integration coordination (CSV import, financial updates)
 * 
 * DOES NOT:
 * - Duplicate registry data (componentType, options)
 * - Implement business logic (delegated to domain)
 * - Directly mutate state (via FormStateOrchestrator)
 */
export class MasterOrchestrator {
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC FACADES - Read-only orchestrators for UI
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PRIVATE ORCHESTRATORS - Accessed via Master API only
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  private readonly component: ComponentOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * CONSTRUCTOR - Instantiates and wires all orchestrators
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles hook
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators with minimal dependencies
    this.fso = new FormStateOrchestrator(getState, dispatch);
    
    // Visibility depends on FSO (for value lookup) and TimeProvider
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // Render depends on FSO and Visibility (vertical dependency)
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // Research depends only on FSO
    this.research = new ResearchOrchestrator(this.fso);
    
    // Component depends on NO orchestrators - only callback and styles!
    // This prevents horizontal dependencies
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator.
   * Maintains vertical architecture (no direct access from UI).
   * 
   * @param fieldViewModel - Business-level ViewModel from RenderOrchestrator
   * @returns ComponentViewModel ready for rendering, or null if invalid
   * 
   * @example
   * const fieldVM = master.render.buildFieldViewModel('aantalMensen');
   * const componentVM = master.buildComponentViewModel(fieldVM);
   * // Pass componentVM to FieldRenderer
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VISIBILITY
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Evaluate visibility rule
   * 
   * Used by UI to determine if field/section should be shown.
   * Delegates to VisibilityOrchestrator.
   * 
   * @param ruleName - Name of visibility rule (from fieldVisibility.ts)
   * @param context - Optional context (memberId, targetWoningType, etc.)
   * @returns true if field should be visible
   * 
   * @example
   * if (master.isVisible('isAdultInputVisible')) {
   *   // Show aantalVolwassen field
   * }
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: STATE MUTATIONS (Single Entry Point)
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Update field value
   * 
   * **CRITICAL: This is the ONLY method that mutates state!**
   * 
   * Flow:
   * 1. Validate at boundary (Zod schema)
   * 2. Update field via FormStateOrchestrator
   * 3. Recompute financial summary (if applicable)
   * 4. Update ViewModel
   * 
   * Used by:
   * - UI components directly
   * - ComponentOrchestrator callbacks (pre-bound in constructor)
   * - Any orchestrator that needs to mutate state
   * 
   * @param fieldId - Field identifier
   * @param value - New value (will be validated)
   */
  public updateField(fieldId: string, value: unknown): void {
    // Boundary validation (Zod)
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    // Update state via FSO
    this.fso.updateField(fieldId, result.data);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: CSV IMPORT
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Handle CSV import (bank transactions)
   * 
   * Flow:
   * 1. Process CSV via ImportOrchestrator
   * 2. Update transactions in state
   * 3. Recompute financial summary
   * 4. Log success or discrepancies
   * 
   * @param csvText - Raw CSV content
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    // Process CSV through ImportOrchestrator
    // Note: ImportOrchestrator uses ResearchOrchestrator instance (DI)
    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    // Update transactions
    this.fso.updateField('transactions', result.transactions);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    // Log results
    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALUE GETTERS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Get current field value
   * 
   * Delegates to FormStateOrchestrator.
   * 
   * @param fieldId - Field identifier
   * @returns Current value or undefined
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  /**
   * Get formatted date value
   * 
   * Converts Date or date string to formatted display string.
   * 
   * @param fieldId - Field identifier
   * @param format - Display format
   * @returns Formatted date string or empty string
   */
  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALIDATION
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Validate field value
   * 
   * Validates against Zod schema at boundary.
   * 
   * @param fieldId - Field identifier
   * @param value - Value to validate
   * @returns Error message or null if valid
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1436
// Timestamp:     2026-02-06T08:17:35.979Z
// ==========================================================
// ‚ùå FOUT - Deze stonden erin, nu weg:
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1437
// Timestamp:     2026-02-06T08:17:35.979Z
// ==========================================================
/**
 * DEPENDENCY GRAPH (Geen horizontale pijlen!)
 * 
 *     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *     ‚îÇ     MASTER ORCHESTRATOR              ‚îÇ
 *     ‚îÇ     (owns & instantiates all)        ‚îÇ
 *     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *            ‚Üì          ‚Üì          ‚Üì          ‚Üì
 *      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *      ‚îÇ   FSO   ‚îÇ ‚îÇ Render  ‚îÇ ‚îÇVisibility‚îÇ ‚îÇComponent‚îÇ
 *      ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ (private)‚îÇ
 *      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                       ‚Üì           ‚Üë
 *                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                     (Vertical OK!)
 * 
 * ‚úÖ NO horizontal arrows
 * ‚úÖ ALL via Master (or vertical: Render‚ÜíVisibility)
 * ‚úÖ Component gets callback, not FSO
 */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1438
// Timestamp:     2026-02-06T08:17:35.979Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1439
// Timestamp:     2026-02-06T08:17:35.979Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1440
// Timestamp:     2026-02-06T08:17:35.979Z
// ==========================================================
new RenderOrchestrator(
  fso,
  (ruleName, context) => this.visibility.evaluate(ruleName, context)  // callback!
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1441
// Timestamp:     2026-02-06T08:17:35.979Z
// ==========================================================
// RenderOrchestrator build ZONDER visibility check
const fieldVM = orchestrator.render.buildFieldViewModelRaw(fieldId);

// Master doet visibility
if (fieldVM.visibilityRule && !orchestrator.isVisible(fieldVM.visibilityRule)) {
  return null;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1442
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
// ComponentOrchestrator: ‚úÖ Krijgt callback (geen directe FSO)
this.component = new ComponentOrchestrator(
  (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Callback!
  styles
);

// RenderOrchestrator: ‚ùå Krijgt directe Visibility (horizontaal!)
this.render = new RenderOrchestrator(
  this.fso,
  this.visibility  // ‚Üê Direct! Horizontale dependency!
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1443
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
// Master constructor
this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);

this.render = new RenderOrchestrator(
  this.fso,
  (ruleName: string, context?: VisibilityContext) => 
    this.visibility.evaluate(ruleName, context)  // ‚Üê Callback!
);

this.component = new ComponentOrchestrator(
  (fieldId: string, value: unknown) => this.updateField(fieldId, value),
  styles
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1444
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1445
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1446
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1447
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1448
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1449
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1450
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1451
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1452
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // ‚úÖ RenderOrchestrator has NO visibility dependency!
    this.render = new RenderOrchestrator(this.fso);
    
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Build FieldViewModel WITH Visibility
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build field ViewModel with visibility evaluation
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility rule
   * 
   * Returns null if field is unknown OR not visible.
   * 
   * @param fieldId - Field identifier
   * @param context - Visibility context (memberId, etc.)
   * @returns FieldViewModel if visible, null if hidden
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Evaluate visibility (Master decides!)
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master hides field
      }
    }

    // Field is visible - return ViewModel
    return rawViewModel;
  }

  /**
   * Build page ViewModels (batch)
   * 
   * Convenience method for building multiple fields at once.
   * Filters out hidden fields automatically.
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * Assumes visibility already checked by buildFieldViewModel!
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel directly from fieldId (convenience)
   * 
   * Two-step process:
   * 1. Build FieldViewModel (with visibility)
   * 2. Transform to ComponentViewModel
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    return this.buildComponentViewModel(fieldViewModel);
  }

  // ... rest of Master methods (updateField, etc.)
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1453
// Timestamp:     2026-02-06T08:17:35.980Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // ‚úÖ RenderOrchestrator has NO visibility dependency!
    this.render = new RenderOrchestrator(this.fso);
    
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Build FieldViewModel WITH Visibility
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build field ViewModel with visibility evaluation
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility rule
   * 
   * Returns null if field is unknown OR not visible.
   * 
   * @param fieldId - Field identifier
   * @param context - Visibility context (memberId, etc.)
   * @returns FieldViewModel if visible, null if hidden
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Evaluate visibility (Master decides!)
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master hides field
      }
    }

    // Field is visible - return ViewModel
    return rawViewModel;
  }

  /**
   * Build page ViewModels (batch)
   * 
   * Convenience method for building multiple fields at once.
   * Filters out hidden fields automatically.
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * Assumes visibility already checked by buildFieldViewModel!
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel directly from fieldId (convenience)
   * 
   * Two-step process:
   * 1. Build FieldViewModel (with visibility)
   * 2. Transform to ComponentViewModel
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    return this.buildComponentViewModel(fieldViewModel);
  }

  // ... rest of Master methods (updateField, etc.)
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1454
// Timestamp:     2026-02-06T08:17:35.982Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1455
// Timestamp:     2026-02-06T08:17:35.982Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1456
// Timestamp:     2026-02-06T08:17:35.982Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator  // ‚Üê Direct!
)

// In buildFieldViewModel
const isVisible = this.visibility.evaluate(ruleName, context);  // ‚Üê Direct call!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1457
// Timestamp:     2026-02-06T08:17:35.982Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator
  // ‚Üê NO visibility!
)

// Master doet:
const rawVM = this.render.buildFieldViewModel(fieldId);
const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1458
// Timestamp:     2026-02-06T08:17:35.982Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1459
// Timestamp:     2026-02-06T08:17:35.982Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1460
// Timestamp:     2026-02-06T08:17:35.983Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1461
// Timestamp:     2026-02-06T08:17:35.983Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1462
// Timestamp:     2026-02-06T08:17:35.983Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1463
// Timestamp:     2026-02-06T08:17:35.983Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1464
// Timestamp:     2026-02-06T08:17:35.984Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1465
// Timestamp:     2026-02-06T08:17:35.984Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1466
// Timestamp:     2026-02-06T08:17:35.984Z
// ==========================================================
// ‚ùå FOUT - Horizontaal
this.render = new RenderOrchestrator(this.fso, this.visibility);

// ‚úÖ GOED - Alleen FSO
this.render = new RenderOrchestrator(this.fso);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1467
// Timestamp:     2026-02-06T08:17:35.984Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from registry + state.
 * NO visibility evaluation - Master does that.
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
  ) {}

  public buildFieldViewModel(fieldId: string): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value: this.fso.getValue(fieldId),
      options: getOptionsForField(fieldId),
      visibilityRuleName: fieldDef.visibilityRuleName,
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1468
// Timestamp:     2026-02-06T08:17:35.984Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from registry + state.
 * NO visibility evaluation - Master does that.
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
  ) {}

  public buildFieldViewModel(fieldId: string): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value: this.fso.getValue(fieldId),
      options: getOptionsForField(fieldId),
      visibilityRuleName: fieldDef.visibilityRuleName,
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1469
// Timestamp:     2026-02-06T08:17:35.984Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator, FieldViewModel } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * PHOENIX MASTER ORCHESTRATOR
 * 
 * ENIGE plaats waar orchestrators elkaar "ontmoeten"
 * Alle communicatie verloopt via deze Master
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  private readonly render: RenderOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚úÖ NO orchestrator dependencies
    this.render = new RenderOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * Build FieldViewModel met visibility check
   * 
   * Master co√∂rdineert:
   * 1. Render bouwt ViewModel
   * 2. Visibility evalueert rule
   * 3. Master besluit: toon of verberg
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // 1. Render bouwt ViewModel
    const viewModel = this.render.buildFieldViewModel(fieldId);
    if (!viewModel) return null;

    // 2. Visibility evalueert (als er een rule is)
    if (viewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        viewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) return null;
    }

    // 3. Return visible ViewModel
    return viewModel;
  }

  /**
   * Build meerdere FieldViewModels (batch)
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * Build ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel direct van fieldId (convenience)
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;
    return this.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Visibility check (facade)
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ENIGE mutatie entry point
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1470
// Timestamp:     2026-02-06T08:17:35.985Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator, FieldViewModel } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * PHOENIX MASTER ORCHESTRATOR
 * 
 * ENIGE plaats waar orchestrators elkaar "ontmoeten"
 * Alle communicatie verloopt via deze Master
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  private readonly render: RenderOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚úÖ NO orchestrator dependencies
    this.render = new RenderOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * Build FieldViewModel met visibility check
   * 
   * Master co√∂rdineert:
   * 1. Render bouwt ViewModel
   * 2. Visibility evalueert rule
   * 3. Master besluit: toon of verberg
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // 1. Render bouwt ViewModel
    const viewModel = this.render.buildFieldViewModel(fieldId);
    if (!viewModel) return null;

    // 2. Visibility evalueert (als er een rule is)
    if (viewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        viewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) return null;
    }

    // 3. Return visible ViewModel
    return viewModel;
  }

  /**
   * Build meerdere FieldViewModels (batch)
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * Build ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel direct van fieldId (convenience)
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;
    return this.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Visibility check (facade)
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ENIGE mutatie entry point
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1471
// Timestamp:     2026-02-06T08:17:35.985Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1472
// Timestamp:     2026-02-06T08:17:35.985Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1473
// Timestamp:     2026-02-06T08:17:35.985Z
// ==========================================================
// ‚ùå DELETE deze 2 methoden uit MasterOrchestrator:
public getComponentType(fieldId: string, baseType: string): string { ... }
public getOptions(fieldId: string): readonly string[] { ... }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1474
// Timestamp:     2026-02-06T08:17:35.985Z
// ==========================================================
"resource": "/home/user/pre7/src/ui/components/FieldRenderer.tsx",
"owner": "typescript",
"code": "2614",
"severity": 8,
"message": "Module '\"@ui/components/fields/MoneyInput\"' has no exported member 'MoneyInput'. Did you mean to use 'import MoneyInput from \"@ui/components/fields/Monpastedde fieldRenderer ziet er nu zo uit en geeft bijbehorende eslint-issues (welke ik deels oplos door de ui-componenten aan te pakken - niet de fieldrenderer). Past jouw voorstel bij deze fieldrenderer?08:00Onderzocht hoe ViewModel-aanpak FieldRenderer kan vereenvoudigenLaten we de huidige  analyseren in het licht van mijn voorstel over het "dommer" maken van de UI.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1475
// Timestamp:     2026-02-06T08:17:35.986Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1476
// Timestamp:     2026-02-06T08:17:35.986Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1477
// Timestamp:     2026-02-06T08:17:35.986Z
// ==========================================================
// ‚úì Geen state management
// ‚úì Geen business logic
// ‚úì Geen API calls
// ‚úì Props-driven


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1478
// Timestamp:     2026-02-06T08:17:35.986Z
// ==========================================================
// 1. LOGICA IN COMPONENT (zou niet moeten)
const isSelected = selected === true;
const hasError = error === true;

// 2. STYLE BEREKENINGEN (presentatie-logica)
const containerStyle = [
  styles.chip, 
  isSelected ? styles.chipSelected : null, 
  hasError ? styles.chipError : null
];

// 3. FALLBACK LOGICA
accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}

// 4. CONDITIONAL RENDERING VAN STYLES
style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1479
// Timestamp:     2026-02-06T08:17:35.986Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1480
// Timestamp:     2026-02-06T08:17:35.987Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1481
// Timestamp:     2026-02-06T08:17:35.987Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1482
// Timestamp:     2026-02-06T08:17:35.987Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1483
// Timestamp:     2026-02-06T08:17:35.987Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1484
// Timestamp:     2026-02-06T08:17:35.987Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1485
// Timestamp:     2026-02-06T08:17:35.987Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1486
// Timestamp:     2026-02-06T08:17:35.987Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1487
// Timestamp:     2026-02-06T08:17:35.987Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1488
// Timestamp:     2026-02-06T08:17:35.987Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1489
// Timestamp:     2026-02-06T08:17:35.987Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1490
// Timestamp:     2026-02-06T08:17:35.988Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1491
// Timestamp:     2026-02-06T08:17:35.988Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1492
// Timestamp:     2026-02-06T08:17:35.988Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1493
// Timestamp:     2026-02-06T08:17:35.988Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1494
// Timestamp:     2026-02-06T08:17:35.988Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1495
// Timestamp:     2026-02-06T08:17:35.989Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1496
// Timestamp:     2026-02-06T08:17:35.989Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1497
// Timestamp:     2026-02-06T08:17:35.990Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1498
// Timestamp:     2026-02-06T08:17:35.990Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1499
// Timestamp:     2026-02-06T08:17:35.991Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1500
// Timestamp:     2026-02-06T08:17:35.991Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1501
// Timestamp:     2026-02-06T08:17:35.991Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1502
// Timestamp:     2026-02-06T08:17:35.991Z
// ==========================================================
import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { useAppStyles } from '@ui/styles/useAppStyles';

export type ChipButtonProps = {
  label: string;
  selected: boolean;
  error?: boolean;
  onPress: () => void;
  accessibilityLabel?: string;
};

const ChipButton: React.FC<ChipButtonProps> = ({
  label, selected, error, onPress, accessibilityLabel,
}) => {
  const { styles } = useAppStyles();
  
  const isSelected = selected === true;
  const hasError = error === true;
  
  const containerStyle = [
    styles.chip, 
    isSelected ? styles.chipSelected : null, 
    hasError ? styles.chipError : null
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}
      accessibilityState={{ selected: isSelected }}
    >
      <Text style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1503
// Timestamp:     2026-02-06T08:17:35.991Z
// ==========================================================
// ‚úì Geen state management
// ‚úì Geen business logic
// ‚úì Geen API calls
// ‚úì Props-driven


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1504
// Timestamp:     2026-02-06T08:17:35.991Z
// ==========================================================
// 1. LOGICA IN COMPONENT (zou niet moeten)
const isSelected = selected === true;
const hasError = error === true;

// 2. STYLE BEREKENINGEN (presentatie-logica)
const containerStyle = [
  styles.chip, 
  isSelected ? styles.chipSelected : null, 
  hasError ? styles.chipError : null
];

// 3. FALLBACK LOGICA
accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}

// 4. CONDITIONAL RENDERING VAN STYLES
style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1505
// Timestamp:     2026-02-06T08:17:35.991Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1506
// Timestamp:     2026-02-06T08:17:35.992Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1507
// Timestamp:     2026-02-06T08:17:35.992Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1508
// Timestamp:     2026-02-06T08:17:35.992Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1509
// Timestamp:     2026-02-06T08:17:35.992Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1510
// Timestamp:     2026-02-06T08:17:35.992Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1511
// Timestamp:     2026-02-06T08:17:35.992Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1512
// Timestamp:     2026-02-06T08:17:35.992Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1513
// Timestamp:     2026-02-06T08:17:35.992Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1514
// Timestamp:     2026-02-06T08:17:35.992Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1515
// Timestamp:     2026-02-06T08:17:35.993Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1516
// Timestamp:     2026-02-06T08:17:35.993Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1517
// Timestamp:     2026-02-06T08:17:35.993Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1518
// Timestamp:     2026-02-06T08:17:35.993Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1519
// Timestamp:     2026-02-06T08:17:35.993Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1520
// Timestamp:     2026-02-06T08:17:35.993Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1521
// Timestamp:     2026-02-06T08:17:35.993Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1522
// Timestamp:     2026-02-06T08:17:35.993Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1523
// Timestamp:     2026-02-06T08:17:35.994Z
// ==========================================================
// ‚úì Geen state management
// ‚úì Geen business logic
// ‚úì Geen API calls
// ‚úì Props-driven


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1524
// Timestamp:     2026-02-06T08:17:35.994Z
// ==========================================================
// ‚úì Geen state management
// ‚úì Geen business logic
// ‚úì Geen API calls
// ‚úì Props-driven


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1525
// Timestamp:     2026-02-06T08:17:35.994Z
// ==========================================================
// 1. LOGICA IN COMPONENT (zou niet moeten)
const isSelected = selected === true;
const hasError = error === true;

// 2. STYLE BEREKENINGEN (presentatie-logica)
const containerStyle = [
  styles.chip, 
  isSelected ? styles.chipSelected : null, 
  hasError ? styles.chipError : null
];

// 3. FALLBACK LOGICA
accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}

// 4. CONDITIONAL RENDERING VAN STYLES
style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1526
// Timestamp:     2026-02-06T08:17:35.994Z
// ==========================================================
// 1. LOGICA IN COMPONENT (zou niet moeten)
const isSelected = selected === true;
const hasError = error === true;

// 2. STYLE BEREKENINGEN (presentatie-logica)
const containerStyle = [
  styles.chip, 
  isSelected ? styles.chipSelected : null, 
  hasError ? styles.chipError : null
];

// 3. FALLBACK LOGICA
accessibilityLabel={typeof accessibilityLabel === 'string' ? accessibilityLabel : label}

// 4. CONDITIONAL RENDERING VAN STYLES
style={[styles.chipText, isSelected ? styles.chipTextSelected : null]}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1527
// Timestamp:     2026-02-06T08:17:35.994Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1528
// Timestamp:     2026-02-06T08:17:35.994Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1529
// Timestamp:     2026-02-06T08:17:35.994Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1530
// Timestamp:     2026-02-06T08:17:35.994Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text, ViewStyle, TextStyle } from 'react-native';

export type ChipButtonProps = {
  label: string;
  containerStyle: ViewStyle;      // ‚Üê Pre-computed door parent
  textStyle: TextStyle;            // ‚Üê Pre-computed door parent
  onPress: () => void;
  accessibilityLabel: string;      // ‚Üê Altijd verplicht (geen fallback)
  accessibilityState: {            // ‚Üê Pre-computed door parent
    selected: boolean;
  };
};

/**
 * DUMB CHIP BUTTON
 * 
 * Geen logica, geen conditionals, geen berekeningen.
 * Alles komt pre-computed binnen via props.
 */
const ChipButton: React.FC<ChipButtonProps> = ({
  label,
  containerStyle,
  textStyle,
  onPress,
  accessibilityLabel,
  accessibilityState,
}) => {
  return (
    <TouchableOpacity
      style={containerStyle}           // ‚Üê Direct gebruiken
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={accessibilityState}
    >
      <Text style={textStyle}>        {/* ‚Üê Direct gebruiken */}
        {label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1531
// Timestamp:     2026-02-06T08:17:35.994Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1532
// Timestamp:     2026-02-06T08:17:35.994Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1533
// Timestamp:     2026-02-06T08:17:35.996Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1534
// Timestamp:     2026-02-06T08:17:35.996Z
// ==========================================================
// src/ui/fields/ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel, orchestrator }) => {
  const { styles } = useAppStyles();
  
  return (
    <View>
      {viewModel.options.map((option) => {
        const isSelected = viewModel.value === option;
        const hasError = viewModel.error !== null;
        
        // üëà ALLE LOGICA HIER (in de renderer, niet in de presentational component)
        const containerStyle = [
          styles.chip,
          isSelected && styles.chipSelected,
          hasError && styles.chipError,
        ];
        
        const textStyle = [
          styles.chipText,
          isSelected && styles.chipTextSelected,
        ];
        
        return (
          <ChipButton
            key={option}
            label={option}
            containerStyle={containerStyle}
            textStyle={textStyle}
            onPress={() => orchestrator.updateField(viewModel.fieldId, option)}
            accessibilityLabel={`${viewModel.labelToken}: ${option}`}
            accessibilityState={{ selected: isSelected }}
          />
        );
      })}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1535
// Timestamp:     2026-02-06T08:17:35.997Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1536
// Timestamp:     2026-02-06T08:17:35.997Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1537
// Timestamp:     2026-02-06T08:17:35.997Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1538
// Timestamp:     2026-02-06T08:17:35.997Z
// ==========================================================
// src/ui/components/ChipButton.tsx

import * as React from 'react';
import { TouchableOpacity, Text } from 'react-native';

export type ChipViewModel = {
  label: string;
  styleVariant: 'default' | 'selected' | 'error';
  onPress: () => void;
  a11y: {
    label: string;
    selected: boolean;
  };
};

type ChipButtonProps = {
  viewModel: ChipViewModel;
  styles: any; // ‚Üê Krijgt pre-selected styles van parent
};

/**
 * ULTRA-DUMB CHIP BUTTON
 * 
 * Ontvangt een ViewModel en rendert exact wat erin staat.
 * Geen enkele beslissing, alleen rendering.
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel, styles }) => {
  return (
    <TouchableOpacity
      style={styles[viewModel.styleVariant]}    // ‚Üê Lookup, geen conditionals
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.a11y.label}
      accessibilityState={{ selected: viewModel.a11y.selected }}
    >
      <Text style={styles[`${viewModel.styleVariant}Text`]}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1539
// Timestamp:     2026-02-06T08:17:35.997Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1540
// Timestamp:     2026-02-06T08:17:35.997Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1541
// Timestamp:     2026-02-06T08:17:35.997Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1542
// Timestamp:     2026-02-06T08:17:35.997Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

buildChipViewModel(
  option: string, 
  fieldViewModel: FieldViewModel,
  context: RenderContext
): ChipViewModel {
  const isSelected = fieldViewModel.value === option;
  const hasError = fieldViewModel.error !== null;
  
  // üëà ALLE LOGICA HIER (in de orchestrator)
  const styleVariant = hasError 
    ? 'error' 
    : isSelected 
    ? 'selected' 
    : 'default';
  
  return {
    label: option,
    styleVariant,
    onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
    a11y: {
      label: `${fieldViewModel.labelToken}: ${option}`,
      selected: isSelected,
    },
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1543
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1544
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1545
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1546
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// ChipButton.tsx - Verwijder defensieve checks

const ChipButton: React.FC<ChipButtonProps> = ({
  label, 
  selected,  // ‚Üê Vertrouw op caller voor boolean
  error,     // ‚Üê Vertrouw op caller voor boolean
  onPress, 
  accessibilityLabel = label,  // ‚Üê Gebruik default parameter
}) => {
  const { styles } = useAppStyles();
  
  // OPTIE: Verplaats dit naar een helper functie
  const containerStyle = [
    styles.chip, 
    selected && styles.chipSelected,  // ‚Üê Simpelere check
    error && styles.chipError
  ];
  
  return (
    <TouchableOpacity
      style={containerStyle}
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel}
      accessibilityState={{ selected }}  // ‚Üê Direct gebruiken
    >
      <Text style={[styles.chipText, selected && styles.chipTextSelected]}>
        {label}
      </Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1547
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1548
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1549
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1550
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// src/ui/helpers/chipStyles.ts

import { ViewStyle, TextStyle } from 'react-native';

export function getChipStyles(
  styles: any, 
  state: { selected: boolean; error: boolean }
): { container: ViewStyle[]; text: TextStyle[] } {
  return {
    container: [
      styles.chip,
      state.selected && styles.chipSelected,
      state.error && styles.chipError,
    ],
    text: [
      styles.chipText,
      state.selected && styles.chipTextSelected,
    ],
  };
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1551
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1552
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1553
// Timestamp:     2026-02-06T08:17:35.998Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1554
// Timestamp:     2026-02-06T08:17:35.999Z
// ==========================================================
// ChipButton.tsx

import { getChipStyles } from '@ui/helpers/chipStyles';

const ChipButton: React.FC<ChipButtonProps> = (props) => {
  const { styles } = useAppStyles();
  const computedStyles = getChipStyles(styles, { 
    selected: props.selected, 
    error: props.error ?? false 
  });
  
  return (
    <TouchableOpacity style={computedStyles.container} onPress={props.onPress}>
      <Text style={computedStyles.text}>{props.label}</Text>
    </TouchableOpacity>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1555
// Timestamp:     2026-02-06T08:17:35.999Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1556
// Timestamp:     2026-02-06T08:17:35.999Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1557
// Timestamp:     2026-02-06T08:17:35.999Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1558
// Timestamp:     2026-02-06T08:17:35.999Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

export class RenderOrchestrator {
  
  /**
   * Bouwt een volledige chip-group ViewModel inclusief alle chips
   */
  buildChipGroupViewModel(
    fieldViewModel: FieldViewModel,
    context: RenderContext
  ): ChipGroupViewModel {
    const { styles } = context.styles;
    
    return {
      fieldId: fieldViewModel.fieldId,
      labelToken: fieldViewModel.labelToken,
      chips: fieldViewModel.options.map(option => 
        this.buildChipViewModel(option, fieldViewModel, styles)
      ),
    };
  }
  
  /**
   * Bouwt een individuele chip ViewModel
   */
  private buildChipViewModel(
    option: string,
    fieldViewModel: FieldViewModel,
    styles: any
  ): ChipViewModel {
    const isSelected = fieldViewModel.value === option;
    const hasError = fieldViewModel.error !== null;
    
    // ‚¨ÖÔ∏è ALLE BESLISSINGEN HIER
    const styleVariant = hasError ? 'error' : isSelected ? 'selected' : 'default';
    
    return {
      label: option,
      styleVariant,
      containerStyle: [
        styles.chip,
        isSelected && styles.chipSelected,
        hasError && styles.chipError,
      ],
      textStyle: [
        styles.chipText,
        isSelected && styles.chipTextSelected,
      ],
      onPress: () => this.fso.updateField(fieldViewModel.fieldId, option),
      a11y: {
        label: `${fieldViewModel.labelToken}: ${option}`,
        selected: isSelected,
      },
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1559
// Timestamp:     2026-02-06T08:17:35.999Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1560
// Timestamp:     2026-02-06T08:17:35.999Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1561
// Timestamp:     2026-02-06T08:17:36.000Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1562
// Timestamp:     2026-02-06T08:17:36.000Z
// ==========================================================
// ChipGroupRenderer.tsx

const ChipGroupRenderer: React.FC<Props> = ({ viewModel }) => {
  return (
    <View>
      <Text>{viewModel.labelToken}</Text>
      {viewModel.chips.map((chipVM) => (
        <ChipButton 
          key={chipVM.label} 
          viewModel={chipVM}  // ‚Üê Alles pre-computed
        />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1563
// Timestamp:     2026-02-06T08:17:36.000Z
// ==========================================================
"resource": "/home/user/pre7/src/ui/components/FieldRenderer.tsx",
"owner": "typescript",
"code": "2614",
"severity": 8,
"message": "Module '\"@ui/components/fields/MoneyInput\"' has no exported member 'MoneyInput'. Did you mean to use 'import MoneyInput from \"@ui/components/fields/Monpastedde fieldRenderer ziet er nu zo uit en geeft bijbehorende eslint-issues (welke ik deels oplos door de ui-componenten aan te pakken - niet de fieldrenderer). Past jouw voorstel bij deze fieldrenderer?08:00


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1564
// Timestamp:     2026-02-06T08:17:36.000Z
// ==========================================================
"resource": "/home/user/pre7/src/ui/components/FieldRenderer.tsx",
"owner": "typescript",
"code": "2614",
"severity": 8,
"message": "Module '\"@ui/components/fields/MoneyInput\"' has no exported member 'MoneyInput'. Did you mean to use 'import MoneyInput from \"@ui/components/fields/Monpasted


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1565
// Timestamp:     2026-02-06T08:17:36.000Z
// ==========================================================
FieldRenderer.tsx


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1566
// Timestamp:     2026-02-06T08:17:36.001Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1567
// Timestamp:     2026-02-06T08:17:36.001Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1568
// Timestamp:     2026-02-06T08:17:36.001Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1569
// Timestamp:     2026-02-06T08:17:36.001Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1570
// Timestamp:     2026-02-06T08:17:36.001Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1571
// Timestamp:     2026-02-06T08:17:36.001Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1572
// Timestamp:     2026-02-06T08:17:36.001Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1573
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1574
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1575
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1576
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1577
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1578
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1579
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1580
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
// Simplify to pure rendering
// Remove all helper functions
// Just map ComponentViewModel ‚Üí React


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1581
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
// Change from props to viewModel
// Remove all internal logic


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1582
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
// Change all imports from named to default:
// ‚ùå import { ChipButton } from '...'
// ‚úÖ import ChipButton from '...'


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1583
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1584
// Timestamp:     2026-02-06T08:17:36.002Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1585
// Timestamp:     2026-02-06T08:17:36.003Z
// ==========================================================
ComponentViewModels.ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1586
// Timestamp:     2026-02-06T08:17:36.003Z
// ==========================================================
FieldRenderer.tsx


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1587
// Timestamp:     2026-02-06T08:17:36.003Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1588
// Timestamp:     2026-02-06T08:17:36.003Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1589
// Timestamp:     2026-02-06T08:17:36.003Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1590
// Timestamp:     2026-02-06T08:17:36.004Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1591
// Timestamp:     2026-02-06T08:17:36.004Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1592
// Timestamp:     2026-02-06T08:17:36.004Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1593
// Timestamp:     2026-02-06T08:17:36.004Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1594
// Timestamp:     2026-02-06T08:17:36.004Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1595
// Timestamp:     2026-02-06T08:17:36.004Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1596
// Timestamp:     2026-02-06T08:17:36.004Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1597
// Timestamp:     2026-02-06T08:17:36.004Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1598
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1599
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1600
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1601
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
// Simplify to pure rendering
// Remove all helper functions
// Just map ComponentViewModel ‚Üí React


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1602
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
// Change from props to viewModel
// Remove all internal logic


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1603
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
// Change all imports from named to default:
// ‚ùå import { ChipButton } from '...'
// ‚úÖ import ChipButton from '...'


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1604
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1605
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1606
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
ComponentViewModels.ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1607
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1608
// Timestamp:     2026-02-06T08:17:36.005Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1609
// Timestamp:     2026-02-06T08:17:36.006Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1610
// Timestamp:     2026-02-06T08:17:36.006Z
// ==========================================================
// ‚ùå HUIDIG: Te veel parameters (violates max-params)
function renderCounter(
  vm: FieldViewModel,        // 1
  onUpdate: (value: unknown) => void,  // 2
  styles: Record<string, unknown>,     // 3
  label: string              // 4
): React.ReactElement { ... }

// ‚ùå HUIDIG: Logica in render functies
const currentValue = vm.value as string | undefined;
const containerStyle = [
  styles.chip,
  isSelected && styles.chipSelected,  // ‚Üê Conditional styling
];

// ‚ùå HUIDIG: Type casting overal
typeof vm.value === 'number' ? vm.value : 0


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1611
// Timestamp:     2026-02-06T08:17:36.006Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1612
// Timestamp:     2026-02-06T08:17:36.006Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1613
// Timestamp:     2026-02-06T08:17:36.006Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1614
// Timestamp:     2026-02-06T08:17:36.006Z
// ==========================================================
// src/domain/viewmodels/ComponentViewModels.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * BASE ViewModel - shared by all components
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  isVisible: boolean;
  error?: string | null;
}

/**
 * COUNTER ViewModel - pre-computed for InputCounter
 */
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CURRENCY ViewModel - pre-computed for MoneyInput
 */
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

/**
 * CHIP GROUP ViewModel - pre-computed for ChipButton
 */
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chips: ChipViewModel[];  // ‚Üê All chips pre-built!
}

/**
 * TEXT ViewModel
 */
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

/**
 * Union type for all ViewModels
 */
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1615
// Timestamp:     2026-02-06T08:17:36.006Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1616
// Timestamp:     2026-02-06T08:17:36.007Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1617
// Timestamp:     2026-02-06T08:17:36.007Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1618
// Timestamp:     2026-02-06T08:17:36.007Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { ComponentViewModel, CounterViewModel, ChipGroupViewModel, ChipViewModel } from '@domain/viewmodels/ComponentViewModels';
import { FieldViewModel } from './types';
import { labelFromToken } from '@ui/constants/labelResolver';

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * MAIN ENTRY POINT
   * Converts FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounterViewModel(fieldViewModel);
      
      case 'currency':
        return this.buildCurrencyViewModel(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroupViewModel(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultipleViewModel(fieldViewModel);
      
      // ... other cases
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER ViewModel
   * All logic here, component is dumb
   */
  private buildCounterViewModel(
    vm: FieldViewModel
  ): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,  // ‚Üê Type casting HERE
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY ViewModel
   */
  private buildCurrencyViewModel(
    vm: FieldViewModel
  ): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      value: typeof vm.value === 'number' ? vm.value : 0,
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken) 
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP ViewModel
   * Pre-builds ALL chips with their styles
   */
  private buildChipGroupViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE
    const chips: ChipViewModel[] = options.map((option) => 
      this.buildChipViewModel(option, currentValue, vm.fieldId)
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,  // ‚Üê Fully pre-built!
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP ViewModel
   * All style logic HERE
   */
  private buildChipViewModel(
    option: string,
    currentValue: string | undefined,
    fieldId: string
  ): ChipViewModel {
    const isSelected = currentValue === option;

    // ‚Üê ALL STYLE LOGIC HERE (not in component!)
    const containerStyle = [
      this.styles.chip,
      isSelected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      isSelected && this.styles.chipTextSelected,
    ];

    return {
      label: option,
      selected: isSelected,
      containerStyle,
      textStyle,
      onPress: () => {
        this.fso.updateField(fieldId, option);
      },
      accessibilityLabel: `${option}`,
      accessibilityState: { selected: isSelected },
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE ViewModel
   */
  private buildChipGroupMultipleViewModel(
    vm: FieldViewModel
  ): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips: ChipViewModel[] = options.map((option) => {
      const isSelected = currentValues.includes(option);

      return {
        label: option,
        selected: isSelected,
        containerStyle: [
          this.styles.chip,
          isSelected && this.styles.chipSelected,
        ],
        textStyle: [
          this.styles.chipText,
          isSelected && this.styles.chipTextSelected,
        ],
        onPress: () => {
          // ‚Üê TOGGLE LOGIC HERE
          const newValues = isSelected
            ? currentValues.filter((v) => v !== option)
            : [...currentValues, option];
          this.fso.updateField(vm.fieldId, newValues);
        },
        accessibilityLabel: option,
        accessibilityState: { selected: isSelected },
      };
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      isVisible: true,
      error: vm.error,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chips,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1619
// Timestamp:     2026-02-06T08:17:36.007Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1620
// Timestamp:     2026-02-06T08:17:36.008Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1621
// Timestamp:     2026-02-06T08:17:36.009Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1622
// Timestamp:     2026-02-06T08:17:36.009Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@domain/viewmodels/ComponentViewModels';

// Import dumb components (default exports fixed)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * No logic, no decisions, no conditionals.
 * Just maps ComponentViewModel to React components.
 * 
 * ‚úÖ Max 1 parameter (no max-params violation)
 * ‚úÖ No complexity (just switch statement)
 * ‚úÖ Small functions (no max-lines violation)
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  // Safety check (should never happen - pre-filtered)
  if (!viewModel.isVisible) return null;

  return (
    <View>
      {renderComponent(viewModel)}
      {viewModel.error && (
        <Text style={viewModel.errorStyle ?? {}}>
          {viewModel.error}
        </Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel to actual component
 * Each case is 2-3 lines - no complexity!
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chip) => (
              <ChipButton key={chip.label} viewModel={chip} />
            ))}
          </ScrollView>
        </View>
      );

    // ... other cases (all 2-3 lines each)

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1623
// Timestamp:     2026-02-06T08:17:36.009Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1624
// Timestamp:     2026-02-06T08:17:36.009Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1625
// Timestamp:     2026-02-06T08:17:36.009Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1626
// Timestamp:     2026-02-06T08:17:36.010Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/viewmodels/ComponentViewModels';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * Just renders what's in the ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}  // ‚Üê Pre-computed
      onPress={viewModel.onPress}       // ‚Üê Pre-bound
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>  {/* ‚Üê Pre-computed */}
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1627
// Timestamp:     2026-02-06T08:17:36.011Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1628
// Timestamp:     2026-02-06T08:17:36.011Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1629
// Timestamp:     2026-02-06T08:17:36.011Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1630
// Timestamp:     2026-02-06T08:17:36.011Z
// ==========================================================
# Create new file
touch src/domain/viewmodels/ComponentViewModels.ts

# Define all ViewModel types
# (Counter, Currency, ChipGroup, etc.)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1631
// Timestamp:     2026-02-06T08:17:36.011Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1632
// Timestamp:     2026-02-06T08:17:36.013Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1633
// Timestamp:     2026-02-06T08:17:36.014Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1634
// Timestamp:     2026-02-06T08:17:36.020Z
// ==========================================================
# Create orchestrator
touch src/app/orchestrators/RenderOrchestrator.ts

# Implement build methods for each component type
# Move ALL logic from FieldRenderer here


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1635
// Timestamp:     2026-02-06T08:17:36.024Z
// ==========================================================
// Simplify to pure rendering
// Remove all helper functions
// Just map ComponentViewModel ‚Üí React


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1636
// Timestamp:     2026-02-06T08:17:36.025Z
// ==========================================================
// Simplify to pure rendering
// Remove all helper functions
// Just map ComponentViewModel ‚Üí React


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1637
// Timestamp:     2026-02-06T08:17:36.025Z
// ==========================================================
// Change from props to viewModel
// Remove all internal logic


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1638
// Timestamp:     2026-02-06T08:17:36.025Z
// ==========================================================
// Change from props to viewModel
// Remove all internal logic


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1639
// Timestamp:     2026-02-06T08:17:36.027Z
// ==========================================================
// Change all imports from named to default:
// ‚ùå import { ChipButton } from '...'
// ‚úÖ import ChipButton from '...'


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1640
// Timestamp:     2026-02-06T08:17:36.030Z
// ==========================================================
// Change all imports from named to default:
// ‚ùå import { ChipButton } from '...'
// ‚úÖ import ChipButton from '...'


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1641
// Timestamp:     2026-02-06T08:17:36.031Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1642
// Timestamp:     2026-02-06T08:17:36.032Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1643
// Timestamp:     2026-02-06T08:17:36.034Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1644
// Timestamp:     2026-02-06T08:17:36.035Z
// ==========================================================
// Instead of passing FieldViewModel:
const fieldViewModels = config.fields.map(...)

// Pass ComponentViewModel:
const componentViewModels = fieldViewModels.map(fvm =>
  renderOrchestrator.buildComponentViewModel(fvm)
).filter(Boolean);

// Render:
{componentViewModels.map(vm => (
  <FieldRenderer key={vm.fieldId} viewModel={vm} />
))}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1645
// Timestamp:     2026-02-06T08:17:36.035Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1646
// Timestamp:     2026-02-06T08:17:36.043Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1647
// Timestamp:     2026-02-06T08:17:36.043Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1648
// Timestamp:     2026-02-06T08:17:36.043Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1649
// Timestamp:     2026-02-06T08:17:36.044Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@app/orchestrators/ComponentOrchestrator';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params)
 * ‚úÖ No logic (no complexity)
 * ‚úÖ Small (no max-lines)
 * ‚úÖ ADR-04 compliant
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering (if present) */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * 
 * Each case: 2-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case 'text':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1650
// Timestamp:     2026-02-06T08:17:36.044Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@app/orchestrators/ComponentOrchestrator';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params)
 * ‚úÖ No logic (no complexity)
 * ‚úÖ Small (no max-lines)
 * ‚úÖ ADR-04 compliant
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering (if present) */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * 
 * Each case: 2-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case 'text':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1651
// Timestamp:     2026-02-06T08:17:36.044Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@app/orchestrators/ComponentOrchestrator';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * No logic, no decisions - just render ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1652
// Timestamp:     2026-02-06T08:17:36.048Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@app/orchestrators/ComponentOrchestrator';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * No logic, no decisions - just render ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1653
// Timestamp:     2026-02-06T08:17:36.049Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1654
// Timestamp:     2026-02-06T08:17:36.050Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1655
// Timestamp:     2026-02-06T08:17:36.051Z
// ==========================================================
ComponentOrchestrator.ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1656
// Timestamp:     2026-02-06T08:17:36.052Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1657
// Timestamp:     2026-02-06T08:17:36.053Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1658
// Timestamp:     2026-02-06T08:17:36.054Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1659
// Timestamp:     2026-02-06T08:17:36.054Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1660
// Timestamp:     2026-02-06T08:17:36.054Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@app/orchestrators/ComponentOrchestrator';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params)
 * ‚úÖ No logic (no complexity)
 * ‚úÖ Small (no max-lines)
 * ‚úÖ ADR-04 compliant
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering (if present) */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * 
 * Each case: 2-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case 'text':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1661
// Timestamp:     2026-02-06T08:17:36.055Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import { ComponentViewModel } from '@app/orchestrators/ComponentOrchestrator';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ULTRA-DUMB FieldRenderer
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params)
 * ‚úÖ No logic (no complexity)
 * ‚úÖ Small (no max-lines)
 * ‚úÖ ADR-04 compliant
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering (if present) */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * 
 * Each case: 2-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case 'counter':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case 'currency':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case 'chip-group':
    case 'chip-group-multiple':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case 'text':
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1662
// Timestamp:     2026-02-06T08:17:36.055Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@app/orchestrators/ComponentOrchestrator';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * No logic, no decisions - just render ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1663
// Timestamp:     2026-02-06T08:17:36.058Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@app/orchestrators/ComponentOrchestrator';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * No logic, no decisions - just render ViewModel
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1664
// Timestamp:     2026-02-06T08:17:36.058Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1665
// Timestamp:     2026-02-06T08:17:36.058Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1666
// Timestamp:     2026-02-06T08:17:36.058Z
// ==========================================================
ComponentOrchestrator.ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1667
// Timestamp:     2026-02-06T08:17:36.058Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1668
// Timestamp:     2026-02-06T08:17:36.058Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 HUIDIG (wat je hebt)                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  RenderOrchestrator                                          ‚îÇ
‚îÇ  ‚îî‚îÄ buildFieldViewModel()                                   ‚îÇ
‚îÇ      ‚Üí FieldViewModel {                                      ‚îÇ
‚îÇ          fieldId: 'aantalMensen',                           ‚îÇ
‚îÇ          componentType: 'counter',                          ‚îÇ
‚îÇ          labelToken: 'LABEL_AANTAL_MENSEN',                 ‚îÇ
‚îÇ          value: 2,                                          ‚îÇ
‚îÇ          isVisible: true,                                   ‚îÇ
‚îÇ          options: null,                                     ‚îÇ
‚îÇ          error: null                                        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              NIEUWE LAAG (ComponentOrchestrator)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ComponentOrchestrator                                       ‚îÇ
‚îÇ  ‚îî‚îÄ buildComponentViewModel(FieldViewModel, styles)         ‚îÇ
‚îÇ      ‚Üí CounterViewModel {                                    ‚îÇ
‚îÇ          label: 'Aantal mensen',        ‚Üê Resolved          ‚îÇ
‚îÇ          value: 2,                       ‚Üê Type-safe        ‚îÇ
‚îÇ          containerStyle: {...},          ‚Üê Pre-computed     ‚îÇ
‚îÇ          labelStyle: {...},              ‚Üê Pre-computed     ‚îÇ
‚îÇ          onUpdate: (n) => fso.update()   ‚Üê Pre-bound        ‚îÇ
‚îÇ        }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ULTRA-DUMB UI                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRenderer                                               ‚îÇ
‚îÇ  ‚îî‚îÄ <InputCounter {...counterViewModel} />                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ  InputCounter                                                ‚îÇ
‚îÇ  ‚îî‚îÄ Just renders (no logic)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1669
// Timestamp:     2026-02-06T08:17:36.059Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1670
// Timestamp:     2026-02-06T08:17:36.059Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1671
// Timestamp:     2026-02-06T08:17:36.060Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1672
// Timestamp:     2026-02-06T08:17:36.060Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ViewStyle, TextStyle } from 'react-native';
import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * COMPONENT VIEW MODELS
 * 
 * These are UI-ready, pre-computed ViewModels.
 * No logic needed in components - everything is ready to render.
 */

// Base
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: string;
  error?: string | null;
  errorStyle?: TextStyle;
}

// Counter
export interface CounterViewModel extends BaseComponentViewModel {
  componentType: 'counter';
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Currency
export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: 'currency';
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// Chip (individual)
export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

// Chip Group
export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: 'chip-group' | 'chip-group-multiple';
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];  // ‚Üê Pre-built!
}

// Text
export interface TextViewModel extends BaseComponentViewModel {
  componentType: 'text';
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others as needed

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens
 * - Compute styles
 * - Build callbacks
 * - Type conversions
 * - Pre-build nested structures (chips, etc.)
 * 
 * Does NOT:
 * - Evaluate visibility (done by RenderOrchestrator)
 * - Access state directly (uses FieldViewModel)
 * - Contain business logic (pure transformation)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly styles: any  // From useAppStyles()
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Already filtered for visibility by RenderOrchestrator
    // But double-check for safety
    if (!fieldViewModel.isVisible) return null;

    switch (fieldViewModel.componentType) {
      case 'counter':
        return this.buildCounter(fieldViewModel);
      
      case 'currency':
        return this.buildCurrency(fieldViewModel);
      
      case 'chip-group':
        return this.buildChipGroup(fieldViewModel);
      
      case 'chip-group-multiple':
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case 'text':
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        return null;
    }
  }

  /**
   * BUILD COUNTER
   * All UI concerns handled here
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'counter',
      label: labelFromToken(vm.labelToken),  // ‚Üê Resolve token
      value: this.ensureNumber(vm.value),    // ‚Üê Type-safe conversion
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {         // ‚Üê Pre-bound callback
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'currency',
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.fso.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds ALL chips
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // ‚Üê BUILD ALL CHIPS HERE (not in renderer!)
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.fso.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,  // ‚Üê Fully pre-built!
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // ‚Üê TOGGLE LOGIC HERE (not in renderer!)
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.fso.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: 'chip-group-multiple',
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style logic here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // ‚Üê ALL STYLE DECISIONS HERE
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: 'text',
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.fso.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1673
// Timestamp:     2026-02-06T08:17:36.061Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1674
// Timestamp:     2026-02-06T08:17:36.061Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1675
// Timestamp:     2026-02-06T08:17:36.061Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1676
// Timestamp:     2026-02-06T08:17:36.063Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentOrchestrator } from '@app/orchestrators/ComponentOrchestrator';
import { useAppStyles } from '@ui/styles/useAppStyles';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // Has RenderOrchestrator
  const { styles } = useAppStyles();

  // Create ComponentOrchestrator (memoized)
  const componentOrch = useMemo(
    () => new ComponentOrchestrator(orchestrator.fso, styles),
    [orchestrator.fso, styles]
  );

  // Build FieldViewModels (business-level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels (UI-level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => componentOrch.buildComponentViewModel(fieldVM))
      .filter((vm) => vm !== null);
  }, [fieldViewModels, componentOrch]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1677
// Timestamp:     2026-02-06T08:17:36.064Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1678
// Timestamp:     2026-02-06T08:17:36.065Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1679
// Timestamp:     2026-02-06T08:17:36.065Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1680
// Timestamp:     2026-02-06T08:17:36.065Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1681
// Timestamp:     2026-02-06T08:17:36.067Z
// ==========================================================
// Nieuwe laag tussen domain en UI
ComponentOrchestrator
  ‚îî‚îÄ buildComponentViewModel(fieldVM, styles)
      ‚Üí ComponentViewModel (1 object met alles erin)

FieldRenderer
  ‚îî‚îÄ renderComponent(vm)  // 1 parameter!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1682
// Timestamp:     2026-02-06T08:17:36.067Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1683
// Timestamp:     2026-02-06T08:17:36.068Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1684
// Timestamp:     2026-02-06T08:17:36.068Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1685
// Timestamp:     2026-02-06T08:17:36.068Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1686
// Timestamp:     2026-02-06T08:17:36.068Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1687
// Timestamp:     2026-02-06T08:17:36.068Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1688
// Timestamp:     2026-02-06T08:17:36.068Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1689
// Timestamp:     2026-02-06T08:17:36.068Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1690
// Timestamp:     2026-02-06T08:17:36.068Z
// ==========================================================
// Voor: switch met 11 cases (complexity 11)
function renderFieldComponent(vm, onUpdate, styles, label) {
  switch (vm.componentType) {
    case 'counter': return renderCounter(...);
    case 'currency': return renderCurrency(...);
    // ... 9 more cases
    default: return renderFallback(...);
  }
}

// Na: gebruik lookup table (complexity 1)
const RENDER_MAP: Record<string, RenderFunction> = {
  'counter': renderCounter,
  'currency': renderCurrency,
  'chip-group': renderChipGroup,
  // ... etc
};

function renderFieldComponent(vm, onUpdate, styles, label) {
  const renderFn = RENDER_MAP[vm.componentType] ?? renderFallback;
  return renderFn(vm, onUpdate, styles, label);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1691
// Timestamp:     2026-02-06T08:17:36.068Z
// ==========================================================
// ‚úÖ Voeg ESLint exception toe met goede comment
/* eslint-disable max-params */
// REASON: Pure presentation functions - parameters are acceptable
// TODO: Consider ComponentOrchestrator pattern in future refactor


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1692
// Timestamp:     2026-02-06T08:17:36.068Z
// ==========================================================
// ‚úÖ Splits bestand (helpers apart)
// ‚úÖ Vervang switch door lookup table
// ‚úÖ Blijft functioneel hetzelfde


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1693
// Timestamp:     2026-02-06T08:17:36.070Z
// ==========================================================
// ‚úÖ Implementeer ComponentOrchestrator
// ‚úÖ Volledige ViewModel pattern
// ‚úÖ Perfect separation of concerns


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1694
// Timestamp:     2026-02-06T08:17:36.070Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1695
// Timestamp:     2026-02-06T08:17:36.070Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1696
// Timestamp:     2026-02-06T08:17:36.070Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1697
// Timestamp:     2026-02-06T08:17:36.071Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1698
// Timestamp:     2026-02-06T08:17:36.071Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1699
// Timestamp:     2026-02-06T08:17:36.071Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1700
// Timestamp:     2026-02-06T08:17:36.071Z
// ==========================================================
// Nieuwe laag tussen domain en UI
ComponentOrchestrator
  ‚îî‚îÄ buildComponentViewModel(fieldVM, styles)
      ‚Üí ComponentViewModel (1 object met alles erin)

FieldRenderer
  ‚îî‚îÄ renderComponent(vm)  // 1 parameter!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1701
// Timestamp:     2026-02-06T08:17:36.071Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1702
// Timestamp:     2026-02-06T08:17:36.071Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1703
// Timestamp:     2026-02-06T08:17:36.071Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1704
// Timestamp:     2026-02-06T08:17:36.071Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1705
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1706
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1707
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1708
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1709
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// Voor: switch met 11 cases (complexity 11)
function renderFieldComponent(vm, onUpdate, styles, label) {
  switch (vm.componentType) {
    case 'counter': return renderCounter(...);
    case 'currency': return renderCurrency(...);
    // ... 9 more cases
    default: return renderFallback(...);
  }
}

// Na: gebruik lookup table (complexity 1)
const RENDER_MAP: Record<string, RenderFunction> = {
  'counter': renderCounter,
  'currency': renderCurrency,
  'chip-group': renderChipGroup,
  // ... etc
};

function renderFieldComponent(vm, onUpdate, styles, label) {
  const renderFn = RENDER_MAP[vm.componentType] ?? renderFallback;
  return renderFn(vm, onUpdate, styles, label);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1710
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// ‚úÖ Voeg ESLint exception toe met goede comment
/* eslint-disable max-params */
// REASON: Pure presentation functions - parameters are acceptable
// TODO: Consider ComponentOrchestrator pattern in future refactor


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1711
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// ‚úÖ Splits bestand (helpers apart)
// ‚úÖ Vervang switch door lookup table
// ‚úÖ Blijft functioneel hetzelfde


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1712
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// ‚úÖ Implementeer ComponentOrchestrator
// ‚úÖ Volledige ViewModel pattern
// ‚úÖ Perfect separation of concerns


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1713
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1714
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1715
// Timestamp:     2026-02-06T08:17:36.072Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1716
// Timestamp:     2026-02-06T08:17:36.073Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1717
// Timestamp:     2026-02-06T08:17:36.073Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1718
// Timestamp:     2026-02-06T08:17:36.073Z
// ==========================================================
// Huidige helper functies zijn pure transformaties
function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ‚úÖ No state
  // ‚úÖ No side effects (onUpdate is passed in)
  // ‚úÖ Pure function: same inputs ‚Üí same output
  // ‚úÖ Just transforms params ‚Üí JSX
  
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter value={...} onChange={onUpdate} />
    </View>
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1719
// Timestamp:     2026-02-06T08:17:36.073Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1720
// Timestamp:     2026-02-06T08:17:36.073Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1721
// Timestamp:     2026-02-06T08:17:36.073Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1722
// Timestamp:     2026-02-06T08:17:36.073Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
// Justification: Render functions need vm, onUpdate, styles, and label.
// These are pure transformation functions with no business logic.

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // ... huidige code blijft exact hetzelfde
}
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1723
// Timestamp:     2026-02-06T08:17:36.073Z
// ==========================================================
// Nieuwe laag tussen domain en UI
ComponentOrchestrator
  ‚îî‚îÄ buildComponentViewModel(fieldVM, styles)
      ‚Üí ComponentViewModel (1 object met alles erin)

FieldRenderer
  ‚îî‚îÄ renderComponent(vm)  // 1 parameter!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1724
// Timestamp:     2026-02-06T08:17:36.074Z
// ==========================================================
// Nieuwe laag tussen domain en UI
ComponentOrchestrator
  ‚îî‚îÄ buildComponentViewModel(fieldVM, styles)
      ‚Üí ComponentViewModel (1 object met alles erin)

FieldRenderer
  ‚îî‚îÄ renderComponent(vm)  // 1 parameter!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1725
// Timestamp:     2026-02-06T08:17:36.074Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1726
// Timestamp:     2026-02-06T08:17:36.074Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1727
// Timestamp:     2026-02-06T08:17:36.074Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1728
// Timestamp:     2026-02-06T08:17:36.074Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

/* eslint-disable max-params */
/* 
 * ARCHITECTURAL NOTE:
 * These render functions are pure transformations with no business logic.
 * They receive 4-5 parameters which is acceptable for presentation-only functions.
 * 
 * Future refactor: Consider ComponentOrchestrator pattern to reduce parameters
 * and improve testability. See ADR-XX for context.
 */

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  // Huidige implementatie blijft
}

// ... rest van de code
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1729
// Timestamp:     2026-02-06T08:17:36.074Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1730
// Timestamp:     2026-02-06T08:17:36.074Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1731
// Timestamp:     2026-02-06T08:17:36.074Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1732
// Timestamp:     2026-02-06T08:17:36.075Z
// ==========================================================
# Splits in 2 files
src/ui/components/FieldRenderer.tsx         # Main component (80 lines)
src/ui/components/FieldRenderer.helpers.ts  # Render functions (150 lines)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1733
// Timestamp:     2026-02-06T08:17:36.075Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1734
// Timestamp:     2026-02-06T08:17:36.075Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1735
// Timestamp:     2026-02-06T08:17:36.075Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1736
// Timestamp:     2026-02-06T08:17:36.085Z
// ==========================================================
// FieldRenderer.tsx
import { renderCounter, renderCurrency, ... } from './FieldRenderer.helpers';

export const FieldRenderer: React.FC<Props> = ({ viewModel, onUpdate }) => {
  const { styles } = useAppStyles();
  const label = labelFromToken(viewModel.labelToken);
  
  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles, label)}
      {/* error rendering */}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1737
// Timestamp:     2026-02-06T08:17:36.086Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1738
// Timestamp:     2026-02-06T08:17:36.086Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1739
// Timestamp:     2026-02-06T08:17:36.086Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1740
// Timestamp:     2026-02-06T08:17:36.086Z
// ==========================================================
// FieldRenderer.helpers.ts
/* eslint-disable max-params */
export function renderCounter(...) { ... }
export function renderCurrency(...) { ... }
// etc.
/* eslint-enable max-params */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1741
// Timestamp:     2026-02-06T08:17:36.086Z
// ==========================================================
// Voor: switch met 11 cases (complexity 11)
function renderFieldComponent(vm, onUpdate, styles, label) {
  switch (vm.componentType) {
    case 'counter': return renderCounter(...);
    case 'currency': return renderCurrency(...);
    // ... 9 more cases
    default: return renderFallback(...);
  }
}

// Na: gebruik lookup table (complexity 1)
const RENDER_MAP: Record<string, RenderFunction> = {
  'counter': renderCounter,
  'currency': renderCurrency,
  'chip-group': renderChipGroup,
  // ... etc
};

function renderFieldComponent(vm, onUpdate, styles, label) {
  const renderFn = RENDER_MAP[vm.componentType] ?? renderFallback;
  return renderFn(vm, onUpdate, styles, label);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1742
// Timestamp:     2026-02-06T08:17:36.086Z
// ==========================================================
// Voor: switch met 11 cases (complexity 11)
function renderFieldComponent(vm, onUpdate, styles, label) {
  switch (vm.componentType) {
    case 'counter': return renderCounter(...);
    case 'currency': return renderCurrency(...);
    // ... 9 more cases
    default: return renderFallback(...);
  }
}

// Na: gebruik lookup table (complexity 1)
const RENDER_MAP: Record<string, RenderFunction> = {
  'counter': renderCounter,
  'currency': renderCurrency,
  'chip-group': renderChipGroup,
  // ... etc
};

function renderFieldComponent(vm, onUpdate, styles, label) {
  const renderFn = RENDER_MAP[vm.componentType] ?? renderFallback;
  return renderFn(vm, onUpdate, styles, label);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1743
// Timestamp:     2026-02-06T08:17:36.086Z
// ==========================================================
// ‚úÖ Voeg ESLint exception toe met goede comment
/* eslint-disable max-params */
// REASON: Pure presentation functions - parameters are acceptable
// TODO: Consider ComponentOrchestrator pattern in future refactor


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1744
// Timestamp:     2026-02-06T08:17:36.088Z
// ==========================================================
// ‚úÖ Voeg ESLint exception toe met goede comment
/* eslint-disable max-params */
// REASON: Pure presentation functions - parameters are acceptable
// TODO: Consider ComponentOrchestrator pattern in future refactor


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1745
// Timestamp:     2026-02-06T08:17:36.096Z
// ==========================================================
// ‚úÖ Splits bestand (helpers apart)
// ‚úÖ Vervang switch door lookup table
// ‚úÖ Blijft functioneel hetzelfde


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1746
// Timestamp:     2026-02-06T08:17:36.096Z
// ==========================================================
// ‚úÖ Splits bestand (helpers apart)
// ‚úÖ Vervang switch door lookup table
// ‚úÖ Blijft functioneel hetzelfde


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1747
// Timestamp:     2026-02-06T08:17:36.096Z
// ==========================================================
// ‚úÖ Implementeer ComponentOrchestrator
// ‚úÖ Volledige ViewModel pattern
// ‚úÖ Perfect separation of concerns


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1748
// Timestamp:     2026-02-06T08:17:36.096Z
// ==========================================================
// ‚úÖ Implementeer ComponentOrchestrator
// ‚úÖ Volledige ViewModel pattern
// ‚úÖ Perfect separation of concerns


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1749
// Timestamp:     2026-02-06T08:17:36.096Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1750
// Timestamp:     2026-02-06T08:17:36.096Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1751
// Timestamp:     2026-02-06T08:17:36.096Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1752
// Timestamp:     2026-02-06T08:17:36.096Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARCHITECTURAL NOTE: ESLint max-params exception
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 
// These render functions use 4-5 parameters, which violates our
// max-params rule of 3. This is acceptable because:
//
// 1. Functions are PURE (no state, no side effects)
// 2. Functions are DUMB (no business logic, just JSX transformation)
// 3. Parameters are all NECESSARY (vm, callback, styles, labels)
// 4. Alternative (ComponentOrchestrator) is valid but adds complexity
//
// Trade-off: Pragmatism > Perfect adherence to lint rules
// Future: Consider ComponentOrchestrator pattern when refactoring
// See: docs/architecture/ADR-XX-component-orchestrator.md
//
/* eslint-disable max-params */

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
// ... imports

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RENDER HELPERS - Pure transformation functions
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function renderCounter(
  vm: FieldViewModel,
  onUpdate: (value: unknown) => void,
  styles: Record<string, unknown>,
  label: string
): React.ReactElement {
  return (
    <View style={styles.fieldContainer}>
      <Text style={styles.label}>{label}</Text>
      <InputCounter
        value={typeof vm.value === 'number' ? vm.value : 0}
        onChange={onUpdate}
      />
    </View>
  );
}

// ... rest blijft hetzelfde

/* eslint-enable max-params */

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT - Orchestrates rendering
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export const FieldRenderer: React.FC<FieldRendererProps> = ({
  viewModel,
  onUpdate,
}) => {
  const { styles } = useAppStyles();

  if (viewModel.isVisible === false) {
    return null;
  }

  const hasError = viewModel.error !== null && 
                   viewModel.error !== undefined && 
                   viewModel.error !== '';

  return (
    <View>
      {renderFieldComponent(viewModel, onUpdate, styles)}
      {hasError && (
        <Text style={styles.errorText}>{viewModel.error}</Text>
      )}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1753
// Timestamp:     2026-02-06T08:17:36.101Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1754
// Timestamp:     2026-02-06T08:17:36.101Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1755
// Timestamp:     2026-02-06T08:17:36.103Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1756
// Timestamp:     2026-02-06T08:17:36.103Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1757
// Timestamp:     2026-02-06T08:17:36.104Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1758
// Timestamp:     2026-02-06T08:17:36.107Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1759
// Timestamp:     2026-02-06T08:17:36.110Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1760
// Timestamp:     2026-02-06T08:17:36.113Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1761
// Timestamp:     2026-02-06T08:17:36.115Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1762
// Timestamp:     2026-02-06T08:17:36.119Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1763
// Timestamp:     2026-02-06T08:17:36.121Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1764
// Timestamp:     2026-02-06T08:17:36.129Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1765
// Timestamp:     2026-02-06T08:17:36.129Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1766
// Timestamp:     2026-02-06T08:17:36.129Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1767
// Timestamp:     2026-02-06T08:17:36.130Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1768
// Timestamp:     2026-02-06T08:17:36.131Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1769
// Timestamp:     2026-02-06T08:17:36.135Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1770
// Timestamp:     2026-02-06T08:17:36.135Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1771
// Timestamp:     2026-02-06T08:17:36.142Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1772
// Timestamp:     2026-02-06T08:17:36.142Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1773
// Timestamp:     2026-02-06T08:17:36.143Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1774
// Timestamp:     2026-02-06T08:17:36.144Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1775
// Timestamp:     2026-02-06T08:17:36.146Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1776
// Timestamp:     2026-02-06T08:17:36.149Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1777
// Timestamp:     2026-02-06T08:17:36.150Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1778
// Timestamp:     2026-02-06T08:17:36.152Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1779
// Timestamp:     2026-02-06T08:17:36.154Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1780
// Timestamp:     2026-02-06T08:17:36.163Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1781
// Timestamp:     2026-02-06T08:17:36.164Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1782
// Timestamp:     2026-02-06T08:17:36.165Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1783
// Timestamp:     2026-02-06T08:17:36.165Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1784
// Timestamp:     2026-02-06T08:17:36.165Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1785
// Timestamp:     2026-02-06T08:17:36.167Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1786
// Timestamp:     2026-02-06T08:17:36.168Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1787
// Timestamp:     2026-02-06T08:17:36.174Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1788
// Timestamp:     2026-02-06T08:17:36.174Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1789
// Timestamp:     2026-02-06T08:17:36.174Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1790
// Timestamp:     2026-02-06T08:17:36.174Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1791
// Timestamp:     2026-02-06T08:17:36.174Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1792
// Timestamp:     2026-02-06T08:17:36.174Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1793
// Timestamp:     2026-02-06T08:17:36.177Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1794
// Timestamp:     2026-02-06T08:17:36.181Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1795
// Timestamp:     2026-02-06T08:17:36.183Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1796
// Timestamp:     2026-02-06T08:17:36.189Z
// ==========================================================
// Prompt voor AI:
"Genereer ComponentViewModels.ts met deze types:
- CounterViewModel (label, value, styles, onUpdate)
- CurrencyViewModel (label, value, placeholder, styles, onUpdate)  
- ChipViewModel (label, selected, styles, onPress, a11y)
- ChipGroupViewModel (label, styles, chips[])
- TextViewModel (label, value, placeholder, styles, onChangeText)

Gebruik ViewStyle en TextStyle types.
Maak union type ComponentViewModel."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1797
// Timestamp:     2026-02-06T08:17:36.189Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1798
// Timestamp:     2026-02-06T08:17:36.192Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1799
// Timestamp:     2026-02-06T08:17:36.193Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1800
// Timestamp:     2026-02-06T08:17:36.195Z
// ==========================================================
// Prompt voor AI:
"Maak ComponentOrchestrator.ts die:
- Constructor: (fso, styles)
- buildComponentViewModel(fieldVM) ‚Üí switch op componentType
- buildCounter(fieldVM) ‚Üí CounterViewModel met:
  - label via labelFromToken()
  - value type-safe (ensureNumber helper)
  - styles pre-assigned
  - onUpdate pre-bound naar fso.updateField
- buildChipGroup(fieldVM) ‚Üí ChipGroupViewModel met:
  - alle chips pre-built via buildChip()
  - toggle logic in onPress
- buildChip(label, selected, onPress) ‚Üí ChipViewModel met:
  - containerStyle: [styles.chip, selected && styles.chipSelected]
  - textStyle: [styles.chipText, selected && styles.chipTextSelected]

Voeg helpers toe: ensureNumber(), ensureString()."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1801
// Timestamp:     2026-02-06T08:17:36.198Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1802
// Timestamp:     2026-02-06T08:17:36.200Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1803
// Timestamp:     2026-02-06T08:17:36.205Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1804
// Timestamp:     2026-02-06T08:17:36.207Z
// ==========================================================
// Prompt voor AI:
"Herschrijf FieldRenderer.tsx naar:
- Props: { viewModel: ComponentViewModel }
- renderComponent(vm) met switch op vm.componentType
- Elk case: 3-5 lines, gebruik vm.* properties direct
- Counter case: <View style={vm.containerStyle}><Text>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} />
- ChipGroup case: map over vm.chips, render ChipButton met viewModel={chip}
- Error rendering: {vm.error && <Text style={vm.errorStyle}>{vm.error}</Text>}

Gebruik default imports voor components."


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1805
// Timestamp:     2026-02-06T08:17:36.208Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1806
// Timestamp:     2026-02-06T08:17:36.210Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1807
// Timestamp:     2026-02-06T08:17:36.215Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1808
// Timestamp:     2026-02-06T08:17:36.216Z
// ==========================================================
// Prompt voor AI:
"Herschrijf ChipButton.tsx naar:
- Props: { viewModel: ChipViewModel }
- Render: TouchableOpacity met viewModel.containerStyle, onPress, a11y
- Text met viewModel.textStyle
- Geen logica, pure rendering"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1809
// Timestamp:     2026-02-06T08:17:36.218Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1810
// Timestamp:     2026-02-06T08:17:36.220Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1811
// Timestamp:     2026-02-06T08:17:36.221Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1812
// Timestamp:     2026-02-06T08:17:36.222Z
// ==========================================================
// Prompt voor AI:
"Update WizardPage.tsx:
- Maak ComponentOrchestrator: useMemo(() => new ComponentOrchestrator(fso, styles))
- Build fieldViewModels via renderOrch.buildFieldViewModel() (huidige code)
- Transform naar componentViewModels via componentOrch.buildComponentViewModel()
- Render: {componentViewModels.map(vm => <FieldRenderer viewModel={vm} />)}"


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1813
// Timestamp:     2026-02-06T08:17:36.224Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1814
// Timestamp:     2026-02-06T08:17:36.225Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1815
// Timestamp:     2026-02-06T08:17:36.225Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1816
// Timestamp:     2026-02-06T08:17:36.226Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1817
// Timestamp:     2026-02-06T08:17:36.229Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1818
// Timestamp:     2026-02-06T08:17:36.230Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1819
// Timestamp:     2026-02-06T08:17:36.231Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1820
// Timestamp:     2026-02-06T08:17:36.232Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1821
// Timestamp:     2026-02-06T08:17:36.232Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1822
// Timestamp:     2026-02-06T08:17:36.235Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1823
// Timestamp:     2026-02-06T08:17:36.235Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1824
// Timestamp:     2026-02-06T08:17:36.236Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1825
// Timestamp:     2026-02-06T08:17:36.236Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1826
// Timestamp:     2026-02-06T08:17:36.237Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1827
// Timestamp:     2026-02-06T08:17:36.239Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1828
// Timestamp:     2026-02-06T08:17:36.239Z
// ==========================================================
// Nieuwe field type toevoegen?

// ZONDER ComponentOrchestrator (huidige):
// 1. Update FieldRenderer.helpers (5+ plekken wijzigen)
// 2. Add render function (15 lines)
// 3. Add case in switch
// 4. Update types
// 5. Test manually
// ‚Üí 10-15 minuten, foutgevoelig

// MET ComponentOrchestrator:
// Prompt: "Voeg DatePickerViewModel toe + buildDatePicker() method"
// AI genereert:
// - ViewModel type (3 lines)
// - Build method (10 lines)
// - Renderer case (3 lines)
// ‚Üí Copy-paste, klaar. 2 minuten, type-safe!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1829
// Timestamp:     2026-02-06T08:17:36.240Z
// ==========================================================
Genereer src/domain/viewmodels/ComponentViewModels.ts volgens deze spec:

1. Base interface met fieldId, componentType, error, errorStyle
2. CounterViewModel extends Base met: label, value (number), containerStyle, labelStyle, onUpdate callback
3. CurrencyViewModel extends Base met: label, value (number), placeholder, containerStyle, labelStyle, onUpdate callback
4. ChipViewModel (geen extends) met: label, selected (bool), containerStyle, textStyle, onPress, accessibilityLabel, accessibilityState
5. ChipGroupViewModel extends Base met: label, containerStyle, labelStyle, chipContainerStyle, chips array
6. TextViewModel extends Base met: label, value (string), placeholder, containerStyle, labelStyle, onChangeText callback
7. Union type ComponentViewModel voor alle bovenstaande

Gebruik ViewStyle en TextStyle van react-native.
Export alle types.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1830
// Timestamp:     2026-02-06T08:17:36.241Z
// ==========================================================
Genereer src/app/orchestrators/ComponentOrchestrator.ts:

Class met constructor(fso: FormStateOrchestrator, styles: any)

Methodes:
1. buildComponentViewModel(fieldViewModel): switch op componentType, retourneert ComponentViewModel|null
2. buildCounter(vm): Retourneert CounterViewModel met:
   - label via labelFromToken(vm.labelToken)
   - value via ensureNumber(vm.value)
   - styles direct assigned
   - onUpdate: (n) => this.fso.updateField(vm.fieldId, n)
3. buildCurrency(vm): Zoals counter, plus placeholder resolve
4. buildChipGroup(vm): Retourneert ChipGroupViewModel met:
   - chips: options.map(opt => buildChip(opt, currentValue === opt, () => fso.updateField()))
5. buildChipGroupMultiple(vm): Zoals chipGroup maar toggle logic in callback
6. buildChip(label, selected, onPress): Retourneert ChipViewModel met:
   - containerStyle: [styles.chip, selected && styles.chipSelected]
   - textStyle: [styles.chipText, selected && styles.chipTextSelected]
7. buildText(vm): Retourneert TextViewModel

Helpers:
- ensureNumber(val): typeof val === 'number' ? val : 0
- ensureString(val): typeof val === 'string' ? val : ''

Import: FormStateOrchestrator, ComponentViewModels, labelFromToken


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1831
// Timestamp:     2026-02-06T08:17:36.243Z
// ==========================================================
Herschrijf src/ui/components/FieldRenderer.tsx:

Props: { viewModel: ComponentViewModel }

Main component:
- Return null als !viewModel.isVisible (safety)
- Render: <View>{renderComponent(viewModel)}{error rendering}</View>

renderComponent(vm) functie met switch:
- case 'counter': <View style={vm.containerStyle}><Text style={vm.labelStyle}>{vm.label}</Text><InputCounter value={vm.value} onUpdate={vm.onUpdate} /></View>
- case 'currency': Zoals counter maar MoneyInput met placeholder
- case 'chip-group'|'chip-group-multiple': <View><Text>{vm.label}</Text><ScrollView horizontal chipContainerStyle>{vm.chips.map(chip => <ChipButton key={chip.label} viewModel={chip} />)}</ScrollView></View>
- case 'text': <View><Text>{vm.label}</Text><FormField value={vm.value} onChangeText={vm.onChangeText} placeholder={vm.placeholder} /></View>

Error rendering: {vm.error && vm.errorStyle && <Text style={vm.errorStyle}>{vm.error}</Text>}

Import ComponentViewModel, en default imports: InputCounter, MoneyInput, ChipButton, FormField


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1832
// Timestamp:     2026-02-06T08:17:36.243Z
// ==========================================================
Herschrijf src/ui/components/fields/ChipButton.tsx:

Props: { viewModel: ChipViewModel }

Pure functional component:
<TouchableOpacity
  style={viewModel.containerStyle}
  onPress={viewModel.onPress}
  accessibilityRole="button"
  accessibilityLabel={viewModel.accessibilityLabel}
  accessibilityState={viewModel.accessibilityState}
>
  <Text style={viewModel.textStyle}>{viewModel.label}</Text>
</TouchableOpacity>

Export default.
Import ChipViewModel from ComponentViewModels.


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1833
// Timestamp:     2026-02-06T08:17:36.247Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1834
// Timestamp:     2026-02-06T08:17:36.249Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1835
// Timestamp:     2026-02-06T08:17:36.250Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1836
// Timestamp:     2026-02-06T08:17:36.253Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1837
// Timestamp:     2026-02-06T08:17:36.253Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1838
// Timestamp:     2026-02-06T08:17:36.254Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1839
// Timestamp:     2026-02-06T08:17:36.255Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1840
// Timestamp:     2026-02-06T08:17:36.256Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1841
// Timestamp:     2026-02-06T08:17:36.256Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1842
// Timestamp:     2026-02-06T08:17:36.256Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1843
// Timestamp:     2026-02-06T08:17:36.256Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1844
// Timestamp:     2026-02-06T08:17:36.257Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1845
// Timestamp:     2026-02-06T08:17:36.260Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1846
// Timestamp:     2026-02-06T08:17:36.264Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1847
// Timestamp:     2026-02-06T08:17:36.264Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Step 2: Transform to ComponentViewModels (presentation level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm) => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1848
// Timestamp:     2026-02-06T08:17:36.264Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Step 2: Transform to ComponentViewModels (presentation level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm) => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1849
// Timestamp:     2026-02-06T08:17:36.265Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1850
// Timestamp:     2026-02-06T08:17:36.265Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1851
// Timestamp:     2026-02-06T08:17:36.265Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1852
// Timestamp:     2026-02-06T08:17:36.266Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1853
// Timestamp:     2026-02-06T08:17:36.267Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1854
// Timestamp:     2026-02-06T08:17:36.268Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1855
// Timestamp:     2026-02-06T08:17:36.270Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1856
// Timestamp:     2026-02-06T08:17:36.270Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1857
// Timestamp:     2026-02-06T08:17:36.271Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1858
// Timestamp:     2026-02-06T08:17:36.271Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1859
// Timestamp:     2026-02-06T08:17:36.272Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1860
// Timestamp:     2026-02-06T08:17:36.274Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1861
// Timestamp:     2026-02-06T08:17:36.275Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1862
// Timestamp:     2026-02-06T08:17:36.276Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1863
// Timestamp:     2026-02-06T08:17:36.278Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Step 2: Transform to ComponentViewModels (presentation level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm) => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1864
// Timestamp:     2026-02-06T08:17:36.278Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';

export const WizardPage: React.FC<Props> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business level)
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => 
        orchestrator.render.buildFieldViewModel(fieldConfig.fieldId, context)
      )
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator, context]);

  // Step 2: Transform to ComponentViewModels (presentation level)
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm) => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <View>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </View>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1865
// Timestamp:     2026-02-06T08:17:36.280Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1866
// Timestamp:     2026-02-06T08:17:36.280Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1867
// Timestamp:     2026-02-06T08:17:36.280Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1868
// Timestamp:     2026-02-06T08:17:36.283Z
// ==========================================================
// ‚ùå FOUT: Horizontale dependency
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct import!
    private readonly styles: any
  ) {}
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1869
// Timestamp:     2026-02-06T08:17:36.283Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1870
// Timestamp:     2026-02-06T08:17:36.283Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1871
// Timestamp:     2026-02-06T08:17:36.283Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1872
// Timestamp:     2026-02-06T08:17:36.283Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1873
// Timestamp:     2026-02-06T08:17:36.283Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1874
// Timestamp:     2026-02-06T08:17:36.283Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1875
// Timestamp:     2026-02-06T08:17:36.283Z
// ==========================================================
// FieldRegistry.ts
export const FIELD_REGISTRY = {
  aantalMensen: {
    componentType: 'counter',  // ‚Üê Waarheid 1
    // ...
  }
};

// ComponentViewModels.ts
export interface CounterViewModel {
  componentType: 'counter',    // ‚Üê Waarheid 2 (duplicate!)
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1876
// Timestamp:     2026-02-06T08:17:36.283Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             SINGLE SOURCE OF TRUTH (Domain)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts         ComponentRegistry.ts           ‚îÇ
‚îÇ  ‚îî‚îÄ Field metadata        ‚îî‚îÄ Component metadata          ‚îÇ
‚îÇ     (business level)         (presentation level)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  MASTER ORCHESTRATOR                     ‚îÇ
‚îÇ                  (Only entry point)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  - Owns all orchestrators                                ‚îÇ
‚îÇ  - Provides facades/callbacks                            ‚îÇ
‚îÇ  - NO orchestrator knows each other directly             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì              ‚Üì              ‚Üì              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   FormState ‚îÇ ‚îÇ   Render    ‚îÇ ‚îÇ Visibility  ‚îÇ ‚îÇ Component   ‚îÇ
‚îÇ Orchestrator‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ ‚îÇOrchestrator ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                       ‚Üì
                                              Uses ComponentRegistry


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1877
// Timestamp:     2026-02-06T08:17:36.284Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1878
// Timestamp:     2026-02-06T08:17:36.285Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1879
// Timestamp:     2026-02-06T08:17:36.286Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1880
// Timestamp:     2026-02-06T08:17:36.288Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * COMPONENT TYPES - Single Source of Truth
 * 
 * These are the ONLY allowed component types in the system.
 * Used by both FieldRegistry (domain) and ComponentOrchestrator (presentation).
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * COMPONENT VIEW MODELS
 * 
 * UI-ready ViewModels - all logic pre-computed
 */
export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;  // ‚Üê Uses SSOT!
  error?: string | null;
  errorStyle?: TextStyle;
}

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;  // ‚Üê Type-safe!
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// Union type
export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | ChipGroupViewModel
  | TextViewModel;
  // ... add others

/**
 * COMPONENT METADATA REGISTRY
 * 
 * Defines how each component type should be built
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Needs options array?
  supportsPlaceholder: boolean; // Has placeholder?
  isReadOnly: boolean;          // Read-only (like label)?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
  },
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
  },
  // ... etc
};

/**
 * Helper to get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Validation: Check if component type is known
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1881
// Timestamp:     2026-02-06T08:17:36.289Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1882
// Timestamp:     2026-02-06T08:17:36.289Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1883
// Timestamp:     2026-02-06T08:17:36.289Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1884
// Timestamp:     2026-02-06T08:17:36.292Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    defaultValue: 1,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê Uses SSOT constant!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },
  
  // ... etc - all use COMPONENT_TYPES.XXX
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1885
// Timestamp:     2026-02-06T08:17:36.292Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1886
// Timestamp:     2026-02-06T08:17:36.292Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1887
// Timestamp:     2026-02-06T08:17:36.292Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1888
// Timestamp:     2026-02-06T08:17:36.293Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import { ComponentViewModel, COMPONENT_TYPES, ComponentType } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';

/**
 * UPDATE CALLBACK - Facade for state updates
 * 
 * ComponentOrchestrator doesn't know about FSO directly!
 * It gets this callback from MasterOrchestrator.
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * COMPONENT ORCHESTRATOR
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * ARCHITECTURE RULES:
 * - NO direct imports of other orchestrators
 * - Receives callbacks from MasterOrchestrator
 * - Uses ComponentRegistry for SSOT
 * - Pure transformation (no state, no side effects)
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, not direct FSO!
    private readonly styles: any  // Injected styles
  ) {}

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses ComponentRegistry SSOT for type safety
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but double-check)
    if (!fieldViewModel.isVisible) return null;

    // Use COMPONENT_TYPES for exhaustive switch
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      // ... add other types
      
      default:
        // TypeScript will error if we miss a case (exhaustive check)
        return null;
    }
  }

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT constant
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        // ‚Üê Uses callback, not direct FSO!
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);  // ‚Üê Callback!
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);  // ‚Üê Callback!
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      chipContainerStyle: this.styles.chipContainer,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ];

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ];

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer,
      labelStyle: this.styles.label,
      error: vm.error,
      errorStyle: this.styles.errorText,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private ensureNumber(value: unknown): number {
    return typeof value === 'number' ? value : 0;
  }

  private ensureString(value: unknown): string {
    return typeof value === 'string' ? value : '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1889
// Timestamp:     2026-02-06T08:17:36.293Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1890
// Timestamp:     2026-02-06T08:17:36.293Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1891
// Timestamp:     2026-02-06T08:17:36.293Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1892
// Timestamp:     2026-02-06T08:17:36.293Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { VisibilityOrchestrator } from './VisibilityOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';

/**
 * MASTER ORCHESTRATOR
 * 
 * ONLY entry point - owns all orchestrators
 * Provides facades/callbacks to prevent horizontal dependencies
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW! Private!

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any  // From useAppStyles
  ) {
    // Initialize orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback (not direct FSO!)
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  /**
   * PUBLIC API: Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Existing updateField method (used by component callbacks)
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... rest of updateField logic
  }

  // ... rest of Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1893
// Timestamp:     2026-02-06T08:17:36.295Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1894
// Timestamp:     2026-02-06T08:17:36.297Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1895
// Timestamp:     2026-02-06T08:17:36.297Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1896
// Timestamp:     2026-02-06T08:17:36.298Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1897
// Timestamp:     2026-02-06T08:17:36.299Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1898
// Timestamp:     2026-02-06T08:17:36.299Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1899
// Timestamp:     2026-02-06T08:17:36.299Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  // ==================== HOUSEHOLD SETUP ====================
  
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    constraintsKey: 'aantalMensen',
    defaultValue: 1,
  },
  
  aantalVolwassen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_VOLWASSENEN',
    visibilityRuleName: 'isAdultInputVisible',
    constraintsKey: 'aantalVolwassen',
    uiModel: 'numericWrapper',
  },
  
  kinderenLabel: {
    componentType: COMPONENT_TYPES.LABEL,  // ‚Üê SSOT!
    labelToken: 'LABEL_KINDEREN',
    visibilityRuleName: 'calculateChildrenCount',
    isDerived: true,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },

  heeftHuisdieren: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_HUISDIEREN',
    optionsKey: 'isBoolean', 
    defaultValue: 'Nee',
  },
  
  // ==================== HOUSEHOLD DETAILS ====================
  
  burgerlijkeStaat: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_BURGERLIJKE_STAAT',
    visibilityRuleName: 'showMaritalStatus',
    optionsKey: 'burgerlijkeStaat',
  },
  
  woningType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_WONING_TYPE',
    optionsKey: 'woningType',
    defaultValue: 'Huur',
  },
  
  postcode: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_POSTCODE',
    placeholderToken: '1234',
    visibilityRuleName: 'showPostcode',
    constraintsKey: 'postcode',
  },
  
  // ==================== MEMBER FIELDS ====================
  
  naam: {
    componentType: COMPONENT_TYPES.TEXT,  // ‚Üê SSOT!
    labelToken: 'LABEL_NAME',
    placeholderToken: 'PLACEHOLDER_NAME',
    constraintsKey: 'naam',
  },
  
  leeftijd: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AGE',
    constraintsKey: 'leeftijd',
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',
  },
  
  // ==================== INCOME FIELDS ====================
  
  incomeCategory: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_INCOME_CATS',
    optionsKey: 'incomeCategory',
  },
  
  aow_bedrag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_AOW_BEDRAG',
    placeholderToken: '0.00',
    visibilityRuleName: 'isPensionado',
    constraintsKey: 'nettoSalaris',
  },

  nettoSalaris: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_NETTO_SALARIS',
    placeholderToken: '0.00',
    visibilityRuleName: 'hasWorkSelected',
    constraintsKey: 'nettoSalaris',
  },
  
  frequentie: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_FREQUENTIE',
    optionsKey: 'incomeFrequency',
  },
  
  vakantiegeldPerJaar: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_VAKANTIEGELD_JAAR',
    placeholderToken: '0.00',
    constraintsKey: 'vakantiegeldPerJaar',
  },
  
  uitkeringType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_UITKERING_TYPE',
    visibilityRuleName: 'hasBenefitSelected',
    optionsKey: 'uitkeringType',
  },
  
  zorgtoeslag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_ZORGTOESLAG',
    placeholderToken: 'LABEL_ZORGTOESLAG_PM',
    constraintsKey: 'zorgtoeslag',
  },
  
  // ... add rest of fields using COMPONENT_TYPES.XXX
};

export function getFieldDefinition(fieldId: string): FieldDefinition | null {
  return FIELD_REGISTRY[fieldId] ?? null;
}

export function isKnownField(fieldId: string): boolean {
  return fieldId in FIELD_REGISTRY;
}

export function getFieldsByComponentType(type: ComponentType): string[] {
  return Object.entries(FIELD_REGISTRY)
    .filter(([_, def]) => def.componentType === type)
    .map(([fieldId]) => fieldId);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1900
// Timestamp:     2026-02-06T08:17:36.300Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  // ==================== HOUSEHOLD SETUP ====================
  
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    constraintsKey: 'aantalMensen',
    defaultValue: 1,
  },
  
  aantalVolwassen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_VOLWASSENEN',
    visibilityRuleName: 'isAdultInputVisible',
    constraintsKey: 'aantalVolwassen',
    uiModel: 'numericWrapper',
  },
  
  kinderenLabel: {
    componentType: COMPONENT_TYPES.LABEL,  // ‚Üê SSOT!
    labelToken: 'LABEL_KINDEREN',
    visibilityRuleName: 'calculateChildrenCount',
    isDerived: true,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },

  heeftHuisdieren: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_HUISDIEREN',
    optionsKey: 'isBoolean', 
    defaultValue: 'Nee',
  },
  
  // ==================== HOUSEHOLD DETAILS ====================
  
  burgerlijkeStaat: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_BURGERLIJKE_STAAT',
    visibilityRuleName: 'showMaritalStatus',
    optionsKey: 'burgerlijkeStaat',
  },
  
  woningType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_WONING_TYPE',
    optionsKey: 'woningType',
    defaultValue: 'Huur',
  },
  
  postcode: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_POSTCODE',
    placeholderToken: '1234',
    visibilityRuleName: 'showPostcode',
    constraintsKey: 'postcode',
  },
  
  // ==================== MEMBER FIELDS ====================
  
  naam: {
    componentType: COMPONENT_TYPES.TEXT,  // ‚Üê SSOT!
    labelToken: 'LABEL_NAME',
    placeholderToken: 'PLACEHOLDER_NAME',
    constraintsKey: 'naam',
  },
  
  leeftijd: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AGE',
    constraintsKey: 'leeftijd',
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',
  },
  
  // ==================== INCOME FIELDS ====================
  
  incomeCategory: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_INCOME_CATS',
    optionsKey: 'incomeCategory',
  },
  
  aow_bedrag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_AOW_BEDRAG',
    placeholderToken: '0.00',
    visibilityRuleName: 'isPensionado',
    constraintsKey: 'nettoSalaris',
  },

  nettoSalaris: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_NETTO_SALARIS',
    placeholderToken: '0.00',
    visibilityRuleName: 'hasWorkSelected',
    constraintsKey: 'nettoSalaris',
  },
  
  frequentie: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_FREQUENTIE',
    optionsKey: 'incomeFrequency',
  },
  
  vakantiegeldPerJaar: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_VAKANTIEGELD_JAAR',
    placeholderToken: '0.00',
    constraintsKey: 'vakantiegeldPerJaar',
  },
  
  uitkeringType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_UITKERING_TYPE',
    visibilityRuleName: 'hasBenefitSelected',
    optionsKey: 'uitkeringType',
  },
  
  zorgtoeslag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_ZORGTOESLAG',
    placeholderToken: 'LABEL_ZORGTOESLAG_PM',
    constraintsKey: 'zorgtoeslag',
  },
  
  // ... add rest of fields using COMPONENT_TYPES.XXX
};

export function getFieldDefinition(fieldId: string): FieldDefinition | null {
  return FIELD_REGISTRY[fieldId] ?? null;
}

export function isKnownField(fieldId: string): boolean {
  return fieldId in FIELD_REGISTRY;
}

export function getFieldsByComponentType(type: ComponentType): string[] {
  return Object.entries(FIELD_REGISTRY)
    .filter(([_, def]) => def.componentType === type)
    .map(([fieldId]) => fieldId);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1901
// Timestamp:     2026-02-06T08:17:36.300Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1902
// Timestamp:     2026-02-06T08:17:36.301Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1903
// Timestamp:     2026-02-06T08:17:36.301Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/registry/ComponentRegistry';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * 
 * No logic, no decisions - just render ViewModel
 * All style/state logic done in ComponentOrchestrator
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1904
// Timestamp:     2026-02-06T08:17:36.302Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/registry/ComponentRegistry';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * 
 * No logic, no decisions - just render ViewModel
 * All style/state logic done in ComponentOrchestrator
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1905
// Timestamp:     2026-02-06T08:17:36.302Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1906
// Timestamp:     2026-02-06T08:17:36.302Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1907
// Timestamp:     2026-02-06T08:17:36.303Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1908
// Timestamp:     2026-02-06T08:17:36.305Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1909
// Timestamp:     2026-02-06T08:17:36.307Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1910
// Timestamp:     2026-02-06T08:17:36.307Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1911
// Timestamp:     2026-02-06T08:17:36.307Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1912
// Timestamp:     2026-02-06T08:17:36.308Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1913
// Timestamp:     2026-02-06T08:17:36.308Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  // ==================== HOUSEHOLD SETUP ====================
  
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    constraintsKey: 'aantalMensen',
    defaultValue: 1,
  },
  
  aantalVolwassen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_VOLWASSENEN',
    visibilityRuleName: 'isAdultInputVisible',
    constraintsKey: 'aantalVolwassen',
    uiModel: 'numericWrapper',
  },
  
  kinderenLabel: {
    componentType: COMPONENT_TYPES.LABEL,  // ‚Üê SSOT!
    labelToken: 'LABEL_KINDEREN',
    visibilityRuleName: 'calculateChildrenCount',
    isDerived: true,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },

  heeftHuisdieren: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_HUISDIEREN',
    optionsKey: 'isBoolean', 
    defaultValue: 'Nee',
  },
  
  // ==================== HOUSEHOLD DETAILS ====================
  
  burgerlijkeStaat: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_BURGERLIJKE_STAAT',
    visibilityRuleName: 'showMaritalStatus',
    optionsKey: 'burgerlijkeStaat',
  },
  
  woningType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_WONING_TYPE',
    optionsKey: 'woningType',
    defaultValue: 'Huur',
  },
  
  postcode: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_POSTCODE',
    placeholderToken: '1234',
    visibilityRuleName: 'showPostcode',
    constraintsKey: 'postcode',
  },
  
  // ==================== MEMBER FIELDS ====================
  
  naam: {
    componentType: COMPONENT_TYPES.TEXT,  // ‚Üê SSOT!
    labelToken: 'LABEL_NAME',
    placeholderToken: 'PLACEHOLDER_NAME',
    constraintsKey: 'naam',
  },
  
  leeftijd: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AGE',
    constraintsKey: 'leeftijd',
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',
  },
  
  // ==================== INCOME FIELDS ====================
  
  incomeCategory: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_INCOME_CATS',
    optionsKey: 'incomeCategory',
  },
  
  aow_bedrag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_AOW_BEDRAG',
    placeholderToken: '0.00',
    visibilityRuleName: 'isPensionado',
    constraintsKey: 'nettoSalaris',
  },

  nettoSalaris: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_NETTO_SALARIS',
    placeholderToken: '0.00',
    visibilityRuleName: 'hasWorkSelected',
    constraintsKey: 'nettoSalaris',
  },
  
  frequentie: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_FREQUENTIE',
    optionsKey: 'incomeFrequency',
  },
  
  vakantiegeldPerJaar: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_VAKANTIEGELD_JAAR',
    placeholderToken: '0.00',
    constraintsKey: 'vakantiegeldPerJaar',
  },
  
  uitkeringType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_UITKERING_TYPE',
    visibilityRuleName: 'hasBenefitSelected',
    optionsKey: 'uitkeringType',
  },
  
  zorgtoeslag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_ZORGTOESLAG',
    placeholderToken: 'LABEL_ZORGTOESLAG_PM',
    constraintsKey: 'zorgtoeslag',
  },
  
  // ... add rest of fields using COMPONENT_TYPES.XXX
};

export function getFieldDefinition(fieldId: string): FieldDefinition | null {
  return FIELD_REGISTRY[fieldId] ?? null;
}

export function isKnownField(fieldId: string): boolean {
  return fieldId in FIELD_REGISTRY;
}

export function getFieldsByComponentType(type: ComponentType): string[] {
  return Object.entries(FIELD_REGISTRY)
    .filter(([_, def]) => def.componentType === type)
    .map(([fieldId]) => fieldId);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1914
// Timestamp:     2026-02-06T08:17:36.309Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts

import { COMPONENT_TYPES, ComponentType } from './ComponentRegistry';  // ‚Üê Import SSOT!

export interface FieldDefinition {
  componentType: ComponentType;  // ‚Üê Uses SSOT type!
  labelToken: string;
  placeholderToken?: string;
  visibilityRuleName?: string;
  optionsKey?: string;
  constraintsKey?: string;
  uiModel?: 'numericWrapper' | 'collapsible' | 'swipeable' | 'readonly';
  isDerived?: boolean;
  defaultValue?: unknown;
}

export const FIELD_REGISTRY: Record<string, FieldDefinition> = {
  // ==================== HOUSEHOLD SETUP ====================
  
  aantalMensen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_MENSEN',
    uiModel: 'numericWrapper',
    constraintsKey: 'aantalMensen',
    defaultValue: 1,
  },
  
  aantalVolwassen: {
    componentType: COMPONENT_TYPES.COUNTER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AANTAL_VOLWASSENEN',
    visibilityRuleName: 'isAdultInputVisible',
    constraintsKey: 'aantalVolwassen',
    uiModel: 'numericWrapper',
  },
  
  kinderenLabel: {
    componentType: COMPONENT_TYPES.LABEL,  // ‚Üê SSOT!
    labelToken: 'LABEL_KINDEREN',
    visibilityRuleName: 'calculateChildrenCount',
    isDerived: true,
  },
  
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',
    defaultValue: 'Geen',
  },

  heeftHuisdieren: {
    componentType: COMPONENT_TYPES.RADIO,  // ‚Üê SSOT!
    labelToken: 'LABEL_HUISDIEREN',
    optionsKey: 'isBoolean', 
    defaultValue: 'Nee',
  },
  
  // ==================== HOUSEHOLD DETAILS ====================
  
  burgerlijkeStaat: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_BURGERLIJKE_STAAT',
    visibilityRuleName: 'showMaritalStatus',
    optionsKey: 'burgerlijkeStaat',
  },
  
  woningType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_WONING_TYPE',
    optionsKey: 'woningType',
    defaultValue: 'Huur',
  },
  
  postcode: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_POSTCODE',
    placeholderToken: '1234',
    visibilityRuleName: 'showPostcode',
    constraintsKey: 'postcode',
  },
  
  // ==================== MEMBER FIELDS ====================
  
  naam: {
    componentType: COMPONENT_TYPES.TEXT,  // ‚Üê SSOT!
    labelToken: 'LABEL_NAME',
    placeholderToken: 'PLACEHOLDER_NAME',
    constraintsKey: 'naam',
  },
  
  leeftijd: {
    componentType: COMPONENT_TYPES.NUMBER,  // ‚Üê SSOT!
    labelToken: 'LABEL_AGE',
    constraintsKey: 'leeftijd',
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',
  },
  
  // ==================== INCOME FIELDS ====================
  
  incomeCategory: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_INCOME_CATS',
    optionsKey: 'incomeCategory',
  },
  
  aow_bedrag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_AOW_BEDRAG',
    placeholderToken: '0.00',
    visibilityRuleName: 'isPensionado',
    constraintsKey: 'nettoSalaris',
  },

  nettoSalaris: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_NETTO_SALARIS',
    placeholderToken: '0.00',
    visibilityRuleName: 'hasWorkSelected',
    constraintsKey: 'nettoSalaris',
  },
  
  frequentie: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,  // ‚Üê SSOT!
    labelToken: 'LABEL_FREQUENTIE',
    optionsKey: 'incomeFrequency',
  },
  
  vakantiegeldPerJaar: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_VAKANTIEGELD_JAAR',
    placeholderToken: '0.00',
    constraintsKey: 'vakantiegeldPerJaar',
  },
  
  uitkeringType: {
    componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,  // ‚Üê SSOT!
    labelToken: 'LABEL_UITKERING_TYPE',
    visibilityRuleName: 'hasBenefitSelected',
    optionsKey: 'uitkeringType',
  },
  
  zorgtoeslag: {
    componentType: COMPONENT_TYPES.CURRENCY,  // ‚Üê SSOT!
    labelToken: 'LABEL_ZORGTOESLAG',
    placeholderToken: 'LABEL_ZORGTOESLAG_PM',
    constraintsKey: 'zorgtoeslag',
  },
  
  // ... add rest of fields using COMPONENT_TYPES.XXX
};

export function getFieldDefinition(fieldId: string): FieldDefinition | null {
  return FIELD_REGISTRY[fieldId] ?? null;
}

export function isKnownField(fieldId: string): boolean {
  return fieldId in FIELD_REGISTRY;
}

export function getFieldsByComponentType(type: ComponentType): string[] {
  return Object.entries(FIELD_REGISTRY)
    .filter(([_, def]) => def.componentType === type)
    .map(([fieldId]) => fieldId);
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1915
// Timestamp:     2026-02-06T08:17:36.309Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1916
// Timestamp:     2026-02-06T08:17:36.310Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1917
// Timestamp:     2026-02-06T08:17:36.311Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/registry/ComponentRegistry';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * 
 * No logic, no decisions - just render ViewModel
 * All style/state logic done in ComponentOrchestrator
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1918
// Timestamp:     2026-02-06T08:17:36.311Z
// ==========================================================
// src/ui/components/fields/ChipButton.tsx

import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import { ChipViewModel } from '@domain/registry/ComponentRegistry';

interface ChipButtonProps {
  viewModel: ChipViewModel;  // ‚Üê Pre-built!
}

/**
 * ULTRA-DUMB ChipButton
 * 
 * No logic, no decisions - just render ViewModel
 * All style/state logic done in ComponentOrchestrator
 */
const ChipButton: React.FC<ChipButtonProps> = ({ viewModel }) => {
  return (
    <TouchableOpacity
      style={viewModel.containerStyle}
      onPress={viewModel.onPress}
      accessibilityRole="button"
      accessibilityLabel={viewModel.accessibilityLabel}
      accessibilityState={viewModel.accessibilityState}
    >
      <Text style={viewModel.textStyle}>
        {viewModel.label}
      </Text>
    </TouchableOpacity>
  );
};

export default ChipButton;


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1919
// Timestamp:     2026-02-06T08:17:36.312Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1920
// Timestamp:     2026-02-06T08:17:36.312Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1921
// Timestamp:     2026-02-06T08:17:36.313Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1922
// Timestamp:     2026-02-06T08:17:36.314Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1923
// Timestamp:     2026-02-06T08:17:36.315Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1924
// Timestamp:     2026-02-06T08:17:36.315Z
// ==========================================================
// src/domain/registry/ComponentRegistry.ts

import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT TYPES - SINGLE SOURCE OF TRUTH
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * These constants are the ONLY allowed component types.
 * Used throughout the system - never use string literals!
 * 
 * Adding a new type:
 * 1. Add constant here
 * 2. Add ViewModel interface
 * 3. Add metadata entry
 * 4. Add case in ComponentOrchestrator
 * 5. Add case in FieldRenderer
 */
export const COMPONENT_TYPES = {
  COUNTER: 'counter',
  CURRENCY: 'currency',
  TEXT: 'text',
  NUMBER: 'number',
  CHIP_GROUP: 'chip-group',
  CHIP_GROUP_MULTIPLE: 'chip-group-multiple',
  RADIO: 'radio',
  LABEL: 'label',
  DATE: 'date',
} as const;

export type ComponentType = typeof COMPONENT_TYPES[keyof typeof COMPONENT_TYPES];

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT VIEW MODELS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * UI-ready ViewModels with all logic pre-computed.
 * Components receive these and just render - no decisions!
 */

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ BASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface BaseComponentViewModel {
  fieldId: string;
  componentType: ComponentType;
  error?: string | null;
  errorStyle?: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COUNTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CounterViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.COUNTER;
  label: string;
  value: number;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CURRENCY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface CurrencyViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CURRENCY;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onUpdate: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEXT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface TextViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.TEXT;
  label: string;
  value: string;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (text: string) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NUMBER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface NumberViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.NUMBER;
  label: string;
  value: number;
  placeholder?: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChangeText: (value: number) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHIPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface ChipViewModel {
  label: string;
  selected: boolean;
  containerStyle: ViewStyle;
  textStyle: TextStyle;
  onPress: () => void;
  accessibilityLabel: string;
  accessibilityState: { selected: boolean };
}

export interface ChipGroupViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.CHIP_GROUP | typeof COMPONENT_TYPES.CHIP_GROUP_MULTIPLE;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  chipContainerStyle: ViewStyle;
  chips: ChipViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RADIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface RadioOptionViewModel {
  label: string;
  value: string;
  selected: boolean;
  onSelect: () => void;
}

export interface RadioViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.RADIO;
  label: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  radioContainerStyle: ViewStyle;
  options: RadioOptionViewModel[];
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LABEL (read-only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface LabelViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.LABEL;
  label: string;
  value: string;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  valueStyle: TextStyle;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ DATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export interface DateViewModel extends BaseComponentViewModel {
  componentType: typeof COMPONENT_TYPES.DATE;
  label: string;
  value?: Date;
  containerStyle: ViewStyle;
  labelStyle: TextStyle;
  onChange: (date: Date) => void;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ UNION TYPE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export type ComponentViewModel =
  | CounterViewModel
  | CurrencyViewModel
  | TextViewModel
  | NumberViewModel
  | ChipGroupViewModel
  | RadioViewModel
  | LabelViewModel
  | DateViewModel;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT METADATA REGISTRY
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Defines characteristics of each component type.
 * Used for validation and dynamic behavior.
 */
export interface ComponentMetadata {
  type: ComponentType;
  requiresOptions: boolean;     // Must have options array?
  supportsPlaceholder: boolean; // Can have placeholder text?
  isReadOnly: boolean;          // User cannot edit?
  supportsMultiSelect: boolean; // Can select multiple values?
}

export const COMPONENT_METADATA: Record<ComponentType, ComponentMetadata> = {
  [COMPONENT_TYPES.COUNTER]: {
    type: COMPONENT_TYPES.COUNTER,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CURRENCY]: {
    type: COMPONENT_TYPES.CURRENCY,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.TEXT]: {
    type: COMPONENT_TYPES.TEXT,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.NUMBER]: {
    type: COMPONENT_TYPES.NUMBER,
    requiresOptions: false,
    supportsPlaceholder: true,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP]: {
    type: COMPONENT_TYPES.CHIP_GROUP,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.CHIP_GROUP_MULTIPLE]: {
    type: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: true,
  },
  
  [COMPONENT_TYPES.RADIO]: {
    type: COMPONENT_TYPES.RADIO,
    requiresOptions: true,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.LABEL]: {
    type: COMPONENT_TYPES.LABEL,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: true,
    supportsMultiSelect: false,
  },
  
  [COMPONENT_TYPES.DATE]: {
    type: COMPONENT_TYPES.DATE,
    requiresOptions: false,
    supportsPlaceholder: false,
    isReadOnly: false,
    supportsMultiSelect: false,
  },
};

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * HELPER FUNCTIONS
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 */

/**
 * Get metadata for a component type
 */
export function getComponentMetadata(type: ComponentType): ComponentMetadata {
  return COMPONENT_METADATA[type];
}

/**
 * Check if a string is a valid component type
 */
export function isValidComponentType(type: string): type is ComponentType {
  return Object.values(COMPONENT_TYPES).includes(type as ComponentType);
}

/**
 * Validate that a FieldViewModel has required options for its type
 */
export function validateComponentRequirements(
  componentType: ComponentType,
  hasOptions: boolean
): boolean {
  const metadata = getComponentMetadata(componentType);
  if (metadata.requiresOptions && !hasOptions) {
    return false;
  }
  return true;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1925
// Timestamp:     2026-02-06T08:17:36.318Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1926
// Timestamp:     2026-02-06T08:17:36.318Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1927
// Timestamp:     2026-02-06T08:17:36.319Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1928
// Timestamp:     2026-02-06T08:17:36.319Z
// ==========================================================
// src/app/orchestrators/ComponentOrchestrator.ts

import {
  ComponentViewModel,
  CounterViewModel,
  CurrencyViewModel,
  TextViewModel,
  NumberViewModel,
  ChipGroupViewModel,
  ChipViewModel,
  RadioViewModel,
  RadioOptionViewModel,
  LabelViewModel,
  DateViewModel,
  COMPONENT_TYPES,
  ComponentType,
  getComponentMetadata,
} from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { labelFromToken } from '@ui/constants/labelResolver';
import { ViewStyle, TextStyle } from 'react-native';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * UPDATE CALLBACK - Facade from MasterOrchestrator
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ComponentOrchestrator does NOT know about FormStateOrchestrator!
 * It receives this callback from MasterOrchestrator.
 * 
 * This maintains vertical architecture (no horizontal dependencies).
 */
export type UpdateFieldCallback = (fieldId: string, value: unknown) => void;

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * COMPONENT ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Transforms FieldViewModels ‚Üí ComponentViewModels
 * 
 * Responsibilities:
 * - Resolve label tokens to display strings
 * - Compute styles (containerStyle, labelStyle, etc.)
 * - Type-safe value conversions (string ‚Üí number, etc.)
 * - Build callbacks (pre-bound to updateField)
 * - Pre-build nested structures (chips, radio options)
 * 
 * Does NOT:
 * - Access state directly (uses FieldViewModel)
 * - Know about other orchestrators (uses callbacks)
 * - Contain business logic (pure transformation)
 * - Evaluate visibility (already done by RenderOrchestrator)
 * 
 * Architecture:
 * - Private to MasterOrchestrator
 * - No horizontal dependencies
 * - Uses ComponentRegistry SSOT
 */
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,
    private readonly styles: any  // Injected from useAppStyles
  ) {}

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Main entry point: FieldViewModel ‚Üí ComponentViewModel
   * 
   * Uses exhaustive switch with COMPONENT_TYPES SSOT
   * TypeScript enforces all cases are handled
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    // Safety check (should be pre-filtered, but defensive programming)
    if (!fieldViewModel.isVisible) {
      return null;
    }

    // Validate component requirements (options, etc.)
    const metadata = getComponentMetadata(fieldViewModel.componentType as ComponentType);
    if (metadata.requiresOptions && !fieldViewModel.options) {
      console.warn(`Component ${fieldViewModel.componentType} requires options but none provided for ${fieldViewModel.fieldId}`);
      return null;
    }

    // Exhaustive switch using SSOT constants
    switch (fieldViewModel.componentType) {
      case COMPONENT_TYPES.COUNTER:
        return this.buildCounter(fieldViewModel);
      
      case COMPONENT_TYPES.CURRENCY:
        return this.buildCurrency(fieldViewModel);
      
      case COMPONENT_TYPES.TEXT:
        return this.buildText(fieldViewModel);
      
      case COMPONENT_TYPES.NUMBER:
        return this.buildNumber(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP:
        return this.buildChipGroup(fieldViewModel);
      
      case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
        return this.buildChipGroupMultiple(fieldViewModel);
      
      case COMPONENT_TYPES.RADIO:
        return this.buildRadio(fieldViewModel);
      
      case COMPONENT_TYPES.LABEL:
        return this.buildLabel(fieldViewModel);
      
      case COMPONENT_TYPES.DATE:
        return this.buildDate(fieldViewModel);
      
      default:
        // TypeScript exhaustiveness check - will error if case missing
        const exhaustiveCheck: never = fieldViewModel.componentType as never;
        console.warn(`Unknown component type: ${exhaustiveCheck}`);
        return null;
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * BUILD METHODS - One per component type
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * BUILD COUNTER
   */
  private buildCounter(vm: FieldViewModel): CounterViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.COUNTER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CURRENCY
   */
  private buildCurrency(vm: FieldViewModel): CurrencyViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CURRENCY,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken 
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onUpdate: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD TEXT
   */
  private buildText(vm: FieldViewModel): TextViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.TEXT,
      label: labelFromToken(vm.labelToken),
      value: this.ensureString(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (text: string) => {
        this.updateField(vm.fieldId, text);
      },
    };
  }

  /**
   * BUILD NUMBER
   */
  private buildNumber(vm: FieldViewModel): NumberViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.NUMBER,
      label: labelFromToken(vm.labelToken),
      value: this.ensureNumber(vm.value),
      placeholder: vm.placeholderToken
        ? labelFromToken(vm.placeholderToken)
        : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChangeText: (value: number) => {
        this.updateField(vm.fieldId, value);
      },
    };
  }

  /**
   * BUILD CHIP GROUP (single select)
   * Pre-builds all chips with styles and callbacks
   */
  private buildChipGroup(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    // Pre-build all chips
    const chips = options.map((option) => 
      this.buildChip(option, currentValue === option, () => {
        this.updateField(vm.fieldId, option);
      })
    );

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD CHIP GROUP MULTIPLE (multi select)
   * Includes toggle logic in callbacks
   */
  private buildChipGroupMultiple(vm: FieldViewModel): ChipGroupViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValues = Array.isArray(vm.value) ? vm.value : [];

    const chips = options.map((option) => {
      const isSelected = currentValues.includes(option);
      
      return this.buildChip(option, isSelected, () => {
        // Toggle logic
        const newValues = isSelected
          ? currentValues.filter((v) => v !== option)
          : [...currentValues, option];
        this.updateField(vm.fieldId, newValues);
      });
    });

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.CHIP_GROUP_MULTIPLE,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      chipContainerStyle: this.styles.chipContainer as ViewStyle,
      chips,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD INDIVIDUAL CHIP
   * All style decisions made here
   */
  private buildChip(
    label: string,
    selected: boolean,
    onPress: () => void
  ): ChipViewModel {
    // Style logic - all conditionals resolved here
    const containerStyle = [
      this.styles.chip,
      selected && this.styles.chipSelected,
    ] as ViewStyle;

    const textStyle = [
      this.styles.chipText,
      selected && this.styles.chipTextSelected,
    ] as TextStyle;

    return {
      label,
      selected,
      containerStyle,
      textStyle,
      onPress,
      accessibilityLabel: label,
      accessibilityState: { selected },
    };
  }

  /**
   * BUILD RADIO (vertical single select)
   */
  private buildRadio(vm: FieldViewModel): RadioViewModel {
    const options = (vm.options ?? []) as readonly string[];
    const currentValue = vm.value as string | undefined;

    const radioOptions: RadioOptionViewModel[] = options.map((option) => ({
      label: option,
      value: option,
      selected: currentValue === option,
      onSelect: () => {
        this.updateField(vm.fieldId, option);
      },
    }));

    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.RADIO,
      label: labelFromToken(vm.labelToken),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      radioContainerStyle: this.styles.radioContainer as ViewStyle,
      options: radioOptions,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD LABEL (read-only, derived value)
   */
  private buildLabel(vm: FieldViewModel): LabelViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.LABEL,
      label: labelFromToken(vm.labelToken),
      value: String(vm.value ?? ''),
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      valueStyle: this.styles.derivedValue as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
    };
  }

  /**
   * BUILD DATE
   */
  private buildDate(vm: FieldViewModel): DateViewModel {
    return {
      fieldId: vm.fieldId,
      componentType: COMPONENT_TYPES.DATE,
      label: labelFromToken(vm.labelToken),
      value: vm.value instanceof Date ? vm.value : undefined,
      containerStyle: this.styles.fieldContainer as ViewStyle,
      labelStyle: this.styles.label as TextStyle,
      error: vm.error,
      errorStyle: this.styles.errorText as TextStyle,
      onChange: (date: Date) => {
        this.updateField(vm.fieldId, date);
      },
    };
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * HELPER METHODS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Type-safe conversion to number
   */
  private ensureNumber(value: unknown): number {
    if (typeof value === 'number' && !isNaN(value)) {
      return value;
    }
    return 0;
  }

  /**
   * Type-safe conversion to string
   */
  private ensureString(value: unknown): string {
    if (typeof value === 'string') {
      return value;
    }
    return '';
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1929
// Timestamp:     2026-02-06T08:17:36.322Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1930
// Timestamp:     2026-02-06T08:17:36.322Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1931
// Timestamp:     2026-02-06T08:17:36.323Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1932
// Timestamp:     2026-02-06T08:17:36.323Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';  // ‚Üê NEW!
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';  // ‚Üê NEW!
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * ONLY entry point - owns all orchestrators.
 * Provides facades/callbacks to prevent horizontal dependencies.
 * 
 * Architecture Rules:
 * - All orchestrators are private (except those needed by UI)
 * - Orchestrators receive callbacks, not direct references
 * - Public API provides clean facades
 * - NO orchestrator knows about other orchestrators directly
 */
export class MasterOrchestrator {
  // Public orchestrators (accessed by UI)
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // Private orchestrators (accessed via facades)
  private readonly component: ComponentOrchestrator;  // ‚Üê NEW!
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚Üê NEW: Initialize ComponentOrchestrator with callback facade
    // It receives updateField callback - no direct FSO access!
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Component ViewModels
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way UI can access ComponentOrchestrator.
   * Maintains vertical architecture.
   * 
   * Usage:
   * const fieldVM = master.render.buildFieldViewModel(...)
   * const componentVM = master.buildComponentViewModel(fieldVM)
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * EXISTING PUBLIC API
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * UI calls this to determine visibility
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * UI calls this when user inputs data
   * 
   * Also used by ComponentOrchestrator callbacks!
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1933
// Timestamp:     2026-02-06T08:17:36.323Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1934
// Timestamp:     2026-02-06T08:17:36.324Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1935
// Timestamp:     2026-02-06T08:17:36.325Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1936
// Timestamp:     2026-02-06T08:17:36.325Z
// ==========================================================
// src/ui/components/FieldRenderer.tsx

import React from 'react';
import { View, Text, ScrollView } from 'react-native';
import {
  ComponentViewModel,
  COMPONENT_TYPES,
} from '@domain/registry/ComponentRegistry';

// Default imports (fixes your import errors)
import InputCounter from '@ui/components/fields/InputCounter';
import MoneyInput from '@ui/components/fields/MoneyInput';
import ChipButton from '@ui/components/fields/ChipButton';
import FormField from '@ui/components/fields/FormField';
import ToggleSwitch from '@ui/components/fields/ToggleSwitch';
import DateField from '@ui/components/fields/DateField';

interface FieldRendererProps {
  viewModel: ComponentViewModel;  // ‚Üê One parameter!
}

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * FIELD RENDERER - Ultra-Dumb Component
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Just maps ComponentViewModel ‚Üí React component
 * 
 * ‚úÖ 1 parameter (no max-params violation)
 * ‚úÖ No logic (no complexity violation)
 * ‚úÖ Small functions (no max-lines violation)
 * ‚úÖ ADR-04 compliant (dumb component)
 * 
 * All logic is in ComponentOrchestrator!
 */
export const FieldRenderer: React.FC<FieldRendererProps> = ({ viewModel }) => {
  return (
    <View>
      {renderComponent(viewModel)}
      
      {/* Error rendering */}
      {viewModel.error && viewModel.errorStyle && (
        <Text style={viewModel.errorStyle}>{viewModel.error}</Text>
      )}
    </View>
  );
};

/**
 * Maps ComponentViewModel type ‚Üí React component
 * Each case: 3-5 lines (no complexity!)
 */
function renderComponent(vm: ComponentViewModel): React.ReactElement | null {
  switch (vm.componentType) {
    case COMPONENT_TYPES.COUNTER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <InputCounter value={vm.value} onUpdate={vm.onUpdate} />
        </View>
      );

    case COMPONENT_TYPES.CURRENCY:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <MoneyInput
            value={vm.value}
            onUpdate={vm.onUpdate}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.TEXT:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={vm.value}
            onChangeText={vm.onChangeText}
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.NUMBER:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <FormField
            value={String(vm.value)}
            onChangeText={(text) => {
              const num = Number(text);
              if (!isNaN(num)) vm.onChangeText(num);
            }}
            keyboardType="numeric"
            placeholder={vm.placeholder}
          />
        </View>
      );

    case COMPONENT_TYPES.CHIP_GROUP:
    case COMPONENT_TYPES.CHIP_GROUP_MULTIPLE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={vm.chipContainerStyle}
          >
            {vm.chips.map((chipVM) => (
              <ChipButton key={chipVM.label} viewModel={chipVM} />
            ))}
          </ScrollView>
        </View>
      );

    case COMPONENT_TYPES.RADIO:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <View style={vm.radioContainerStyle}>
            {vm.options.map((option) => (
              <ToggleSwitch
                key={option.value}
                label={option.label}
                value={option.selected}
                onValueChange={(selected) => {
                  if (selected) option.onSelect();
                }}
              />
            ))}
          </View>
        </View>
      );

    case COMPONENT_TYPES.LABEL:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <Text style={vm.valueStyle}>{vm.value}</Text>
        </View>
      );

    case COMPONENT_TYPES.DATE:
      return (
        <View style={vm.containerStyle}>
          <Text style={vm.labelStyle}>{vm.label}</Text>
          <DateField value={vm.value} onChange={vm.onChange} />
        </View>
      );

    default:
      return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1937
// Timestamp:     2026-02-06T08:17:36.327Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1938
// Timestamp:     2026-02-06T08:17:36.329Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1939
// Timestamp:     2026-02-06T08:17:36.331Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1940
// Timestamp:     2026-02-06T08:17:36.331Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

import React, { useMemo } from 'react';
import { View, ScrollView } from 'react-native';
import { FieldRenderer } from '@ui/components/FieldRenderer';
import { useFormContext } from '@app/context/FormContext';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';

interface WizardPageProps {
  config: {
    pageId: string;
    titleToken: string;
    fields: Array<{
      fieldId: string;
      type: string;
      labelToken: string;
      // ... other config
    }>;
  };
}

/**
 * WIZARD PAGE
 * 
 * Orchestrates the two-step transformation:
 * 1. FieldConfig ‚Üí FieldViewModel (via RenderOrchestrator)
 * 2. FieldViewModel ‚Üí ComponentViewModel (via ComponentOrchestrator)
 * 3. ComponentViewModel ‚Üí React (via FieldRenderer)
 */
export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();  // MasterOrchestrator

  // Step 1: Build FieldViewModels (business-level)
  // Includes: visibility evaluation, value lookup, error checking
  const fieldViewModels = useMemo(() => {
    return config.fields
      .map((fieldConfig) => {
        // Context might include memberId, etc.
        const context = {}; // Build context as needed
        return orchestrator.render.buildFieldViewModel(
          fieldConfig.fieldId,
          context
        );
      })
      .filter((vm) => vm !== null && vm.isVisible);
  }, [config.fields, orchestrator]);

  // Step 2: Transform to ComponentViewModels (presentation-level)
  // Includes: style computation, label resolution, callback binding
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => 
        orchestrator.buildComponentViewModel(fieldVM)  // ‚Üê Via Master API!
      )
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      <View>
        {componentViewModels.map((vm) => (
          <FieldRenderer key={vm.fieldId} viewModel={vm} />
        ))}
      </View>
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1941
// Timestamp:     2026-02-06T08:17:36.331Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1942
// Timestamp:     2026-02-06T08:17:36.331Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1943
// Timestamp:     2026-02-06T08:17:36.331Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1944
// Timestamp:     2026-02-06T08:17:36.331Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, geen FSO!
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1945
// Timestamp:     2026-02-06T08:17:36.333Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1946
// Timestamp:     2026-02-06T08:17:36.335Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1947
// Timestamp:     2026-02-06T08:17:36.338Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1948
// Timestamp:     2026-02-06T08:17:36.338Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1949
// Timestamp:     2026-02-06T08:17:36.340Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1950
// Timestamp:     2026-02-06T08:17:36.340Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1951
// Timestamp:     2026-02-06T08:17:36.340Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1952
// Timestamp:     2026-02-06T08:17:36.340Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1953
// Timestamp:     2026-02-06T08:17:36.340Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1954
// Timestamp:     2026-02-06T08:17:36.340Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1955
// Timestamp:     2026-02-06T08:17:36.341Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1956
// Timestamp:     2026-02-06T08:17:36.343Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1957
// Timestamp:     2026-02-06T08:17:36.345Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1958
// Timestamp:     2026-02-06T08:17:36.346Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1959
// Timestamp:     2026-02-06T08:17:36.347Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1960
// Timestamp:     2026-02-06T08:17:36.347Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1961
// Timestamp:     2026-02-06T08:17:36.347Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1962
// Timestamp:     2026-02-06T08:17:36.349Z
// ==========================================================
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1963
// Timestamp:     2026-02-06T08:17:36.350Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, geen FSO!
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1964
// Timestamp:     2026-02-06T08:17:36.350Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1965
// Timestamp:     2026-02-06T08:17:36.350Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1966
// Timestamp:     2026-02-06T08:17:36.350Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1967
// Timestamp:     2026-02-06T08:17:36.350Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1968
// Timestamp:     2026-02-06T08:17:36.350Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1969
// Timestamp:     2026-02-06T08:17:36.351Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1970
// Timestamp:     2026-02-06T08:17:36.354Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1971
// Timestamp:     2026-02-06T08:17:36.354Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1972
// Timestamp:     2026-02-06T08:17:36.354Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1973
// Timestamp:     2026-02-06T08:17:36.354Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, geen FSO!
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1974
// Timestamp:     2026-02-06T08:17:36.354Z
// ==========================================================
constructor(
  private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback, geen FSO!
  private readonly styles: any
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1975
// Timestamp:     2026-02-06T08:17:36.354Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1976
// Timestamp:     2026-02-06T08:17:36.354Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1977
// Timestamp:     2026-02-06T08:17:36.355Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1978
// Timestamp:     2026-02-06T08:17:36.355Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly timeProvider: TimeProvider
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1979
// Timestamp:     2026-02-06T08:17:36.355Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1980
// Timestamp:     2026-02-06T08:17:36.355Z
// ==========================================================
// Uit je bestaande codebase:
constructor(
  private readonly fso: FormStateOrchestrator
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1981
// Timestamp:     2026-02-06T08:17:36.357Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1982
// Timestamp:     2026-02-06T08:17:36.359Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1983
// Timestamp:     2026-02-06T08:17:36.360Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1984
// Timestamp:     2026-02-06T08:17:36.361Z
// ==========================================================
export class MasterOrchestrator {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FACADES (read-only, exposed to UI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PRIVATE (accessed via Master API only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  private readonly component: ComponentOrchestrator;  // ‚Üê Private!
  
  constructor(getState, dispatch, styles, timeProvider) {
    // 1. Instantiate all (Master owns all)
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    // 2. ComponentOrchestrator gets CALLBACK, not FSO!
    this.component = new ComponentOrchestrator(
      (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Facade!
      styles
    );
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SINGLE MUTATION POINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public updateField(fieldId: string, value: unknown): void {
    // ALL state changes flow through here
    const result = validateAtBoundary(fieldId, value);
    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }
    this.fso.updateField(fieldId, result.data);
    // ... financial summary update, etc.
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ COMPONENT API (only via Master) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  public buildComponentViewModel(fieldViewModel: FieldViewModel): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }
  
  // ... other Master methods
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1985
// Timestamp:     2026-02-06T08:17:36.362Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1986
// Timestamp:     2026-02-06T08:17:36.362Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1987
// Timestamp:     2026-02-06T08:17:36.366Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1988
// Timestamp:     2026-02-06T08:17:36.367Z
// ==========================================================
// ‚ùå FOUT - Horizontaal contact
export class ComponentOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,  // ‚Üê Direct FSO!
    private readonly render: RenderOrchestrator   // ‚Üê Horizontal!
  ) {}
}

// ‚ùå FOUT - Orchestrator roept andere orchestrator aan
export class ResearchOrchestrator {
  process() {
    if (this.visibility.evaluate('someRule')) {  // ‚Üê Horizontal!
      // ...
    }
  }
}

// ‚ùå FOUT - Master is alleen wrapper
export class MasterOrchestrator {
  // Geen eigendom, alleen delegatie
  getFieldValue(id: string) {
    return someExternalFSO.getValue(id);  // ‚Üê Master bezit niets!
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1989
// Timestamp:     2026-02-06T08:17:36.367Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1990
// Timestamp:     2026-02-06T08:17:36.367Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1991
// Timestamp:     2026-02-06T08:17:36.367Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1992
// Timestamp:     2026-02-06T08:17:36.367Z
// ==========================================================
// ‚úÖ GOED - Callback facade
export class ComponentOrchestrator {
  constructor(
    private readonly updateField: UpdateFieldCallback,  // ‚Üê Callback!
    private readonly styles: any
  ) {}
  
  onClick() {
    this.updateField('fieldId', value);  // ‚Üê Via Master!
  }
}

// ‚úÖ GOED - Verticale dependency (toegestaan)
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,      // ‚Üê Data provider
    private readonly visibility: VisibilityOrchestrator  // ‚Üê Vertical
  ) {}
}

// ‚úÖ GOED - Master bezit alles
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  private readonly component: ComponentOrchestrator;
  
  constructor() {
    this.fso = new FormStateOrchestrator(...);  // ‚Üê Master bezit!
    this.component = new ComponentOrchestrator(
      (id, val) => this.updateField(id, val),  // ‚Üê Callback naar self!
      styles
    );
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1993
// Timestamp:     2026-02-06T08:17:36.368Z
// ==========================================================
/**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1994
// Timestamp:     2026-02-06T08:17:36.369Z
// ==========================================================
options (2).ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1995
// Timestamp:     2026-02-06T08:17:36.369Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1996
// Timestamp:     2026-02-06T08:17:36.369Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1997
// Timestamp:     2026-02-06T08:17:36.369Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1998
// Timestamp:     2026-02-06T08:17:36.371Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       1999
// Timestamp:     2026-02-06T08:17:36.371Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2000
// Timestamp:     2026-02-06T08:17:36.371Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2001
// Timestamp:     2026-02-06T08:17:36.371Z
// ==========================================================
// RenderOrchestrator.buildFieldViewModel() returns:
return {
  fieldId: 'aantalMensen',
  componentType: 'counter',  // ‚Üê Already from FieldRegistry
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2002
// Timestamp:     2026-02-06T08:17:36.372Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2003
// Timestamp:     2026-02-06T08:17:36.372Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2004
// Timestamp:     2026-02-06T08:17:36.373Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2005
// Timestamp:     2026-02-06T08:17:36.374Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2006
// Timestamp:     2026-02-06T08:17:36.375Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2007
// Timestamp:     2026-02-06T08:17:36.375Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2008
// Timestamp:     2026-02-06T08:17:36.375Z
// ==========================================================
/**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2009
// Timestamp:     2026-02-06T08:17:36.375Z
// ==========================================================
options (2).ts


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2010
// Timestamp:     2026-02-06T08:17:36.375Z
// ==========================================================
/**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2011
// Timestamp:     2026-02-06T08:17:36.375Z
// ==========================================================
/**
   * UX & UI Regie
   */
  public getComponentType(fieldId: string, baseType: string): string {
    return baseType; 
  }

  public getOptions(fieldId: string): readonly string[] {
    const optionsMap: Record<string, readonly string[]> = {
      autoCount: ['Geen', 'Een', 'Twee'],
      woningType: ['Huur', 'Koop', 'Inwonend'],
    };
    return optionsMap[fieldId] ?? [];
  }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2012
// Timestamp:     2026-02-06T08:17:36.376Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2013
// Timestamp:     2026-02-06T08:17:36.376Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2014
// Timestamp:     2026-02-06T08:17:36.376Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2015
// Timestamp:     2026-02-06T08:17:36.376Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2016
// Timestamp:     2026-02-06T08:17:36.377Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2017
// Timestamp:     2026-02-06T08:17:36.377Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2018
// Timestamp:     2026-02-06T08:17:36.378Z
// ==========================================================
// RenderOrchestrator.buildFieldViewModel() returns:
return {
  fieldId: 'aantalMensen',
  componentType: 'counter',  // ‚Üê Already from FieldRegistry
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2019
// Timestamp:     2026-02-06T08:17:36.378Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2020
// Timestamp:     2026-02-06T08:17:36.379Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2021
// Timestamp:     2026-02-06T08:17:36.379Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2022
// Timestamp:     2026-02-06T08:17:36.379Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2023
// Timestamp:     2026-02-06T08:17:36.379Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2024
// Timestamp:     2026-02-06T08:17:36.379Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2025
// Timestamp:     2026-02-06T08:17:36.379Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2026
// Timestamp:     2026-02-06T08:17:36.379Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2027
// Timestamp:     2026-02-06T08:17:36.381Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2028
// Timestamp:     2026-02-06T08:17:36.382Z
// ==========================================================
// ‚ùå ANTI-PATTERN - Hardcoded duplicatie!
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;  // ‚Üê Nutteloos! Returnt gewoon de input
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],  // ‚Üê Duplicatie van options.ts!
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2029
// Timestamp:     2026-02-06T08:17:36.382Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2030
// Timestamp:     2026-02-06T08:17:36.382Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2031
// Timestamp:     2026-02-06T08:17:36.383Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2032
// Timestamp:     2026-02-06T08:17:36.383Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Component ViewModels
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Visibility & Updates
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  // ‚ùå VERWIJDERD: getComponentType (nutteloos)
  // ‚ùå VERWIJDERD: getOptions (duplicatie)

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: CSV Import
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Value Getters
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PUBLIC API: Validation
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2033
// Timestamp:     2026-02-06T08:17:36.386Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2034
// Timestamp:     2026-02-06T08:17:36.387Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2035
// Timestamp:     2026-02-06T08:17:36.387Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2036
// Timestamp:     2026-02-06T08:17:36.388Z
// ==========================================================
// In RenderOrchestrator.buildFieldViewModel()
import { FIELD_REGISTRY } from '@domain/registry/FieldRegistry';

const fieldDef = FIELD_REGISTRY[fieldId];
const componentType = fieldDef.componentType;  // ‚Üê SSOT!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2037
// Timestamp:     2026-02-06T08:17:36.390Z
// ==========================================================
// RenderOrchestrator.buildFieldViewModel() returns:
return {
  fieldId: 'aantalMensen',
  componentType: 'counter',  // ‚Üê Already from FieldRegistry
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2038
// Timestamp:     2026-02-06T08:17:36.390Z
// ==========================================================
// RenderOrchestrator.buildFieldViewModel() returns:
return {
  fieldId: 'aantalMensen',
  componentType: 'counter',  // ‚Üê Already from FieldRegistry
  // ...
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2039
// Timestamp:     2026-02-06T08:17:36.392Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2040
// Timestamp:     2026-02-06T08:17:36.392Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2041
// Timestamp:     2026-02-06T08:17:36.393Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2042
// Timestamp:     2026-02-06T08:17:36.393Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2043
// Timestamp:     2026-02-06T08:17:36.393Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2044
// Timestamp:     2026-02-06T08:17:36.394Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2045
// Timestamp:     2026-02-06T08:17:36.395Z
// ==========================================================
// src/domain/registry/FieldRegistry.ts
import { HOUSEHOLD_OPTIONS, FINANCE_OPTIONS } from '@domain/constants/options';

export const FIELD_REGISTRY = {
  autoCount: {
    componentType: COMPONENT_TYPES.RADIO,
    labelToken: 'LABEL_CAR_COUNT',
    optionsKey: 'autoCount',  // ‚Üê Key naar options
  },
  
  gender: {
    componentType: COMPONENT_TYPES.CHIP_GROUP,
    labelToken: 'LABEL_GENDER',
    optionsKey: 'gender',  // ‚Üê Key naar options
  },
};

// Helper functie
export function getOptionsForField(fieldId: string): readonly string[] | null {
  const fieldDef = FIELD_REGISTRY[fieldId];
  if (!fieldDef?.optionsKey) return null;
  
  // Lookup in options based on key
  return (
    HOUSEHOLD_OPTIONS[fieldDef.optionsKey as keyof typeof HOUSEHOLD_OPTIONS] ??
    FINANCE_OPTIONS[fieldDef.optionsKey as keyof typeof FINANCE_OPTIONS] ??
    null
  );
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2046
// Timestamp:     2026-02-06T08:17:36.395Z
// ==========================================================
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SSOT REGISTRIES                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  FieldRegistry.ts        options.ts                     ‚îÇ
‚îÇ  ‚îî‚îÄ componentType        ‚îî‚îÄ HOUSEHOLD_OPTIONS           ‚îÇ
‚îÇ  ‚îî‚îÄ optionsKey              ‚îî‚îÄ autoCount: [...]         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             RenderOrchestrator                          ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildFieldViewModel(fieldId) {                        ‚îÇ
‚îÇ    const def = FIELD_REGISTRY[fieldId];               ‚îÇ
‚îÇ    const options = getOptionsForField(fieldId);       ‚îÇ
‚îÇ    return {                                            ‚îÇ
‚îÇ      componentType: def.componentType,  // ‚Üê SSOT     ‚îÇ
‚îÇ      options: options,                  // ‚Üê SSOT     ‚îÇ
‚îÇ    };                                                  ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ComponentOrchestrator                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  buildComponentViewModel(fieldViewModel) {             ‚îÇ
‚îÇ    // Krijgt componentType & options via ViewModel    ‚îÇ
‚îÇ    // Geen extra lookup nodig!                        ‚îÇ
‚îÇ  }                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2047
// Timestamp:     2026-02-06T08:17:36.399Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2048
// Timestamp:     2026-02-06T08:17:36.399Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2049
// Timestamp:     2026-02-06T08:17:36.399Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2050
// Timestamp:     2026-02-06T08:17:36.399Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';

export class RenderOrchestrator {
  // ... existing code

  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    // Check visibility
    const isVisible = fieldDef.visibilityRuleName
      ? this.visibility.evaluate(fieldDef.visibilityRuleName, context)
      : true;

    if (!isVisible) return null;

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options from registry (if applicable)
    const options = getOptionsForField(fieldId);  // ‚Üê SSOT!

    return {
      fieldId,
      componentType: fieldDef.componentType,  // ‚Üê SSOT!
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      isVisible,
      options,  // ‚Üê From options.ts via FieldRegistry!
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2051
// Timestamp:     2026-02-06T08:17:36.401Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Single Entry Point - Owns ALL orchestrators
 * 
 * ARCHITECTURE PRINCIPLES:
 * ‚úÖ All orchestrators instantiated here (Master owns everything)
 * ‚úÖ No horizontal dependencies (orchestrators don't know each other)
 * ‚úÖ All state mutations flow through updateField()
 * ‚úÖ Orchestrators receive callbacks, not direct references
 * ‚úÖ Public facades expose read-only orchestrators
 * ‚úÖ Private orchestrators accessed via Master API only
 * 
 * RESPONSIBILITIES:
 * - Orchestrator lifecycle management (instantiation, ownership)
 * - State mutation coordination (single entry point)
 * - Facade provision (controlled access to orchestrators)
 * - Integration coordination (CSV import, financial updates)
 * 
 * DOES NOT:
 * - Duplicate registry data (componentType, options)
 * - Implement business logic (delegated to domain)
 * - Directly mutate state (via FormStateOrchestrator)
 */
export class MasterOrchestrator {
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC FACADES - Read-only orchestrators for UI
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PRIVATE ORCHESTRATORS - Accessed via Master API only
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  private readonly component: ComponentOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * CONSTRUCTOR - Instantiates and wires all orchestrators
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles hook
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators with minimal dependencies
    this.fso = new FormStateOrchestrator(getState, dispatch);
    
    // Visibility depends on FSO (for value lookup) and TimeProvider
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // Render depends on FSO and Visibility (vertical dependency)
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // Research depends only on FSO
    this.research = new ResearchOrchestrator(this.fso);
    
    // Component depends on NO orchestrators - only callback and styles!
    // This prevents horizontal dependencies
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator.
   * Maintains vertical architecture (no direct access from UI).
   * 
   * @param fieldViewModel - Business-level ViewModel from RenderOrchestrator
   * @returns ComponentViewModel ready for rendering, or null if invalid
   * 
   * @example
   * const fieldVM = master.render.buildFieldViewModel('aantalMensen');
   * const componentVM = master.buildComponentViewModel(fieldVM);
   * // Pass componentVM to FieldRenderer
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VISIBILITY
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Evaluate visibility rule
   * 
   * Used by UI to determine if field/section should be shown.
   * Delegates to VisibilityOrchestrator.
   * 
   * @param ruleName - Name of visibility rule (from fieldVisibility.ts)
   * @param context - Optional context (memberId, targetWoningType, etc.)
   * @returns true if field should be visible
   * 
   * @example
   * if (master.isVisible('isAdultInputVisible')) {
   *   // Show aantalVolwassen field
   * }
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: STATE MUTATIONS (Single Entry Point)
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Update field value
   * 
   * **CRITICAL: This is the ONLY method that mutates state!**
   * 
   * Flow:
   * 1. Validate at boundary (Zod schema)
   * 2. Update field via FormStateOrchestrator
   * 3. Recompute financial summary (if applicable)
   * 4. Update ViewModel
   * 
   * Used by:
   * - UI components directly
   * - ComponentOrchestrator callbacks (pre-bound in constructor)
   * - Any orchestrator that needs to mutate state
   * 
   * @param fieldId - Field identifier
   * @param value - New value (will be validated)
   */
  public updateField(fieldId: string, value: unknown): void {
    // Boundary validation (Zod)
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    // Update state via FSO
    this.fso.updateField(fieldId, result.data);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: CSV IMPORT
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Handle CSV import (bank transactions)
   * 
   * Flow:
   * 1. Process CSV via ImportOrchestrator
   * 2. Update transactions in state
   * 3. Recompute financial summary
   * 4. Log success or discrepancies
   * 
   * @param csvText - Raw CSV content
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    // Process CSV through ImportOrchestrator
    // Note: ImportOrchestrator uses ResearchOrchestrator instance (DI)
    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    // Update transactions
    this.fso.updateField('transactions', result.transactions);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    // Log results
    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALUE GETTERS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Get current field value
   * 
   * Delegates to FormStateOrchestrator.
   * 
   * @param fieldId - Field identifier
   * @returns Current value or undefined
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  /**
   * Get formatted date value
   * 
   * Converts Date or date string to formatted display string.
   * 
   * @param fieldId - Field identifier
   * @param format - Display format
   * @returns Formatted date string or empty string
   */
  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALIDATION
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Validate field value
   * 
   * Validates against Zod schema at boundary.
   * 
   * @param fieldId - Field identifier
   * @param value - Value to validate
   * @returns Error message or null if valid
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2052
// Timestamp:     2026-02-06T08:17:36.401Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Single Entry Point - Owns ALL orchestrators
 * 
 * ARCHITECTURE PRINCIPLES:
 * ‚úÖ All orchestrators instantiated here (Master owns everything)
 * ‚úÖ No horizontal dependencies (orchestrators don't know each other)
 * ‚úÖ All state mutations flow through updateField()
 * ‚úÖ Orchestrators receive callbacks, not direct references
 * ‚úÖ Public facades expose read-only orchestrators
 * ‚úÖ Private orchestrators accessed via Master API only
 * 
 * RESPONSIBILITIES:
 * - Orchestrator lifecycle management (instantiation, ownership)
 * - State mutation coordination (single entry point)
 * - Facade provision (controlled access to orchestrators)
 * - Integration coordination (CSV import, financial updates)
 * 
 * DOES NOT:
 * - Duplicate registry data (componentType, options)
 * - Implement business logic (delegated to domain)
 * - Directly mutate state (via FormStateOrchestrator)
 */
export class MasterOrchestrator {
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC FACADES - Read-only orchestrators for UI
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PRIVATE ORCHESTRATORS - Accessed via Master API only
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  private readonly component: ComponentOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * CONSTRUCTOR - Instantiates and wires all orchestrators
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles hook
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators with minimal dependencies
    this.fso = new FormStateOrchestrator(getState, dispatch);
    
    // Visibility depends on FSO (for value lookup) and TimeProvider
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // Render depends on FSO and Visibility (vertical dependency)
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // Research depends only on FSO
    this.research = new ResearchOrchestrator(this.fso);
    
    // Component depends on NO orchestrators - only callback and styles!
    // This prevents horizontal dependencies
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator.
   * Maintains vertical architecture (no direct access from UI).
   * 
   * @param fieldViewModel - Business-level ViewModel from RenderOrchestrator
   * @returns ComponentViewModel ready for rendering, or null if invalid
   * 
   * @example
   * const fieldVM = master.render.buildFieldViewModel('aantalMensen');
   * const componentVM = master.buildComponentViewModel(fieldVM);
   * // Pass componentVM to FieldRenderer
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VISIBILITY
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Evaluate visibility rule
   * 
   * Used by UI to determine if field/section should be shown.
   * Delegates to VisibilityOrchestrator.
   * 
   * @param ruleName - Name of visibility rule (from fieldVisibility.ts)
   * @param context - Optional context (memberId, targetWoningType, etc.)
   * @returns true if field should be visible
   * 
   * @example
   * if (master.isVisible('isAdultInputVisible')) {
   *   // Show aantalVolwassen field
   * }
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: STATE MUTATIONS (Single Entry Point)
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Update field value
   * 
   * **CRITICAL: This is the ONLY method that mutates state!**
   * 
   * Flow:
   * 1. Validate at boundary (Zod schema)
   * 2. Update field via FormStateOrchestrator
   * 3. Recompute financial summary (if applicable)
   * 4. Update ViewModel
   * 
   * Used by:
   * - UI components directly
   * - ComponentOrchestrator callbacks (pre-bound in constructor)
   * - Any orchestrator that needs to mutate state
   * 
   * @param fieldId - Field identifier
   * @param value - New value (will be validated)
   */
  public updateField(fieldId: string, value: unknown): void {
    // Boundary validation (Zod)
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    // Update state via FSO
    this.fso.updateField(fieldId, result.data);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: CSV IMPORT
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Handle CSV import (bank transactions)
   * 
   * Flow:
   * 1. Process CSV via ImportOrchestrator
   * 2. Update transactions in state
   * 3. Recompute financial summary
   * 4. Log success or discrepancies
   * 
   * @param csvText - Raw CSV content
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    // Process CSV through ImportOrchestrator
    // Note: ImportOrchestrator uses ResearchOrchestrator instance (DI)
    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    // Update transactions
    this.fso.updateField('transactions', result.transactions);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    // Log results
    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALUE GETTERS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Get current field value
   * 
   * Delegates to FormStateOrchestrator.
   * 
   * @param fieldId - Field identifier
   * @returns Current value or undefined
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  /**
   * Get formatted date value
   * 
   * Converts Date or date string to formatted display string.
   * 
   * @param fieldId - Field identifier
   * @param format - Display format
   * @returns Formatted date string or empty string
   */
  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALIDATION
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Validate field value
   * 
   * Validates against Zod schema at boundary.
   * 
   * @param fieldId - Field identifier
   * @param value - Value to validate
   * @returns Error message or null if valid
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2053
// Timestamp:     2026-02-06T08:17:36.402Z
// ==========================================================
// ‚ùå FOUT - Deze stonden erin, nu weg:
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2054
// Timestamp:     2026-02-06T08:17:36.402Z
// ==========================================================
/**
 * DEPENDENCY GRAPH (Geen horizontale pijlen!)
 * 
 *     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *     ‚îÇ     MASTER ORCHESTRATOR              ‚îÇ
 *     ‚îÇ     (owns & instantiates all)        ‚îÇ
 *     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *            ‚Üì          ‚Üì          ‚Üì          ‚Üì
 *      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *      ‚îÇ   FSO   ‚îÇ ‚îÇ Render  ‚îÇ ‚îÇVisibility‚îÇ ‚îÇComponent‚îÇ
 *      ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ (private)‚îÇ
 *      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                       ‚Üì           ‚Üë
 *                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                     (Vertical OK!)
 * 
 * ‚úÖ NO horizontal arrows
 * ‚úÖ ALL via Master (or vertical: Render‚ÜíVisibility)
 * ‚úÖ Component gets callback, not FSO
 */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2055
// Timestamp:     2026-02-06T08:17:36.403Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2056
// Timestamp:     2026-02-06T08:17:36.404Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2057
// Timestamp:     2026-02-06T08:17:36.405Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Single Entry Point - Owns ALL orchestrators
 * 
 * ARCHITECTURE PRINCIPLES:
 * ‚úÖ All orchestrators instantiated here (Master owns everything)
 * ‚úÖ No horizontal dependencies (orchestrators don't know each other)
 * ‚úÖ All state mutations flow through updateField()
 * ‚úÖ Orchestrators receive callbacks, not direct references
 * ‚úÖ Public facades expose read-only orchestrators
 * ‚úÖ Private orchestrators accessed via Master API only
 * 
 * RESPONSIBILITIES:
 * - Orchestrator lifecycle management (instantiation, ownership)
 * - State mutation coordination (single entry point)
 * - Facade provision (controlled access to orchestrators)
 * - Integration coordination (CSV import, financial updates)
 * 
 * DOES NOT:
 * - Duplicate registry data (componentType, options)
 * - Implement business logic (delegated to domain)
 * - Directly mutate state (via FormStateOrchestrator)
 */
export class MasterOrchestrator {
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC FACADES - Read-only orchestrators for UI
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PRIVATE ORCHESTRATORS - Accessed via Master API only
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  private readonly component: ComponentOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * CONSTRUCTOR - Instantiates and wires all orchestrators
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles hook
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators with minimal dependencies
    this.fso = new FormStateOrchestrator(getState, dispatch);
    
    // Visibility depends on FSO (for value lookup) and TimeProvider
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // Render depends on FSO and Visibility (vertical dependency)
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // Research depends only on FSO
    this.research = new ResearchOrchestrator(this.fso);
    
    // Component depends on NO orchestrators - only callback and styles!
    // This prevents horizontal dependencies
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator.
   * Maintains vertical architecture (no direct access from UI).
   * 
   * @param fieldViewModel - Business-level ViewModel from RenderOrchestrator
   * @returns ComponentViewModel ready for rendering, or null if invalid
   * 
   * @example
   * const fieldVM = master.render.buildFieldViewModel('aantalMensen');
   * const componentVM = master.buildComponentViewModel(fieldVM);
   * // Pass componentVM to FieldRenderer
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VISIBILITY
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Evaluate visibility rule
   * 
   * Used by UI to determine if field/section should be shown.
   * Delegates to VisibilityOrchestrator.
   * 
   * @param ruleName - Name of visibility rule (from fieldVisibility.ts)
   * @param context - Optional context (memberId, targetWoningType, etc.)
   * @returns true if field should be visible
   * 
   * @example
   * if (master.isVisible('isAdultInputVisible')) {
   *   // Show aantalVolwassen field
   * }
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: STATE MUTATIONS (Single Entry Point)
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Update field value
   * 
   * **CRITICAL: This is the ONLY method that mutates state!**
   * 
   * Flow:
   * 1. Validate at boundary (Zod schema)
   * 2. Update field via FormStateOrchestrator
   * 3. Recompute financial summary (if applicable)
   * 4. Update ViewModel
   * 
   * Used by:
   * - UI components directly
   * - ComponentOrchestrator callbacks (pre-bound in constructor)
   * - Any orchestrator that needs to mutate state
   * 
   * @param fieldId - Field identifier
   * @param value - New value (will be validated)
   */
  public updateField(fieldId: string, value: unknown): void {
    // Boundary validation (Zod)
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    // Update state via FSO
    this.fso.updateField(fieldId, result.data);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: CSV IMPORT
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Handle CSV import (bank transactions)
   * 
   * Flow:
   * 1. Process CSV via ImportOrchestrator
   * 2. Update transactions in state
   * 3. Recompute financial summary
   * 4. Log success or discrepancies
   * 
   * @param csvText - Raw CSV content
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    // Process CSV through ImportOrchestrator
    // Note: ImportOrchestrator uses ResearchOrchestrator instance (DI)
    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    // Update transactions
    this.fso.updateField('transactions', result.transactions);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    // Log results
    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALUE GETTERS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Get current field value
   * 
   * Delegates to FormStateOrchestrator.
   * 
   * @param fieldId - Field identifier
   * @returns Current value or undefined
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  /**
   * Get formatted date value
   * 
   * Converts Date or date string to formatted display string.
   * 
   * @param fieldId - Field identifier
   * @param format - Display format
   * @returns Formatted date string or empty string
   */
  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALIDATION
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Validate field value
   * 
   * Validates against Zod schema at boundary.
   * 
   * @param fieldId - Field identifier
   * @param value - Value to validate
   * @returns Error message or null if valid
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2058
// Timestamp:     2026-02-06T08:17:36.407Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { FieldViewModel } from './RenderOrchestrator';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * PHOENIX MASTER ORCHESTRATOR
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * 
 * Single Entry Point - Owns ALL orchestrators
 * 
 * ARCHITECTURE PRINCIPLES:
 * ‚úÖ All orchestrators instantiated here (Master owns everything)
 * ‚úÖ No horizontal dependencies (orchestrators don't know each other)
 * ‚úÖ All state mutations flow through updateField()
 * ‚úÖ Orchestrators receive callbacks, not direct references
 * ‚úÖ Public facades expose read-only orchestrators
 * ‚úÖ Private orchestrators accessed via Master API only
 * 
 * RESPONSIBILITIES:
 * - Orchestrator lifecycle management (instantiation, ownership)
 * - State mutation coordination (single entry point)
 * - Facade provision (controlled access to orchestrators)
 * - Integration coordination (CSV import, financial updates)
 * 
 * DOES NOT:
 * - Duplicate registry data (componentType, options)
 * - Implement business logic (delegated to domain)
 * - Directly mutate state (via FormStateOrchestrator)
 */
export class MasterOrchestrator {
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC FACADES - Read-only orchestrators for UI
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PRIVATE ORCHESTRATORS - Accessed via Master API only
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  private readonly component: ComponentOrchestrator;
  
  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * CONSTRUCTOR - Instantiates and wires all orchestrators
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */
  
  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,  // From useAppStyles hook
    timeProvider: TimeProvider
  ) {
    // Initialize core orchestrators with minimal dependencies
    this.fso = new FormStateOrchestrator(getState, dispatch);
    
    // Visibility depends on FSO (for value lookup) and TimeProvider
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // Render depends on FSO and Visibility (vertical dependency)
    this.render = new RenderOrchestrator(this.fso, this.visibility);
    
    // Research depends only on FSO
    this.research = new ResearchOrchestrator(this.fso);
    
    // Component depends on NO orchestrators - only callback and styles!
    // This prevents horizontal dependencies
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * This is the ONLY way to access ComponentOrchestrator.
   * Maintains vertical architecture (no direct access from UI).
   * 
   * @param fieldViewModel - Business-level ViewModel from RenderOrchestrator
   * @returns ComponentViewModel ready for rendering, or null if invalid
   * 
   * @example
   * const fieldVM = master.render.buildFieldViewModel('aantalMensen');
   * const componentVM = master.buildComponentViewModel(fieldVM);
   * // Pass componentVM to FieldRenderer
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VISIBILITY
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Evaluate visibility rule
   * 
   * Used by UI to determine if field/section should be shown.
   * Delegates to VisibilityOrchestrator.
   * 
   * @param ruleName - Name of visibility rule (from fieldVisibility.ts)
   * @param context - Optional context (memberId, targetWoningType, etc.)
   * @returns true if field should be visible
   * 
   * @example
   * if (master.isVisible('isAdultInputVisible')) {
   *   // Show aantalVolwassen field
   * }
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: STATE MUTATIONS (Single Entry Point)
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Update field value
   * 
   * **CRITICAL: This is the ONLY method that mutates state!**
   * 
   * Flow:
   * 1. Validate at boundary (Zod schema)
   * 2. Update field via FormStateOrchestrator
   * 3. Recompute financial summary (if applicable)
   * 4. Update ViewModel
   * 
   * Used by:
   * - UI components directly
   * - ComponentOrchestrator callbacks (pre-bound in constructor)
   * - Any orchestrator that needs to mutate state
   * 
   * @param fieldId - Field identifier
   * @param value - New value (will be validated)
   */
  public updateField(fieldId: string, value: unknown): void {
    // Boundary validation (Zod)
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    // Update state via FSO
    this.fso.updateField(fieldId, result.data);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: CSV IMPORT
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Handle CSV import (bank transactions)
   * 
   * Flow:
   * 1. Process CSV via ImportOrchestrator
   * 2. Update transactions in state
   * 3. Recompute financial summary
   * 4. Log success or discrepancies
   * 
   * @param csvText - Raw CSV content
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    // Process CSV through ImportOrchestrator
    // Note: ImportOrchestrator uses ResearchOrchestrator instance (DI)
    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    // Update transactions
    this.fso.updateField('transactions', result.transactions);

    // Recompute financial summary
    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    // Update ViewModel
    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    // Log results
    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALUE GETTERS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Get current field value
   * 
   * Delegates to FormStateOrchestrator.
   * 
   * @param fieldId - Field identifier
   * @returns Current value or undefined
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  /**
   * Get formatted date value
   * 
   * Converts Date or date string to formatted display string.
   * 
   * @param fieldId - Field identifier
   * @param format - Display format
   * @returns Formatted date string or empty string
   */
  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: VALIDATION
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Validate field value
   * 
   * Validates against Zod schema at boundary.
   * 
   * @param fieldId - Field identifier
   * @param value - Value to validate
   * @returns Error message or null if valid
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2059
// Timestamp:     2026-02-06T08:17:36.408Z
// ==========================================================
// ‚ùå FOUT - Deze stonden erin, nu weg:
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2060
// Timestamp:     2026-02-06T08:17:36.409Z
// ==========================================================
/**
 * DEPENDENCY GRAPH (Geen horizontale pijlen!)
 * 
 *     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *     ‚îÇ     MASTER ORCHESTRATOR              ‚îÇ
 *     ‚îÇ     (owns & instantiates all)        ‚îÇ
 *     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *            ‚Üì          ‚Üì          ‚Üì          ‚Üì
 *      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *      ‚îÇ   FSO   ‚îÇ ‚îÇ Render  ‚îÇ ‚îÇVisibility‚îÇ ‚îÇComponent‚îÇ
 *      ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ (private)‚îÇ
 *      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                       ‚Üì           ‚Üë
 *                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                     (Vertical OK!)
 * 
 * ‚úÖ NO horizontal arrows
 * ‚úÖ ALL via Master (or vertical: Render‚ÜíVisibility)
 * ‚úÖ Component gets callback, not FSO
 */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2061
// Timestamp:     2026-02-06T08:17:36.409Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2062
// Timestamp:     2026-02-06T08:17:36.409Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2063
// Timestamp:     2026-02-06T08:17:36.409Z
// ==========================================================
// ‚ùå FOUT - Deze stonden erin, nu weg:
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2064
// Timestamp:     2026-02-06T08:17:36.409Z
// ==========================================================
// ‚ùå FOUT - Deze stonden erin, nu weg:
public getComponentType(fieldId: string, baseType: string): string {
  return baseType;
}

public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2065
// Timestamp:     2026-02-06T08:17:36.409Z
// ==========================================================
/**
 * DEPENDENCY GRAPH (Geen horizontale pijlen!)
 * 
 *     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *     ‚îÇ     MASTER ORCHESTRATOR              ‚îÇ
 *     ‚îÇ     (owns & instantiates all)        ‚îÇ
 *     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *            ‚Üì          ‚Üì          ‚Üì          ‚Üì
 *      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *      ‚îÇ   FSO   ‚îÇ ‚îÇ Render  ‚îÇ ‚îÇVisibility‚îÇ ‚îÇComponent‚îÇ
 *      ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ (private)‚îÇ
 *      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                       ‚Üì           ‚Üë
 *                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                     (Vertical OK!)
 * 
 * ‚úÖ NO horizontal arrows
 * ‚úÖ ALL via Master (or vertical: Render‚ÜíVisibility)
 * ‚úÖ Component gets callback, not FSO
 */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2066
// Timestamp:     2026-02-06T08:17:36.409Z
// ==========================================================
/**
 * DEPENDENCY GRAPH (Geen horizontale pijlen!)
 * 
 *     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *     ‚îÇ     MASTER ORCHESTRATOR              ‚îÇ
 *     ‚îÇ     (owns & instantiates all)        ‚îÇ
 *     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *            ‚Üì          ‚Üì          ‚Üì          ‚Üì
 *      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 *      ‚îÇ   FSO   ‚îÇ ‚îÇ Render  ‚îÇ ‚îÇVisibility‚îÇ ‚îÇComponent‚îÇ
 *      ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ         ‚îÇ ‚îÇ (private)‚îÇ
 *      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                       ‚Üì           ‚Üë
 *                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                     (Vertical OK!)
 * 
 * ‚úÖ NO horizontal arrows
 * ‚úÖ ALL via Master (or vertical: Render‚ÜíVisibility)
 * ‚úÖ Component gets callback, not FSO
 */


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2067
// Timestamp:     2026-02-06T08:17:36.410Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2068
// Timestamp:     2026-02-06T08:17:36.410Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2069
// Timestamp:     2026-02-06T08:17:36.413Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2070
// Timestamp:     2026-02-06T08:17:36.413Z
// ==========================================================
// In FormContext:
const master = new MasterOrchestrator(
  getState,
  dispatch,
  styles,
  timeProvider
);

// In WizardPage:
const { orchestrator } = useFormContext();  // master

// Build FieldViewModel (business-level)
const fieldVM = orchestrator.render.buildFieldViewModel('aantalMensen');

// Transform to ComponentViewModel (presentation-level)
const componentVM = orchestrator.buildComponentViewModel(fieldVM);

// Render
<FieldRenderer viewModel={componentVM} />


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2071
// Timestamp:     2026-02-06T08:17:36.413Z
// ==========================================================
new RenderOrchestrator(
  fso,
  (ruleName, context) => this.visibility.evaluate(ruleName, context)  // callback!
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2072
// Timestamp:     2026-02-06T08:17:36.413Z
// ==========================================================
// RenderOrchestrator build ZONDER visibility check
const fieldVM = orchestrator.render.buildFieldViewModelRaw(fieldId);

// Master doet visibility
if (fieldVM.visibilityRule && !orchestrator.isVisible(fieldVM.visibilityRule)) {
  return null;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2073
// Timestamp:     2026-02-06T08:17:36.413Z
// ==========================================================
// ComponentOrchestrator: ‚úÖ Krijgt callback (geen directe FSO)
this.component = new ComponentOrchestrator(
  (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Callback!
  styles
);

// RenderOrchestrator: ‚ùå Krijgt directe Visibility (horizontaal!)
this.render = new RenderOrchestrator(
  this.fso,
  this.visibility  // ‚Üê Direct! Horizontale dependency!
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2074
// Timestamp:     2026-02-06T08:17:36.414Z
// ==========================================================
// Master constructor
this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);

this.render = new RenderOrchestrator(
  this.fso,
  (ruleName: string, context?: VisibilityContext) => 
    this.visibility.evaluate(ruleName, context)  // ‚Üê Callback!
);

this.component = new ComponentOrchestrator(
  (fieldId: string, value: unknown) => this.updateField(fieldId, value),
  styles
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2075
// Timestamp:     2026-02-06T08:17:36.415Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2076
// Timestamp:     2026-02-06T08:17:36.415Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2077
// Timestamp:     2026-02-06T08:17:36.416Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2078
// Timestamp:     2026-02-06T08:17:36.418Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2079
// Timestamp:     2026-02-06T08:17:36.418Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2080
// Timestamp:     2026-02-06T08:17:36.418Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2081
// Timestamp:     2026-02-06T08:17:36.420Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2082
// Timestamp:     2026-02-06T08:17:36.420Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2083
// Timestamp:     2026-02-06T08:17:36.420Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // ‚úÖ RenderOrchestrator has NO visibility dependency!
    this.render = new RenderOrchestrator(this.fso);
    
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Build FieldViewModel WITH Visibility
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build field ViewModel with visibility evaluation
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility rule
   * 
   * Returns null if field is unknown OR not visible.
   * 
   * @param fieldId - Field identifier
   * @param context - Visibility context (memberId, etc.)
   * @returns FieldViewModel if visible, null if hidden
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Evaluate visibility (Master decides!)
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master hides field
      }
    }

    // Field is visible - return ViewModel
    return rawViewModel;
  }

  /**
   * Build page ViewModels (batch)
   * 
   * Convenience method for building multiple fields at once.
   * Filters out hidden fields automatically.
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * Assumes visibility already checked by buildFieldViewModel!
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel directly from fieldId (convenience)
   * 
   * Two-step process:
   * 1. Build FieldViewModel (with visibility)
   * 2. Transform to ComponentViewModel
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    return this.buildComponentViewModel(fieldViewModel);
  }

  // ... rest of Master methods (updateField, etc.)
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2084
// Timestamp:     2026-02-06T08:17:36.420Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // ‚úÖ RenderOrchestrator has NO visibility dependency!
    this.render = new RenderOrchestrator(this.fso);
    
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Build FieldViewModel WITH Visibility
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build field ViewModel with visibility evaluation
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility rule
   * 
   * Returns null if field is unknown OR not visible.
   * 
   * @param fieldId - Field identifier
   * @param context - Visibility context (memberId, etc.)
   * @returns FieldViewModel if visible, null if hidden
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Evaluate visibility (Master decides!)
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master hides field
      }
    }

    // Field is visible - return ViewModel
    return rawViewModel;
  }

  /**
   * Build page ViewModels (batch)
   * 
   * Convenience method for building multiple fields at once.
   * Filters out hidden fields automatically.
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * Assumes visibility already checked by buildFieldViewModel!
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel directly from fieldId (convenience)
   * 
   * Two-step process:
   * 1. Build FieldViewModel (with visibility)
   * 2. Transform to ComponentViewModel
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    return this.buildComponentViewModel(fieldViewModel);
  }

  // ... rest of Master methods (updateField, etc.)
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2085
// Timestamp:     2026-02-06T08:17:36.420Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2086
// Timestamp:     2026-02-06T08:17:36.420Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2087
// Timestamp:     2026-02-06T08:17:36.421Z
// ==========================================================
new RenderOrchestrator(
  fso,
  (ruleName, context) => this.visibility.evaluate(ruleName, context)  // callback!
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2088
// Timestamp:     2026-02-06T08:17:36.421Z
// ==========================================================
// RenderOrchestrator build ZONDER visibility check
const fieldVM = orchestrator.render.buildFieldViewModelRaw(fieldId);

// Master doet visibility
if (fieldVM.visibilityRule && !orchestrator.isVisible(fieldVM.visibilityRule)) {
  return null;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2089
// Timestamp:     2026-02-06T08:17:36.423Z
// ==========================================================
new RenderOrchestrator(
  fso,
  (ruleName, context) => this.visibility.evaluate(ruleName, context)  // callback!
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2090
// Timestamp:     2026-02-06T08:17:36.423Z
// ==========================================================
new RenderOrchestrator(
  fso,
  (ruleName, context) => this.visibility.evaluate(ruleName, context)  // callback!
)


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2091
// Timestamp:     2026-02-06T08:17:36.423Z
// ==========================================================
// RenderOrchestrator build ZONDER visibility check
const fieldVM = orchestrator.render.buildFieldViewModelRaw(fieldId);

// Master doet visibility
if (fieldVM.visibilityRule && !orchestrator.isVisible(fieldVM.visibilityRule)) {
  return null;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2092
// Timestamp:     2026-02-06T08:17:36.424Z
// ==========================================================
// RenderOrchestrator build ZONDER visibility check
const fieldVM = orchestrator.render.buildFieldViewModelRaw(fieldId);

// Master doet visibility
if (fieldVM.visibilityRule && !orchestrator.isVisible(fieldVM.visibilityRule)) {
  return null;
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2093
// Timestamp:     2026-02-06T08:17:36.426Z
// ==========================================================
// ComponentOrchestrator: ‚úÖ Krijgt callback (geen directe FSO)
this.component = new ComponentOrchestrator(
  (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Callback!
  styles
);

// RenderOrchestrator: ‚ùå Krijgt directe Visibility (horizontaal!)
this.render = new RenderOrchestrator(
  this.fso,
  this.visibility  // ‚Üê Direct! Horizontale dependency!
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2094
// Timestamp:     2026-02-06T08:17:36.426Z
// ==========================================================
// Master constructor
this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);

this.render = new RenderOrchestrator(
  this.fso,
  (ruleName: string, context?: VisibilityContext) => 
    this.visibility.evaluate(ruleName, context)  // ‚Üê Callback!
);

this.component = new ComponentOrchestrator(
  (fieldId: string, value: unknown) => this.updateField(fieldId, value),
  styles
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2095
// Timestamp:     2026-02-06T08:17:36.429Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2096
// Timestamp:     2026-02-06T08:17:36.429Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2097
// Timestamp:     2026-02-06T08:17:36.430Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2098
// Timestamp:     2026-02-06T08:17:36.430Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2099
// Timestamp:     2026-02-06T08:17:36.430Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2100
// Timestamp:     2026-02-06T08:17:36.432Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2101
// Timestamp:     2026-02-06T08:17:36.432Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2102
// Timestamp:     2026-02-06T08:17:36.437Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2103
// Timestamp:     2026-02-06T08:17:36.438Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // ‚úÖ RenderOrchestrator has NO visibility dependency!
    this.render = new RenderOrchestrator(this.fso);
    
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Build FieldViewModel WITH Visibility
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build field ViewModel with visibility evaluation
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility rule
   * 
   * Returns null if field is unknown OR not visible.
   * 
   * @param fieldId - Field identifier
   * @param context - Visibility context (memberId, etc.)
   * @returns FieldViewModel if visible, null if hidden
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Evaluate visibility (Master decides!)
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master hides field
      }
    }

    // Field is visible - return ViewModel
    return rawViewModel;
  }

  /**
   * Build page ViewModels (batch)
   * 
   * Convenience method for building multiple fields at once.
   * Filters out hidden fields automatically.
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * Assumes visibility already checked by buildFieldViewModel!
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel directly from fieldId (convenience)
   * 
   * Two-step process:
   * 1. Build FieldViewModel (with visibility)
   * 2. Transform to ComponentViewModel
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    return this.buildComponentViewModel(fieldViewModel);
  }

  // ... rest of Master methods (updateField, etc.)
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2104
// Timestamp:     2026-02-06T08:17:36.438Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly render: RenderOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    
    // ‚úÖ RenderOrchestrator has NO visibility dependency!
    this.render = new RenderOrchestrator(this.fso);
    
    this.research = new ResearchOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * NEW PUBLIC API: Build FieldViewModel WITH Visibility
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build field ViewModel with visibility evaluation
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility rule
   * 
   * Returns null if field is unknown OR not visible.
   * 
   * @param fieldId - Field identifier
   * @param context - Visibility context (memberId, etc.)
   * @returns FieldViewModel if visible, null if hidden
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Evaluate visibility (Master decides!)
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master hides field
      }
    }

    // Field is visible - return ViewModel
    return rawViewModel;
  }

  /**
   * Build page ViewModels (batch)
   * 
   * Convenience method for building multiple fields at once.
   * Filters out hidden fields automatically.
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   * PUBLIC API: COMPONENT VIEW MODELS
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  /**
   * Build ComponentViewModel from FieldViewModel
   * 
   * Assumes visibility already checked by buildFieldViewModel!
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel directly from fieldId (convenience)
   * 
   * Two-step process:
   * 1. Build FieldViewModel (with visibility)
   * 2. Transform to ComponentViewModel
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    return this.buildComponentViewModel(fieldViewModel);
  }

  // ... rest of Master methods (updateField, etc.)
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2105
// Timestamp:     2026-02-06T08:17:36.438Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2106
// Timestamp:     2026-02-06T08:17:36.438Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2107
// Timestamp:     2026-02-06T08:17:36.442Z
// ==========================================================
// ComponentOrchestrator: ‚úÖ Krijgt callback (geen directe FSO)
this.component = new ComponentOrchestrator(
  (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Callback!
  styles
);

// RenderOrchestrator: ‚ùå Krijgt directe Visibility (horizontaal!)
this.render = new RenderOrchestrator(
  this.fso,
  this.visibility  // ‚Üê Direct! Horizontale dependency!
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2108
// Timestamp:     2026-02-06T08:17:36.442Z
// ==========================================================
// ComponentOrchestrator: ‚úÖ Krijgt callback (geen directe FSO)
this.component = new ComponentOrchestrator(
  (fieldId, value) => this.updateField(fieldId, value),  // ‚Üê Callback!
  styles
);

// RenderOrchestrator: ‚ùå Krijgt directe Visibility (horizontaal!)
this.render = new RenderOrchestrator(
  this.fso,
  this.visibility  // ‚Üê Direct! Horizontale dependency!
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2109
// Timestamp:     2026-02-06T08:17:36.442Z
// ==========================================================
// Master constructor
this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);

this.render = new RenderOrchestrator(
  this.fso,
  (ruleName: string, context?: VisibilityContext) => 
    this.visibility.evaluate(ruleName, context)  // ‚Üê Callback!
);

this.component = new ComponentOrchestrator(
  (fieldId: string, value: unknown) => this.updateField(fieldId, value),
  styles
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2110
// Timestamp:     2026-02-06T08:17:36.444Z
// ==========================================================
// Master constructor
this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);

this.render = new RenderOrchestrator(
  this.fso,
  (ruleName: string, context?: VisibilityContext) => 
    this.visibility.evaluate(ruleName, context)  // ‚Üê Callback!
);

this.component = new ComponentOrchestrator(
  (fieldId: string, value: unknown) => this.updateField(fieldId, value),
  styles
);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2111
// Timestamp:     2026-02-06T08:17:36.445Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2112
// Timestamp:     2026-02-06T08:17:36.445Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2113
// Timestamp:     2026-02-06T08:17:36.445Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2114
// Timestamp:     2026-02-06T08:17:36.445Z
// ==========================================================
export type EvaluateVisibilityCallback = (
  ruleName: string,
  context?: VisibilityContext
) => boolean;

export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly evaluateVisibility: EvaluateVisibilityCallback  // ‚Üê Callback!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel | null {
    // ...
    const isVisible = fieldDef.visibilityRuleName
      ? this.evaluateVisibility(fieldDef.visibilityRuleName, context)  // ‚Üê Via callback!
      : true;
    // ...
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2115
// Timestamp:     2026-02-06T08:17:36.445Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2116
// Timestamp:     2026-02-06T08:17:36.445Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2117
// Timestamp:     2026-02-06T08:17:36.446Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2118
// Timestamp:     2026-02-06T08:17:36.447Z
// ==========================================================
// RenderOrchestrator: Build ViewModel WITHOUT visibility check
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  public buildFieldViewModel(fieldId: string, context?: VisibilityContext): FieldViewModel {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    const value = this.fso.getValue(fieldId);
    const options = getOptionsForField(fieldId);

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule, don't evaluate!
      // NO isVisible field!
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2119
// Timestamp:     2026-02-06T08:17:36.447Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2120
// Timestamp:     2026-02-06T08:17:36.449Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2121
// Timestamp:     2026-02-06T08:17:36.449Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2122
// Timestamp:     2026-02-06T08:17:36.450Z
// ==========================================================
export class MasterOrchestrator {
  // ...

  /**
   * Build field ViewModel WITH visibility check
   * 
   * Two-step process:
   * 1. RenderOrchestrator builds raw ViewModel
   * 2. Master evaluates visibility
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // Step 1: Build raw ViewModel (no visibility check)
    const rawViewModel = this.render.buildFieldViewModel(fieldId, context);
    if (!rawViewModel) return null;

    // Step 2: Master evaluates visibility
    if (rawViewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        rawViewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) {
        return null;  // ‚Üê Master decides to hide
      }
    }

    return {
      ...rawViewModel,
      isVisible: true,  // ‚Üê Master confirms visible
    };
  }

  /**
   * Build component ViewModel (two-step)
   */
  public buildComponentViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    // Step 1: Get field ViewModel (with visibility)
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;

    // Step 2: Transform to component ViewModel
    return this.component.buildComponentViewModel(fieldViewModel);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2123
// Timestamp:     2026-02-06T08:17:36.450Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2124
// Timestamp:     2026-02-06T08:17:36.451Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2125
// Timestamp:     2026-02-06T08:17:36.451Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2126
// Timestamp:     2026-02-06T08:17:36.452Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;  // ‚Üê Rule name, not evaluated!
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from field definitions.
 * 
 * DOES NOT:
 * - Evaluate visibility (Master does this!)
 * - Know about VisibilityOrchestrator
 * - Make decisions about showing/hiding
 * 
 * Pure transformation: FieldRegistry + State ‚Üí ViewModel
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility dependency!
  ) {}

  /**
   * Build FieldViewModel WITHOUT visibility evaluation
   * 
   * Returns null only if field is unknown.
   * Visibility evaluation is done by MasterOrchestrator!
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: unknown
  ): FieldViewModel | null {
    // Lookup field definition
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) {
      console.warn(`Unknown field: ${fieldId}`);
      return null;
    }

    // Get current value
    const value = this.fso.getValue(fieldId);

    // Get options (if applicable)
    const options = getOptionsForField(fieldId);

    // Build ViewModel (no visibility check!)
    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value,
      options,
      visibilityRuleName: fieldDef.visibilityRuleName,  // ‚Üê Include rule name
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2127
// Timestamp:     2026-02-06T08:17:36.454Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2128
// Timestamp:     2026-02-06T08:17:36.454Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2129
// Timestamp:     2026-02-06T08:17:36.454Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2130
// Timestamp:     2026-02-06T08:17:36.456Z
// ==========================================================
// src/ui/screens/Wizard/WizardPage.tsx

export const WizardPage: React.FC<WizardPageProps> = ({ config }) => {
  const { orchestrator } = useFormContext();

  // Build FieldViewModels (WITH visibility check by Master!)
  const fieldViewModels = useMemo(() => {
    return orchestrator.buildPageViewModels(
      config.fields.map(f => f.fieldId),
      context
    );
  }, [config.fields, orchestrator, context]);

  // Transform to ComponentViewModels
  const componentViewModels = useMemo(() => {
    return fieldViewModels
      .map((fieldVM) => orchestrator.buildComponentViewModel(fieldVM))
      .filter((vm): vm is ComponentViewModel => vm !== null);
  }, [fieldViewModels, orchestrator]);

  return (
    <ScrollView>
      {componentViewModels.map((vm) => (
        <FieldRenderer key={vm.fieldId} viewModel={vm} />
      ))}
    </ScrollView>
  );
};


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2131
// Timestamp:     2026-02-06T08:17:36.459Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator  // ‚Üê Direct!
)

// In buildFieldViewModel
const isVisible = this.visibility.evaluate(ruleName, context);  // ‚Üê Direct call!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2132
// Timestamp:     2026-02-06T08:17:36.459Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator
  // ‚Üê NO visibility!
)

// Master doet:
const rawVM = this.render.buildFieldViewModel(fieldId);
const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2133
// Timestamp:     2026-02-06T08:17:36.459Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2134
// Timestamp:     2026-02-06T08:17:36.459Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2135
// Timestamp:     2026-02-06T08:17:36.459Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2136
// Timestamp:     2026-02-06T08:17:36.459Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2137
// Timestamp:     2026-02-06T08:17:36.459Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2138
// Timestamp:     2026-02-06T08:17:36.459Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2139
// Timestamp:     2026-02-06T08:17:36.459Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2140
// Timestamp:     2026-02-06T08:17:36.460Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2141
// Timestamp:     2026-02-06T08:17:36.460Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator  // ‚Üê Direct!
)

// In buildFieldViewModel
const isVisible = this.visibility.evaluate(ruleName, context);  // ‚Üê Direct call!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2142
// Timestamp:     2026-02-06T08:17:36.460Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator
  // ‚Üê NO visibility!
)

// Master doet:
const rawVM = this.render.buildFieldViewModel(fieldId);
const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2143
// Timestamp:     2026-02-06T08:17:36.460Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator  // ‚Üê Direct!
)

// In buildFieldViewModel
const isVisible = this.visibility.evaluate(ruleName, context);  // ‚Üê Direct call!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2144
// Timestamp:     2026-02-06T08:17:36.460Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator,
  private readonly visibility: VisibilityOrchestrator  // ‚Üê Direct!
)

// In buildFieldViewModel
const isVisible = this.visibility.evaluate(ruleName, context);  // ‚Üê Direct call!


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2145
// Timestamp:     2026-02-06T08:17:36.460Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator
  // ‚Üê NO visibility!
)

// Master doet:
const rawVM = this.render.buildFieldViewModel(fieldId);
const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2146
// Timestamp:     2026-02-06T08:17:36.460Z
// ==========================================================
// RenderOrchestrator constructor
constructor(
  private readonly fso: FormStateOrchestrator
  // ‚Üê NO visibility!
)

// Master doet:
const rawVM = this.render.buildFieldViewModel(fieldId);
const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2147
// Timestamp:     2026-02-06T08:17:36.473Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2148
// Timestamp:     2026-02-06T08:17:36.474Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2149
// Timestamp:     2026-02-06T08:17:36.474Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2150
// Timestamp:     2026-02-06T08:17:36.474Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2151
// Timestamp:     2026-02-06T08:17:36.477Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2152
// Timestamp:     2026-02-06T08:17:36.477Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2153
// Timestamp:     2026-02-06T08:17:36.477Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2154
// Timestamp:     2026-02-06T08:17:36.477Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2155
// Timestamp:     2026-02-06T08:17:36.478Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2156
// Timestamp:     2026-02-06T08:17:36.478Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2157
// Timestamp:     2026-02-06T08:17:36.479Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2158
// Timestamp:     2026-02-06T08:17:36.481Z
// ==========================================================
export class VisibilityOrchestrator {
  public evaluate(ruleName: string, context?: VisibilityContext): boolean {
    // ‚Üê DEZE doet de eigenlijke check!
    return Conditions.isPensionAge(context?.leeftijd ?? 0);
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2159
// Timestamp:     2026-02-06T08:17:36.482Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2160
// Timestamp:     2026-02-06T08:17:36.482Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2161
// Timestamp:     2026-02-06T08:17:36.484Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2162
// Timestamp:     2026-02-06T08:17:36.487Z
// ==========================================================
export class MasterOrchestrator {
  public buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    if (rawVM.visibilityRuleName) {
      // Master ROEPT visibility orchestrator AAN
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      // ‚Üë VisibilityOrchestrator DOET de check, Master VRAAGT erom
    }
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2163
// Timestamp:     2026-02-06T08:17:36.488Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2164
// Timestamp:     2026-02-06T08:17:36.488Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2165
// Timestamp:     2026-02-06T08:17:36.488Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2166
// Timestamp:     2026-02-06T08:17:36.488Z
// ==========================================================
// RenderOrchestrator krijgt DIRECTE reference
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator,
    private readonly visibility: VisibilityOrchestrator  // ‚Üê HORIZONTAAL!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render roept DIRECT visibility aan
    const isVisible = this.visibility.evaluate(ruleName);  // ‚Üê HORIZONTAAL!
    return { ..., isVisible };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2167
// Timestamp:     2026-02-06T08:17:36.488Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2168
// Timestamp:     2026-02-06T08:17:36.489Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2169
// Timestamp:     2026-02-06T08:17:36.491Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2170
// Timestamp:     2026-02-06T08:17:36.491Z
// ==========================================================
// RenderOrchestrator krijgt GEEN visibility
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
    // ‚Üê NO visibility!
  ) {}

  buildFieldViewModel(fieldId: string) {
    // Render doet GEEN visibility check
    return {
      fieldId,
      visibilityRuleName: 'isPensionAge',  // ‚Üê Include rule name
      // NO isVisible field!
    };
  }
}

// Master CO√ñRDINEERT de check
export class MasterOrchestrator {
  buildFieldViewModel(fieldId: string, context?: VisibilityContext) {
    // 1. Vraag Render: bouw ViewModel
    const rawVM = this.render.buildFieldViewModel(fieldId);
    
    // 2. Vraag Visibility: is het zichtbaar?
    if (rawVM.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(rawVM.visibilityRuleName, context);
      //                 ‚Üë VisibilityOrchestrator DOET de check
      //                 Master VRAAGT erom
      
      if (!isVisible) return null;
    }
    
    // 3. Master BESLUIT: return ViewModel
    return rawVM;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2171
// Timestamp:     2026-02-06T08:17:36.492Z
// ==========================================================
// ‚ùå FOUT - Horizontaal
this.render = new RenderOrchestrator(this.fso, this.visibility);

// ‚úÖ GOED - Alleen FSO
this.render = new RenderOrchestrator(this.fso);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2172
// Timestamp:     2026-02-06T08:17:36.492Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from registry + state.
 * NO visibility evaluation - Master does that.
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
  ) {}

  public buildFieldViewModel(fieldId: string): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value: this.fso.getValue(fieldId),
      options: getOptionsForField(fieldId),
      visibilityRuleName: fieldDef.visibilityRuleName,
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2173
// Timestamp:     2026-02-06T08:17:36.493Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from registry + state.
 * NO visibility evaluation - Master does that.
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
  ) {}

  public buildFieldViewModel(fieldId: string): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value: this.fso.getValue(fieldId),
      options: getOptionsForField(fieldId),
      visibilityRuleName: fieldDef.visibilityRuleName,
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2174
// Timestamp:     2026-02-06T08:17:36.494Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator, FieldViewModel } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * PHOENIX MASTER ORCHESTRATOR
 * 
 * ENIGE plaats waar orchestrators elkaar "ontmoeten"
 * Alle communicatie verloopt via deze Master
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  private readonly render: RenderOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚úÖ NO orchestrator dependencies
    this.render = new RenderOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * Build FieldViewModel met visibility check
   * 
   * Master co√∂rdineert:
   * 1. Render bouwt ViewModel
   * 2. Visibility evalueert rule
   * 3. Master besluit: toon of verberg
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // 1. Render bouwt ViewModel
    const viewModel = this.render.buildFieldViewModel(fieldId);
    if (!viewModel) return null;

    // 2. Visibility evalueert (als er een rule is)
    if (viewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        viewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) return null;
    }

    // 3. Return visible ViewModel
    return viewModel;
  }

  /**
   * Build meerdere FieldViewModels (batch)
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * Build ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel direct van fieldId (convenience)
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;
    return this.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Visibility check (facade)
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ENIGE mutatie entry point
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2175
// Timestamp:     2026-02-06T08:17:36.494Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator, FieldViewModel } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * PHOENIX MASTER ORCHESTRATOR
 * 
 * ENIGE plaats waar orchestrators elkaar "ontmoeten"
 * Alle communicatie verloopt via deze Master
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  private readonly render: RenderOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚úÖ NO orchestrator dependencies
    this.render = new RenderOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * Build FieldViewModel met visibility check
   * 
   * Master co√∂rdineert:
   * 1. Render bouwt ViewModel
   * 2. Visibility evalueert rule
   * 3. Master besluit: toon of verberg
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // 1. Render bouwt ViewModel
    const viewModel = this.render.buildFieldViewModel(fieldId);
    if (!viewModel) return null;

    // 2. Visibility evalueert (als er een rule is)
    if (viewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        viewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) return null;
    }

    // 3. Return visible ViewModel
    return viewModel;
  }

  /**
   * Build meerdere FieldViewModels (batch)
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * Build ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel direct van fieldId (convenience)
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;
    return this.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Visibility check (facade)
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ENIGE mutatie entry point
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2176
// Timestamp:     2026-02-06T08:17:36.497Z
// ==========================================================
// ‚ùå FOUT - Horizontaal
this.render = new RenderOrchestrator(this.fso, this.visibility);

// ‚úÖ GOED - Alleen FSO
this.render = new RenderOrchestrator(this.fso);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2177
// Timestamp:     2026-02-06T08:17:36.503Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from registry + state.
 * NO visibility evaluation - Master does that.
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
  ) {}

  public buildFieldViewModel(fieldId: string): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value: this.fso.getValue(fieldId),
      options: getOptionsForField(fieldId),
      visibilityRuleName: fieldDef.visibilityRuleName,
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2178
// Timestamp:     2026-02-06T08:17:36.505Z
// ==========================================================
// src/app/orchestrators/RenderOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { FIELD_REGISTRY, getOptionsForField } from '@domain/registry/FieldRegistry';
import { ComponentType } from '@domain/registry/ComponentRegistry';

export interface FieldViewModel {
  fieldId: string;
  componentType: ComponentType;
  labelToken: string;
  placeholderToken?: string;
  value: unknown;
  options?: readonly string[];
  visibilityRuleName?: string;
  error: string | null;
}

/**
 * RENDER ORCHESTRATOR
 * 
 * Builds FieldViewModels from registry + state.
 * NO visibility evaluation - Master does that.
 */
export class RenderOrchestrator {
  constructor(
    private readonly fso: FormStateOrchestrator
  ) {}

  public buildFieldViewModel(fieldId: string): FieldViewModel | null {
    const fieldDef = FIELD_REGISTRY[fieldId];
    if (!fieldDef) return null;

    return {
      fieldId,
      componentType: fieldDef.componentType,
      labelToken: fieldDef.labelToken,
      placeholderToken: fieldDef.placeholderToken,
      value: this.fso.getValue(fieldId),
      options: getOptionsForField(fieldId),
      visibilityRuleName: fieldDef.visibilityRuleName,
      error: null,
    };
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2179
// Timestamp:     2026-02-06T08:17:36.508Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator, FieldViewModel } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * PHOENIX MASTER ORCHESTRATOR
 * 
 * ENIGE plaats waar orchestrators elkaar "ontmoeten"
 * Alle communicatie verloopt via deze Master
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  private readonly render: RenderOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚úÖ NO orchestrator dependencies
    this.render = new RenderOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * Build FieldViewModel met visibility check
   * 
   * Master co√∂rdineert:
   * 1. Render bouwt ViewModel
   * 2. Visibility evalueert rule
   * 3. Master besluit: toon of verberg
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // 1. Render bouwt ViewModel
    const viewModel = this.render.buildFieldViewModel(fieldId);
    if (!viewModel) return null;

    // 2. Visibility evalueert (als er een rule is)
    if (viewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        viewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) return null;
    }

    // 3. Return visible ViewModel
    return viewModel;
  }

  /**
   * Build meerdere FieldViewModels (batch)
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * Build ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel direct van fieldId (convenience)
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;
    return this.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Visibility check (facade)
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ENIGE mutatie entry point
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2180
// Timestamp:     2026-02-06T08:17:36.511Z
// ==========================================================
// src/app/orchestrators/MasterOrchestrator.ts

import { FormStateOrchestrator } from './FormStateOrchestrator';
import { ResearchOrchestrator } from './ResearchOrchestrator.WIP';
import { FinancialOrchestrator } from './FinancialOrchestrator';
import { ImportOrchestrator } from './ImportOrchestrator';
import { VisibilityOrchestrator, VisibilityContext } from './VisibilityOrchestrator';
import { RenderOrchestrator, FieldViewModel } from './RenderOrchestrator';
import { ComponentOrchestrator } from './ComponentOrchestrator';
import { ComponentViewModel } from '@domain/registry/ComponentRegistry';
import { validateAtBoundary } from '@adapters/validation/validateAtBoundary';
import { logger } from '@adapters/audit/AuditLoggerAdapter';
import { formatToDisplay } from '@domain/helpers/DateHydrator';
import { TimeProvider } from '@domain/helpers/TimeProvider';
import type { FormState, FormAction } from '@core/types/core';

/**
 * PHOENIX MASTER ORCHESTRATOR
 * 
 * ENIGE plaats waar orchestrators elkaar "ontmoeten"
 * Alle communicatie verloopt via deze Master
 */
export class MasterOrchestrator {
  public readonly fso: FormStateOrchestrator;
  public readonly visibility: VisibilityOrchestrator;
  public readonly research: ResearchOrchestrator;
  
  private readonly render: RenderOrchestrator;
  private readonly component: ComponentOrchestrator;

  constructor(
    getState: () => FormState,
    dispatch: (action: FormAction) => void,
    styles: any,
    timeProvider: TimeProvider
  ) {
    this.fso = new FormStateOrchestrator(getState, dispatch);
    this.visibility = new VisibilityOrchestrator(this.fso, timeProvider);
    this.research = new ResearchOrchestrator(this.fso);
    
    // ‚úÖ NO orchestrator dependencies
    this.render = new RenderOrchestrator(this.fso);
    
    this.component = new ComponentOrchestrator(
      (fieldId: string, value: unknown) => this.updateField(fieldId, value),
      styles
    );
  }

  /**
   * Build FieldViewModel met visibility check
   * 
   * Master co√∂rdineert:
   * 1. Render bouwt ViewModel
   * 2. Visibility evalueert rule
   * 3. Master besluit: toon of verberg
   */
  public buildFieldViewModel(
    fieldId: string,
    context?: VisibilityContext
  ): FieldViewModel | null {
    // 1. Render bouwt ViewModel
    const viewModel = this.render.buildFieldViewModel(fieldId);
    if (!viewModel) return null;

    // 2. Visibility evalueert (als er een rule is)
    if (viewModel.visibilityRuleName) {
      const isVisible = this.visibility.evaluate(
        viewModel.visibilityRuleName,
        context
      );
      
      if (!isVisible) return null;
    }

    // 3. Return visible ViewModel
    return viewModel;
  }

  /**
   * Build meerdere FieldViewModels (batch)
   */
  public buildPageViewModels(
    fieldIds: string[],
    context?: VisibilityContext
  ): FieldViewModel[] {
    return fieldIds
      .map((fieldId) => this.buildFieldViewModel(fieldId, context))
      .filter((vm): vm is FieldViewModel => vm !== null);
  }

  /**
   * Build ComponentViewModel
   */
  public buildComponentViewModel(
    fieldViewModel: FieldViewModel
  ): ComponentViewModel | null {
    return this.component.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Build ComponentViewModel direct van fieldId (convenience)
   */
  public buildComponentViewModelById(
    fieldId: string,
    context?: VisibilityContext
  ): ComponentViewModel | null {
    const fieldViewModel = this.buildFieldViewModel(fieldId, context);
    if (!fieldViewModel) return null;
    return this.buildComponentViewModel(fieldViewModel);
  }

  /**
   * Visibility check (facade)
   */
  public isVisible(ruleName: string, context?: VisibilityContext): boolean {
    return this.visibility.evaluate(ruleName, context);
  }

  /**
   * ENIGE mutatie entry point
   */
  public updateField(fieldId: string, value: unknown): void {
    const result = validateAtBoundary(fieldId, value);

    if (!result.success) {
      logger.warn(result.error, { fieldId, value });
      return;
    }

    this.fso.updateField(fieldId, result.data);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });
  }

  /**
   * CSV Import
   */
  public async handleCsvImport(csvText: string): Promise<void> {
    const state = this.fso.getState();

    const result = ImportOrchestrator.processCsvImport(this.research, {
      csvText,
      members: state.data.household.members,
      setupData: state.data.setup,
    });

    this.fso.updateField('transactions', result.transactions);

    const newSummary = FinancialOrchestrator.prepareViewModel(
      this.fso.getState(),
    );

    this.fso.dispatch({
      type: 'UPDATE_VIEWMODEL',
      payload: { financialSummary: newSummary },
    });

    if (result.summary.isDiscrepancy) {
      logger.warn('import.discrepancy_found', { details: result.summary });
    } else {
      logger.info('import.success', { count: result.transactions.length });
    }
  }

  /**
   * Value getters
   */
  public getValue(fieldId: string): unknown {
    return this.fso.getValue(fieldId);
  }

  public getFormattedDate(
    fieldId: string,
    format?: 'dd-mm-yyyy' | 'weekday' | 'short' | 'full',
  ): string {
    const value = this.fso.getValue(fieldId);

    if (value instanceof Date) {
      return formatToDisplay(value, format);
    }

    if (typeof value === 'string' && value !== '') {
      const d = new Date(value);
      return isNaN(d.getTime()) ? value : formatToDisplay(d, format);
    }

    return '';
  }

  /**
   * Validation
   */
  public validate(fieldId: string, value: unknown): string | null {
    const r = validateAtBoundary(fieldId, value);

    if (!r.success) {
      logger.warn(r.error, { fieldId });
      return r.error;
    }

    return null;
  }
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2181
// Timestamp:     2026-02-06T08:17:36.515Z
// ==========================================================
// ‚ùå FOUT - Horizontaal
this.render = new RenderOrchestrator(this.fso, this.visibility);

// ‚úÖ GOED - Alleen FSO
this.render = new RenderOrchestrator(this.fso);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2182
// Timestamp:     2026-02-06T08:17:36.515Z
// ==========================================================
// ‚ùå FOUT - Horizontaal
this.render = new RenderOrchestrator(this.fso, this.visibility);

// ‚úÖ GOED - Alleen FSO
this.render = new RenderOrchestrator(this.fso);


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2183
// Timestamp:     2026-02-06T08:17:36.516Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2184
// Timestamp:     2026-02-06T08:17:36.519Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2185
// Timestamp:     2026-02-06T08:17:36.519Z
// ==========================================================
// ‚ùå DELETE deze 2 methoden uit MasterOrchestrator:
public getComponentType(fieldId: string, baseType: string): string { ... }
public getOptions(fieldId: string): readonly string[] { ... }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2186
// Timestamp:     2026-02-06T08:17:36.519Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2187
// Timestamp:     2026-02-06T08:17:36.524Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2188
// Timestamp:     2026-02-06T08:17:36.526Z
// ==========================================================
// ‚ùå DELETE deze 2 methoden uit MasterOrchestrator:
public getComponentType(fieldId: string, baseType: string): string { ... }
public getOptions(fieldId: string): readonly string[] { ... }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2189
// Timestamp:     2026-02-06T08:17:36.526Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2190
// Timestamp:     2026-02-06T08:17:36.527Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2191
// Timestamp:     2026-02-06T08:17:36.528Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2192
// Timestamp:     2026-02-06T08:17:36.528Z
// ==========================================================
// JOUW BESTAANDE CODE (regel 49-62):

/**
 * UX & UI Regie
 */

// Geeft door welk technisch component er gebruikt moet worden
public getComponentType(fieldId: string, baseType: string): string {
  // Voor nu mappen we het 1-op-1, maar hier kan later de UX-logica komen
  // Bijv: als fieldId 'woningType' is en we zijn op mobiel -> 'swipecard'
  return baseType; 
}

// Haalt de opties op (nu nog even simpel, later uit options.ts)
public getOptions(fieldId: string): readonly string[] {
  const optionsMap: Record<string, readonly string[]> = {
    autoCount: ['Geen', 'Een', 'Twee'],
    woningType: ['Huur', 'Koop', 'Inwonend'],
  };
  return optionsMap[fieldId] ?? [];
}


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2193
// Timestamp:     2026-02-06T08:17:36.528Z
// ==========================================================
// ‚ùå DELETE deze 2 methoden uit MasterOrchestrator:
public getComponentType(fieldId: string, baseType: string): string { ... }
public getOptions(fieldId: string): readonly string[] { ... }


// ==========================================================
// Extracted from: claude_ChipButton component DOM-optimalisatie - Claude (1).json
// Block #:       2194
// Timestamp:     2026-02-06T08:17:36.530Z
// ==========================================================
// ‚ùå DELETE deze 2 methoden uit MasterOrchestrator:
public getComponentType(fieldId: string, baseType: string): string { ... }
public getOptions(fieldId: string): readonly string[] { ... }
